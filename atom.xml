<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>似水年华--沉浮</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://idber.github.io/"/>
  <updated>2019-05-09T07:29:18.693Z</updated>
  <id>http://idber.github.io/</id>
  
  <author>
    <name>Michael Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在Mac上使用CLion编译MySQL</title>
    <link href="http://idber.github.io/2019/05/09-%E5%9C%A8Mac%E4%B8%8A%E4%BD%BF%E7%94%A8CLion%E7%BC%96%E8%AF%91MySQL.html"/>
    <id>http://idber.github.io/2019/05/09-在Mac上使用CLion编译MySQL.html</id>
    <published>2019-05-09T02:01:56.000Z</published>
    <updated>2019-05-09T07:29:18.693Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h1 id=&quot;源码获取&quot;&gt;&lt;a href=&quot;#源码获取&quot; class=&quot;headerlink&quot; title=&quot;源码获取&quot;&gt;&lt;/a&gt;源码获取&lt;/h1&gt;&lt;p&gt;git clone &lt;a href=&quot;https://github.com/mysql/mysql-server&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/mysql/mysql-server&lt;/a&gt;&lt;br&gt;or&lt;br&gt;&lt;a href=&quot;https://dev.mysql.com/downloads/mysql/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/downloads/mysql/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解压&lt;br&gt;mysql-server 为源码目录&lt;br&gt;新建mysql、data目录&lt;br&gt;mysql为basedir&lt;br&gt;data为datadir&lt;/p&gt;
&lt;h1 id=&quot;编译安装初始化数据库&quot;&gt;&lt;a href=&quot;#编译安装初始化数据库&quot; class=&quot;headerlink&quot; title=&quot;编译安装初始化数据库&quot;&gt;&lt;/a&gt;编译安装初始化数据库&lt;/h1&gt;&lt;p&gt;cd mysql-server&lt;/p&gt;
&lt;p&gt;cmake \&lt;br&gt;-DCMAKE_INSTALL_PREFIX=/your_path/mysql \&lt;br&gt;-DMYSQL_DATADIR=/your_path/mysql/data \&lt;br&gt;-DSYSCONFDIR=/your_path/mysql \&lt;br&gt;-DMYSQL_UNIX_ADDR=/your_path/mysql/mysql.sock \&lt;br&gt;-DWITH_DEBUG=1  \&lt;br&gt;-DDOWNLOAD_BOOST=1 -DWITH_BOOST=/your_path/mysql-server/ -DDOWNLOAD_BOOST_TIMEOUT=60000&lt;/p&gt;
&lt;p&gt;make -j 4 &lt;/p&gt;
&lt;p&gt;make install -j 4&lt;/p&gt;
&lt;h1 id=&quot;初始化数据库&quot;&gt;&lt;a href=&quot;#初始化数据库&quot; class=&quot;headerlink&quot; title=&quot;初始化数据库&quot;&gt;&lt;/a&gt;初始化数据库&lt;/h1&gt;&lt;p&gt;/your_path/mysql/scripts/mysql_install_db –user=mysql –basedir=/your_path/mysql –datadir=/Users/xmzj/SourceCode/mysql/data&lt;br&gt;不同版本数据库有不同初始化方式，本文使用的是MySQL 5.6&lt;/p&gt;
&lt;p&gt;启动MySQL，测试下是否安装成功&lt;/p&gt;
&lt;p&gt;/path/mysql/bin/mysqld –defaults-file=/path/mysql/my.cnf&lt;/p&gt;
&lt;p&gt;在CLion欢迎页选择New CMake Project from Sources,选中CMakeLists.txt，Open Existing Project&lt;br&gt;CLion会自动Load工程&lt;br&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/source_code/source_code01.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;然后，CLion 偏好设置，Build, Execution, Deployment 的CMake选项&lt;br&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/source_code/source_code02.jpeg?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;CMake Options和你编译安装时的选项一致&lt;/p&gt;
&lt;p&gt;-DCMAKE_INSTALL_PREFIX=/path/mysql&lt;br&gt;-DMYSQL_DATADIR=/path/mysql/data&lt;br&gt;-DSYSCONFDIR=/path/mysql&lt;br&gt;-DMYSQL_UNIX_ADDR=/path/mysql/mysql.sock&lt;br&gt;-DWITH_DEBUG=1  &lt;/p&gt;
&lt;p&gt;然后在CLion里，Reload CMake Project&lt;br&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/source_code/source_code03.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Run/Debug列表里就可以看到很多选项了 Edit Configurations…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/source_code/source_code04.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;找到mysqld配置下启动参数 mysqld配置下启动参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/source_code/source_code05.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;mysqld –defaults-file=/path/mysql/etc/my.cnf&lt;br&gt;然后以Debug模式启动，看下成功的效果 Debug模式启动&lt;br&gt;这里故意把ib_qry_type_t改为0ib_qry_type_t 让它报错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/source_code/source_code06.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;学习MySQL源码的文档&quot;&gt;&lt;a href=&quot;#学习MySQL源码的文档&quot; class=&quot;headerlink&quot; title=&quot;学习MySQL源码的文档&quot;&gt;&lt;/a&gt;学习MySQL源码的文档&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/internals/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/internals/en/&lt;/a&gt;&lt;br&gt;可以找到想要学习的功能的源码位置，比如主从同步功能（replication） &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/internals/en/replication-source-code-files.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/internals/en/replication-source-code-files.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;源码获取&quot;&gt;&lt;a href=&quot;#源码获取&quot; class=&quot;headerlink&quot; title=&quot;源码获取&quot;&gt;&lt;/a&gt;源码获取&lt;/h1&gt;&lt;p&gt;git clone &lt;a href=&quot;https://github.com/mysql/mysql-server&quot;
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="源码" scheme="http://idber.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的三种排序算法</title>
    <link href="http://idber.github.io/2019/04/28-MySQL%E7%9A%84%E4%B8%89%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html"/>
    <id>http://idber.github.io/2019/04/28-MySQL的三种排序算法.html</id>
    <published>2019-04-28T02:01:56.000Z</published>
    <updated>2019-04-30T03:17:35.940Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;MySQL内部实现排序主要有3种方式，常规排序，优化排序和优先队列排序，主要涉及3种排序算法：快速排序、归并排序和堆排序。&lt;/p&gt;
&lt;p&gt;关于排序算法，Youtube上有套有意思的3D机器人演示视频命令，方便理解。&lt;br&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=aXXWXz5rF64&amp;amp;index=2&amp;amp;list=PL2aHrV9pFqNRS2b2XX2BvgQIPKh72xREP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;via&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;p&gt;快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/p&gt;
&lt;p&gt;快速排序是对冒泡排序的一种改进。在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。&lt;/p&gt;
&lt;p&gt;快速排序使用分治法（Divide and conquer， 在计算机科学中，分治法是建基于多项分支递归的一种很重要的算法范式。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。&lt;/p&gt;
&lt;p&gt;步骤为：&lt;br&gt;挑选基准值：从数列中挑出一个元素，称为“基准”（pivot），&lt;br&gt;分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，&lt;br&gt;递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。&lt;br&gt;递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。&lt;/p&gt;
&lt;p&gt;由于基准是随机的，所以快速排序是不稳定排序。&lt;/p&gt;
&lt;h1 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h1&gt;&lt;p&gt;归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。&lt;br&gt;把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。&lt;br&gt;可从上到下或从下到上进行。&lt;/p&gt;
&lt;p&gt;归并操作&lt;br&gt;归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。&lt;/p&gt;
&lt;p&gt;步骤为：&lt;br&gt;申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列&lt;br&gt;设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;br&gt;比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&lt;br&gt;重复步骤3直到某一指针到达序列尾&lt;br&gt;将另一序列剩下的所有元素直接复制到合并序列尾&lt;/p&gt;
&lt;h1 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h1&gt;&lt;p&gt;堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。&lt;br&gt;从堆顶把根卸出来放在有序区之前，再恢复堆。&lt;/p&gt;
&lt;p&gt;若以升序排序说明，把数组转换成最大堆积(Max-Heap Heap)，这是一种满足最大堆积性质(Max-Heap Property)的二叉树：对于除了根之外的每个节点i, A[parent(i)] ≥ A[i]。&lt;/p&gt;
&lt;p&gt;重复从最大堆积取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆积维持最大堆积性质。&lt;/p&gt;
&lt;p&gt;堆的操作&lt;br&gt;在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作：&lt;br&gt;最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点&lt;br&gt;创建最大堆（Build Max Heap）：将堆中的所有数据重新排序&lt;br&gt;堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算&lt;/p&gt;
&lt;h1 id=&quot;MySQL的排序&quot;&gt;&lt;a href=&quot;#MySQL的排序&quot; class=&quot;headerlink&quot; title=&quot;MySQL的排序&quot;&gt;&lt;/a&gt;MySQL的排序&lt;/h1&gt;&lt;p&gt;a.常规排序&lt;br&gt;(1).从表t1中获取满足WHERE条件的记录&lt;br&gt;(2).对于每条记录，将记录的主键+排序键(id,col2)取出放入sort buffer&lt;br&gt;(3).如果sort buffer可以存放所有满足条件的(id,col2)对，则进行排序；否则sort buffer满后，进行排序并固化到临时文件中。(排序算法采用的是快速排序算法)&lt;br&gt;(4).若排序中产生了临时文件，需要利用归并排序算法，保证临时文件中记录是有序的&lt;br&gt;(5).循环执行上述过程，直到所有满足条件的记录全部参与排序&lt;br&gt;(6).扫描排好序的(id,col2)对，并利用id去捞取SELECT需要返回的列(col1,col2,col3)&lt;br&gt;(7).将获取的结果集返回给用户。&lt;br&gt;      从上述流程来看，是否使用文件排序主要看sort buffer是否能容下需要排序的(id,col2)对，这个buffer的大小由sort_buffer_size参数控制。此外一次排序需要两次IO，一次是捞(id,col2),第二次是捞(col1,col2,col3)，由于返回的结果集是按col2排序，因此id是乱序的，通过乱序的id去捞(col1,col2,col3)时会产生大量的随机IO。对于第二次MySQL本身一个优化，即在捞之前首先将id排序，并放入缓冲区，这个缓存区大小由参数read_rnd_buffer_size控制，然后有序去捞记录，将随机IO转为顺序IO。&lt;/p&gt;
&lt;p&gt;b.优化排序&lt;br&gt;     常规排序方式除了排序本身，还需要额外两次IO。优化的排序方式相对于常规排序，减少了第二次IO。主要区别在于，放入sort buffer不是(id,col2),而是(col1,col2,col3)。由于sort buffer中包含了查询需要的所有字段，因此排序完成后可以直接返回，无需二次捞数据。这种方式的代价在于，同样大小的sort buffer，能存放的(col1,col2,col3)数目要小于(id,col2)，如果sort buffer不够大，可能导致需要写临时文件，造成额外的IO。当然MySQL提供了参数max_length_for_sort_data，只有当排序元组小于max_length_for_sort_data时，才能利用优化排序方式，否则只能用常规排序方式。&lt;/p&gt;
&lt;p&gt;c.优先队列排序&lt;br&gt;     为了得到最终的排序结果，无论怎样，我们都需要将所有满足条件的记录进行排序才能返回。那么相对于优化排序方式，是否还有优化空间呢？5.6版本针对Order by limit M，N语句，在空间层面做了优化，加入了一种新的排序方式–优先队列，这种方式采用堆排序实现。堆排序算法特征正好可以解limit M，N 这类排序的问题，虽然仍然需要所有元素参与排序，但是只需要M+N个元组的sort buffer空间即可，对于M，N很小的场景，基本不会因为sort buffer不够而导致需要临时文件进行归并排序的问题。对于升序，采用大顶堆，最终堆中的元素组成了最小的N个元素，对于降序，采用小顶堆，最终堆中的元素组成了最大的N的元素。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;MySQL内部实现排序主要有3种方式，常规排序，优化排序和优先队列排序，主要涉及3种排序算法：快速排序、归并排序和堆排序。&lt;/p&gt;
&lt;p&gt;关于排序算法，Youtube上有套有意思的3D机器人演示视频命令，方便理解。&lt;br&gt;&lt;a href=&quot;https://www.
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="排序" scheme="http://idber.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="优化" scheme="http://idber.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Purge死锁</title>
    <link href="http://idber.github.io/2018/10/01-Purge%E6%AD%BB%E9%94%81.html"/>
    <id>http://idber.github.io/2018/10/01-Purge死锁.html</id>
    <published>2018-09-30T22:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.932Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;p&gt;场景：业务批量删除，然后插入操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select @@tx_isolation;
+----------------+
| @@tx_isolation |
+----------------+
| READ-COMMITTED |
+----------------+
1 row in set, 1 warning (0.00 sec)

set global innodb_status_output_locks=1;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启用后，InnoDB锁定监视器会打印有关SHOW ENGINE INNODB STATUS输出锁定的附加信息&lt;/p&gt;
&lt;p&gt;为了演示繁忙的场景，使用debug版本启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/home/mysql/mysql/bin/mysqld-debug --basedir=/home/mysql/mysql --datadir=/home/mysql/data

set global innodb_purge_stop_now=1;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;show这个变量􏰀,结果还是off,这个不用管,purge线程已􏰁停止了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table test_purge(a int auto_increment primary key, b int , unique key(b));

insert into test_purge(b) values(10),(20),(30),(40),(50),(60);

select * from test_purge;
+---+------+
| a | b    |
+---+------+
| 1 |   10 |
| 2 |   20 |
| 3 |   30 |
| 4 |   40 |
| 5 |   50 |
| 6 |   60 |
+---+------+
6 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;加锁过程&quot;&gt;&lt;a href=&quot;#加锁过程&quot; class=&quot;headerlink&quot; title=&quot;加锁过程&quot;&gt;&lt;/a&gt;加锁过程&lt;/h1&gt;&lt;p&gt;终端会话1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delete from test_purge where b=20;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;终端会话2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from test_purge;
beign;
insert into test_purge(b) values(20);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;终端会话3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pager less


show engine innodb status\G

---TRANSACTION 3342, ACTIVE 22 sec
3 lock struct(s), heap size 1160, 3 row lock(s), undo log entries 1
MySQL thread id 4, OS thread handle 139843750467328, query id 11 localhost root
TABLE LOCK table `guo_test`.`test_purge` trx id 3342 lock mode IX
RECORD LOCKS space id 28 page no 4 n bits 72 index b of table `guo_test`.`test_purge` trx id 3342 lock mode S
Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 32
 0: len 4; hex 80000014; asc     ;;
 1: len 4; hex 80000002; asc     ;;

-- heap no=3表示是第二个插入的记录20
-- 且info bits为32,表示记录被标记删除了
0: len 4; hex 80000014; asc ;; -- 记录为20
1: len 4; hex 80000002; asc ;; -- 对应的主键为2


Record lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 4; hex 8000001e; asc     ;;
 1: len 4; hex 80000003; asc     ;;
-- heap no=4表示的是20的下一个记录30
-- 且该记录上也有S lock
RECORD LOCKS space id 28 page no 4 n bits 72 index b of table `guo_test`.`test_purge` trx id 3342 lock mode S locks gap before rec
Record lock, heap no 6 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 #heap no=6为新插入的记录20,从隐式锁提升为显示锁
 0: len 4; hex 80000014; asc     ;;
 1: len 4; hex 80000005; asc     ;;
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;因为是唯一索引,需要做唯一性检查,从老的记录 20&lt;em&gt; 开始检查(第一个小于等于自己的值),则此时 20&lt;/em&gt; 上要加上一把 S lock ,然后往下检查到第一个不相等的记录,即 记录30 ,然后退出,但是这个 记录30 也要 加上S lock&lt;/li&gt;
&lt;li&gt;在插入新的记录20的时候,发现下一条记录30上有锁,则自己插入的时的隐式锁提升为显示锁(见插入步骤)&lt;/li&gt;
&lt;li&gt;目前锁住的范围是 (10,20], (20,30]&lt;/li&gt;
&lt;li&gt;新插入的记录20本身是一把 S-Gap Lock (前面20*的有S lock了,由于是唯一索引,本身其实就不需要有记录锁了,有GAP就够了)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以25，15都无法插入，都在锁定区间&lt;br&gt;会话3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@guo_test 01:48:14&amp;gt;insert into test_purge(b) values(25);
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
root@guo_test 01:48:23&amp;gt;insert into test_purge(b) values(15);
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;Purge死锁演示&quot;&gt;&lt;a href=&quot;#Purge死锁演示&quot; class=&quot;headerlink&quot; title=&quot;Purge死锁演示&quot;&gt;&lt;/a&gt;Purge死锁演示&lt;/h1&gt;&lt;p&gt;删除50，20前面已经删除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delete from test_purge where b=50;
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;T1&lt;/th&gt;
&lt;th&gt;T2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;begin;&lt;/td&gt;
&lt;td&gt;begin;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insert into test_purge(b) values(25);&lt;/td&gt;
&lt;td&gt;insert into test_purge(b) values(55);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insert into test_purge(b) values(50);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;insert into test_purge(b) values(20);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Deadlock found..&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insert into test_purge(b) values(50);Query OK, 1 row affected (2.32 sec)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;show engine innodb status\G&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LATEST DETECTED DEADLOCK
------------------------
2018-09-18 12:25:41 0x7ff339aca700
*** (1) TRANSACTION:
TRANSACTION 6692, ACTIVE 53 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 4 lock struct(s), heap size 1160, 4 row lock(s), undo log entries 2
MySQL thread id 4, OS thread handle 140682621667072, query id 27 localhost root update
insert into test_purge(b) values(50)
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 35 page no 4 n bits 80 index b of table `guo_test`.`test_purge` trx id 6692 lock mode S waiting
Record lock, heap no 9 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 4; hex 80000037; asc    7;;     #等待55的S锁
 1: len 4; hex 80000008; asc     ;;

*** (2) TRANSACTION:
TRANSACTION 6693, ACTIVE 28 sec inserting, thread declared inside InnoDB 5000
mysql tables in use 1, locked 1
4 lock struct(s), heap size 1160, 4 row lock(s), undo log entries 2
MySQL thread id 5, OS thread handle 140682621396736, query id 28 localhost root update
insert into test_purge(b) values(20)
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 35 page no 4 n bits 80 index b of table `guo_test`.`test_purge` trx id 6693 lock_mode X locks rec but not gap
Record lock, heap no 9 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 4; hex 80000037; asc    7;;      #持有55的S锁
 1: len 4; hex 80000008; asc     ;;

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 35 page no 4 n bits 80 index b of table `guo_test`.`test_purge` trx id 6693 lock mode S waiting
Record lock, heap no 8 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 4; hex 80000019; asc     ;;      #等待25的S锁
 1: len 4; hex 80000007; asc     ;;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;该问题的场景&quot;&gt;&lt;a href=&quot;#该问题的场景&quot; class=&quot;headerlink&quot; title=&quot;该问题的场景&quot;&gt;&lt;/a&gt;该问题的场景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使用了唯一索引(主要原因)&lt;/li&gt;
&lt;li&gt;大量delete数据后,又立即插入了数据&lt;/li&gt;
&lt;li&gt;插入的数据和部分删除的数据的唯一索引一样,且purge还没有来得及回收删除的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;delete后等待较长时间后(增大purge线程数,等Purge回收),再插入新数据 (不推荐) &lt;/li&gt;
&lt;li&gt;使用普通索引&lt;/li&gt;
&lt;li&gt;仍然使用唯一索引,但是插入前要对唯一索引进行分线程排序 (只会有等待,不会有死锁)&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;p&gt;场景：业务批量删除，然后插入操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select @@tx_isolation;
+-
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="死锁" scheme="http://idber.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Percona Xtrabackup 2.4 恢复指定表</title>
    <link href="http://idber.github.io/2018/09/09-Percona%20Xtrabackup%202.4%20%E6%81%A2%E5%A4%8D%E6%8C%87%E5%AE%9A%E8%A1%A8.html"/>
    <id>http://idber.github.io/2018/09/09-Percona Xtrabackup 2.4 恢复指定表.html</id>
    <published>2018-09-08T22:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.932Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;在5.6之前的服务版本，在不同的MySQL服务中通过复制表的文件来拷贝表是不可能的，即使启用了innodb_file_per_table。然而，通过Percona XtraBackup，可以从任意的InnoDB数据库中导出指定的表，并将它们导入到使用XtraDB的Percona服务中或MySQL 5.6。这只对.ibd文件有效。 &lt;/p&gt;
&lt;p&gt;创建测试表 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE `export_test` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `a` varchar(60) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3   ROW_FORMAT=DYNAMIC  DEFAULT CHARSET=utf8

insert into `test`.`export_test` ( `a`) values ( &amp;apos;aaa&amp;apos;);
insert into `test`.`export_test` ( `a`) values ( &amp;apos;ddd&amp;apos;);
insert into `test`.`export_test` ( `a`) values ( &amp;apos;ccc&amp;apos;);
insert into `test`.`export_test` ( `a`) values ( &amp;apos;dddccc&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;确认innodb_file_per_table是否开启&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like &amp;apos;innodb_file_per_table&amp;apos;; 
+-----------------------+-------+ 
| Variable_name         | Value | 
+-----------------------+-------+ 
| innodb_file_per_table | ON    | 
+-----------------------+-------+ 
1 row in set (0.00 sec) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;确认行格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show variables like &amp;apos;%format%&amp;apos;;
+---------------------------+-------------------+
| Variable_name             | Value             |
+---------------------------+-------------------+
| binlog_format             | ROW               |
| date_format               | %Y-%m-%d          |
| datetime_format           | %Y-%m-%d %H:%i:%s |
| default_week_format       | 0                 |
| innodb_default_row_format | dynamic           |
| innodb_file_format        | Barracuda         |
| innodb_file_format_check  | ON                |
| innodb_file_format_max    | Barracuda         |
| time_format               | %H:%i:%s          |
+---------------------------+-------------------+
9 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行备份 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;innobackupex --defaults-file=/etc/my.cnf --user=bkuser --password=xxxx  --socket=/tmp/mysql.sock ~/backup/fullbackup/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;导出的表必须是以 innodb_file_per_table 格式创建，在备份目录中以.bd文件格式存在。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;find . -name export_test.*
./guo_test/export_test.ibd
./guo_test/export_test.frm
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当准备备份的时候，增加xtrabackup –export参数到命令中。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;innobackupex --user=root --password=root --no-timestamp --apply-log --export ./
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在目标目录下，可以看到.exp文件 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;find . -name export_test.*
./guo_test/export_test.ibd
./guo_test/export_test.exp
./guo_test/export_test.cfg
./guo_test/export_test.frm
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;.exp、.ibd、.cfg这三个文件用于数据库导入中&lt;br&gt;Percona官方对这三个文件的描述&lt;br&gt;After this, copy mytable.ibd and mytable.exp ( or mytable.cfg if importing to MySQL 5.6) files to database’s home, and import its tablespace:&lt;/p&gt;
&lt;p&gt;删除表 （如果表结构一致可以不用删除）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop table export_test; 
Query OK, 0 rows affected (1.45 sec) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在目标MySQL服务器上，创建一张具有相同结构的空表。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE `export_test` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `a` varchar(60) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3   ROW_FORMAT=DYNAMIC  DEFAULT CHARSET=utf8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;清除表空间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE export_test DISCARD  TABLESPACE;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;拷贝导出文件到数据目录中 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cp -f  ~/export_test.* ./
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更改文件权限为mysql &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chown -R mysql:mysql .  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;导入表空间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE export_test IMPORT TABLESPACE;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;验证表中的数据 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from `test`.`export_test`;
+----+--------+
| id | a      |
+----+--------+
| 1  | aaa    |
| 2  | ddd    |
| 3  | ccc    |
| 4  | dddccc |
+----+--------+
4 rows in set (0.02 sec)

mysql&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;常见错误&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;ERROR 1815 (HY000): Internal error: Cannot reset LSNs in table &amp;apos;&amp;quot;test&amp;quot;.&amp;quot;export_test&amp;quot;&amp;apos; : Tablespace not found 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看export文件权限、export文件是否都已经导入到数据库目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;ERROR 1030 (HY000): Got error -1 from storage engine
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;检查innodb_file_per_table是否开启&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;Error : Schema mismatch (Table flags don&amp;apos;t match, server table has 0x0 and the meta-data file has 0x1)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;检查表ROW_FORMAT、innodb_file_format&lt;br&gt;以前支持COMPACT、REDUNDANT的innodb_file_format文件格式为Antelope，新的文件格式为Barracuda，新增格式Compressed、dynamic&lt;br&gt;    innodb_file_format&lt;br&gt;    Default Value (&amp;gt;= 5.7.7)    Barracuda&lt;br&gt;    Default Value (&amp;lt;= 5.7.6)    Antelope&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;在5.6之前的服务版本，在不同的MySQL服务中通过复制表的文件来拷贝表是不可能的，即使启用了innodb_file_per_table。然而，通过Percona XtraBackup，可以从任意的InnoDB数据库中导出指定的表，并将它们导入到使用XtraDB的
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="备份恢复" scheme="http://idber.github.io/tags/%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>ProxySQL 安装配置详解及读写分离、负载均衡</title>
    <link href="http://idber.github.io/2018/08/28-ProxySQL%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"/>
    <id>http://idber.github.io/2018/08/28-ProxySQL 安装配置详解及读写分离、负载均衡.html</id>
    <published>2018-08-27T22:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.932Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在MySQL的高可用集群环境中，中间件是不可缺少的一部分，它提供了读写分离、负载均衡等各种功能，满足集群的横向、纵向的可扩展。由于官方并没有在这方面推出好的产品，更多的是第三方的产品。如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ProxySQL #Percona&lt;/li&gt;
&lt;li&gt;MaxScale #MariaDB&lt;/li&gt;
&lt;li&gt;Atlas #360开源&lt;/li&gt;
&lt;li&gt;OneProxy #平民软件楼方鑫&lt;/li&gt;
&lt;li&gt;MyCat #社区推广&lt;/li&gt;
&lt;li&gt;KingShard #原Atlas作者离职后使用go开发&lt;/li&gt;
&lt;li&gt;TDDL #阿里巴巴开源&lt;/li&gt;
&lt;li&gt;Cobar #阿里巴巴开源&lt;/li&gt;
&lt;li&gt;DBProxy #美团在360Atlas上修改后开源&lt;/li&gt;
&lt;li&gt;Fabric #官方产品&lt;/li&gt;
&lt;li&gt;DRDS #阿里云分库分表产品&lt;/li&gt;
&lt;li&gt;本次以测试ProxySQL为例，逐步了解ProxySQL的使用方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h1&gt;&lt;p&gt;环境：&lt;br&gt;ProxySQL: 1.4.1&lt;br&gt;Master: 192.168.56.101&lt;br&gt;Slave: 192.168.56.102&lt;/p&gt;
&lt;h1 id=&quot;安装配置详解&quot;&gt;&lt;a href=&quot;#安装配置详解&quot; class=&quot;headerlink&quot; title=&quot;安装配置详解&quot;&gt;&lt;/a&gt;安装配置详解&lt;/h1&gt;&lt;p&gt;官网：&lt;a href=&quot;http://www.proxysql.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.proxysql.com/&lt;/a&gt;&lt;br&gt;Percona地址：&lt;a href=&quot;https://www.percona.com/downloads/proxysql/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.percona.com/downloads/proxysql/&lt;/a&gt;&lt;br&gt;Github地址：&lt;a href=&quot;https://github.com/sysown/proxysql/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sysown/proxysql/&lt;/a&gt;&lt;br&gt;本文通过作者编译好的rpm安装，也可通过编译安装的方式安装，本文省略&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;下载proxysql可以有三种途径,分别为官网、Percona网站和Github网站&lt;br&gt;本文从github上下载最新稳定版本，这里选择centos67对应的rpm包&lt;br&gt;下载：wget -c -O proxysql-1.4.1-1-centos67.x86_64.rpm &lt;a href=&quot;https://github.com/sysown/proxysql/releases/download/v1.4.1/proxysql-1.4.1-1-centos67.x86_64.rpm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sysown/proxysql/releases/download/v1.4.1/proxysql-1.4.1-1-centos67.x86_64.rpm&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@mysql test]# yum localinstall -y proxysql-1.4.1-1-centos67.x86_64.rpm
Loaded plugins: security
docker-main-repo                                                                                                                                 | 2.9 kB     00:00     
Setting up Install Process
Resolving Dependencies
There are unfinished transactions remaining. You might consider running yum-complete-transaction first to finish them.
--&amp;gt; Running transaction check
---&amp;gt; Package proxysql.x86_64 0:1.4.1-1 will be installed
--&amp;gt; Finished Dependency Resolution
Dependencies Resolved
========================================================================================================================================================================
 Package                           Arch                            Version                             Repository                                                  Size
========================================================================================================================================================================
Installing:
 proxysql                          x86_64                          1.4.1-1                             /proxysql-1.4.1-1-centos67.x86_64                           19 M
Transaction Summary
========================================================================================================================================================================
Install       1 Package(s)
Total size: 19 M
Installed size: 19 M
Downloading Packages:
Running rpm_check_debug
Running Transaction Test
Transaction Test Succeeded
Running Transaction
  Installing : proxysql-1.4.1-1.x86_64                                                                                                                              1/1 
  Verifying  : proxysql-1.4.1-1.x86_64                                                                                                                              1/1 
Installed:
  proxysql.x86_64 0:1.4.1-1                                                                                                                                             
Complete!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ProxySQL默认配置文件为/etc/proxysql.cnf,只在第一次启动的时候有用,后续的所有配置都是通过对SQLite数据库的操作,并且不会更新到proxysql中,而是存储在/var/lib/proxysql/proxysql.db中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@mysql_slave test]#  proxysql --version    #查看版本
ProxySQL version 1.4.1-45-gab4e6ee, codename Truls
[root@mysql_slave test]# rpm -ql proxysql   #查看安装的具体内容
/etc/init.d/proxysql                    #启动脚本
/etc/proxysql.cnf                       #默认配置文件
/usr/bin/proxysql                       #执行文件
/usr/share/proxysql/tools/proxysql_galera_checker.sh    #ProxySQL调度程序检查pxc_maint_mode参数状态,持续检测各个节点的状态
/usr/share/proxysql/tools/proxysql_galera_writer.pl #ProxySQL指定一个节点直接将流量写入galera
[root@mysql_slave test]#
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;启动&quot;&gt;&lt;a href=&quot;#启动&quot; class=&quot;headerlink&quot; title=&quot;启动&quot;&gt;&lt;/a&gt;启动&lt;/h2&gt;&lt;p&gt;启动之后才会生成存储目录/var/lib/proxysql&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@mysql_slave test]# /etc/init.d/proxysql start
Starting ProxySQL: DONE!
[root@mysql_slave test]# ll /var/lib/proxysql/
总用量 108
-rw------- 1 root root 98304 8月  29 15:37 proxysql.db
-rw------- 1 root root  4306 8月  29 16:25 proxysql.log
-rw-r--r-- 1 root root     5 8月  29 16:25 proxysql.pid
[root@mysql_slave test]#
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;内置对象介绍&quot;&gt;&lt;a href=&quot;#内置对象介绍&quot; class=&quot;headerlink&quot; title=&quot;内置对象介绍&quot;&gt;&lt;/a&gt;内置对象介绍&lt;/h1&gt;&lt;h2 id=&quot;登录&quot;&gt;&lt;a href=&quot;#登录&quot; class=&quot;headerlink&quot; title=&quot;登录&quot;&gt;&lt;/a&gt;登录&lt;/h2&gt;&lt;p&gt;启动了6032和6033两个端口,默认管理端口是6032,客户端服务端口是6033,默认的用户名密码都是 admin,通过mysql的客户端可以登录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@mysql_slave test]# netstat -tunlp|grep proxysql
tcp        0      0 0.0.0.0:6032                0.0.0.0:*                   LISTEN      5181/proxysql       
tcp        0      0 0.0.0.0:6033                0.0.0.0:*                   LISTEN      5181/proxysql       
[root@mysql_slave test]# mysql -uadmin -padmin -h127.0.0.1 -P6032
Warning: Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 1
Server version: 5.5.30 (ProxySQL Admin Module)
Copyright (c) 2009-2017 Percona LLC and/or its affiliates
Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type &amp;apos;help;&amp;apos; or &amp;apos;\h&amp;apos; for help. Type &amp;apos;\c&amp;apos; to clear the current input statement.
MySQL [(none)] 16:28:32 &amp;gt; show databases;
+-----+---------+-------------------------------+
| seq | name    | file                          |
+-----+---------+-------------------------------+
| 0   | main    |                               |
| 2   | disk    | /var/lib/proxysql/proxysql.db |
| 3   | stats   |                               |
| 4   | monitor |                               |
+-----+---------+-------------------------------+
4 rows in set (0.00 sec)
MySQL [(none)] 16:28:41 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;内置库&quot;&gt;&lt;a href=&quot;#内置库&quot; class=&quot;headerlink&quot; title=&quot;内置库&quot;&gt;&lt;/a&gt;内置库&lt;/h2&gt;&lt;p&gt;main：默认数据库名,用于存放后端db实例、用户认证、路由规则等信息。表名以runtime开头的表示proxysql当前运行的配置内容，不能通过dml语句修改。只能修改对应的不以runtime开头的（在内存）里的表，然后LOAD使其生效，SAVE使其存到硬盘以供下次重启加载。&lt;br&gt;disk：是持久化到硬盘的配置，sqlite数据文件。&lt;br&gt;stats：是proxysql运行抓取的统计信息，包括到后端各命令的执行次数、流量、processlist、查询各类汇总、执行时间等。&lt;br&gt;monitor：库存储monitor模块收集的信息，主要是对后端db的健康、延迟检查。&lt;/p&gt;
&lt;h3 id=&quot;main库&quot;&gt;&lt;a href=&quot;#main库&quot; class=&quot;headerlink&quot; title=&quot;main库&quot;&gt;&lt;/a&gt;main库&lt;/h3&gt;&lt;h4 id=&quot;runtime-表&quot;&gt;&lt;a href=&quot;#runtime-表&quot; class=&quot;headerlink&quot; title=&quot;runtime_表&quot;&gt;&lt;/a&gt;runtime_表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [main] 17:19:10 &amp;gt; use main
Database changed
MySQL [main] 17:22:15 &amp;gt; show tables;
+--------------------------------------------+
| tables                                     |
+--------------------------------------------+
| global_variables                           |
| mysql_collations                           |
| mysql_group_replication_hostgroups         |
| mysql_query_rules                          |
| mysql_replication_hostgroups               |
| mysql_servers                              |
| mysql_users                                |
| proxysql_servers                           |
| runtime_global_variables                   |
| runtime_mysql_group_replication_hostgroups |
| runtime_mysql_query_rules                  |
| runtime_mysql_replication_hostgroups       |
| runtime_mysql_servers                      |
| runtime_mysql_users                        |
| runtime_proxysql_servers                   |
| runtime_scheduler                          |
| scheduler                                  |
+--------------------------------------------+
17 rows in set (0.00 sec)
MySQL [main] 17:22:16 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，runtime_开关的表如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;runtime_global_variables：global_variables的运行时版本
runtime_mysql_group_replication_hostgroups：mysql_group_replication_hostgroups的运行时版本
runtime_mysql_query_rules：mysql_query_rules的运行时版本
runtime_mysql_replication_hostgroups：mysql_replication_hostsgroups的运行时版本
runtime_mysql_servers：mysql_servers的运行时版本
runtime_mysql_users：mysql_users的运行时版本
runtime_scheduler：scheduler调度程序的运行时版本

global_variables表
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内置参数表，参考下文&lt;/p&gt;
&lt;h4 id=&quot;mysql-servers表&quot;&gt;&lt;a href=&quot;#mysql-servers表&quot; class=&quot;headerlink&quot; title=&quot;mysql_servers表&quot;&gt;&lt;/a&gt;mysql_servers表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [main] 17:22:16 &amp;gt; show create table mysql_servers\G
*************************** 1. row ***************************
       table: mysql_servers
Create Table: CREATE TABLE mysql_servers (
    hostgroup_id INT NOT NULL DEFAULT 0,
    hostname VARCHAR NOT NULL,
    port INT NOT NULL DEFAULT 3306,
    status VARCHAR CHECK (UPPER(status) IN (&amp;apos;ONLINE&amp;apos;,&amp;apos;SHUNNED&amp;apos;,&amp;apos;OFFLINE_SOFT&amp;apos;, &amp;apos;OFFLINE_HARD&amp;apos;)) NOT NULL DEFAULT &amp;apos;ONLINE&amp;apos;,
    weight INT CHECK (weight &amp;gt;= 0) NOT NULL DEFAULT 1,
    compression INT CHECK (compression &amp;gt;=0 AND compression &amp;lt;= 102400) NOT NULL DEFAULT 0,
    max_connections INT CHECK (max_connections &amp;gt;=0) NOT NULL DEFAULT 1000,
    max_replication_lag INT CHECK (max_replication_lag &amp;gt;= 0 AND max_replication_lag &amp;lt;= 126144000) NOT NULL DEFAULT 0,
    use_ssl INT CHECK (use_ssl IN(0,1)) NOT NULL DEFAULT 0,
    max_latency_ms INT UNSIGNED CHECK (max_latency_ms&amp;gt;=0) NOT NULL DEFAULT 0,
    comment VARCHAR NOT NULL DEFAULT &amp;apos;&amp;apos;,
    PRIMARY KEY (hostgroup_id, hostname, port) )
1 row in set (0.00 sec)
MySQL [main] 17:34:05 &amp;gt;
hostgroup_id：ProxySQL通过hostgroup的形式组织后端db实例,一个hostgroup代表同属于一个角色。
表的主键是(hostgroup_id, hostname, port),以hostname:port在多个hostgroup中存在。
一个hostgroup可以有多个实例，即是多个从库，可能通过weight分配权重。
hostgroup_id 0是一个特殊的hostgroup，路由查询的时候，没有匹配到规则则默认选择hostgroup 0。

status：
ONLINE：当前后端实例状态正常。
SHUNNED：临时被剔除，可能因为后端too many connection error，或者超过了max_replication_lag。
OFFLINE_SOFT：软离线状态，不再接受新的连接，但已建立的连接会等待活跃事务完成。
OFFLINE_HARD：硬离线状态，不再接受新的连接，已建立的连接或被强制中断，当后端实例宕机或网络不可达，会出现。
max_connections：允许连接到该后端实例的最大连接数，不要大于MySQL的max_connections。
如果后端实例hostname:port在多个hostgroup里，以较大者为准，而不是各自独立允许的最大连接数。
max_replication_lag：允许的最大延迟，主库不受影响，默认为0，如果&amp;gt;0，monitor模块监控主从延迟大于阈值时，会临时把它的状态变更为SHUNNED。
max_latency_ms：mysql_ping响应时间，大于这个阈值会把它从连接池剔除，即使是ONLINE。
comment：备注，不建设为空。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他的字段，可通过字面意思理解。&lt;/p&gt;
&lt;h4 id=&quot;mysql-users表&quot;&gt;&lt;a href=&quot;#mysql-users表&quot; class=&quot;headerlink&quot; title=&quot;mysql_users表&quot;&gt;&lt;/a&gt;mysql_users表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [main] 09:13:02 &amp;gt; show create table mysql_users\G
*************************** 1. row ***************************
       table: mysql_users
Create Table: CREATE TABLE mysql_users (
    username VARCHAR NOT NULL,
    password VARCHAR,
    active INT CHECK (active IN (0,1)) NOT NULL DEFAULT 1,
    use_ssl INT CHECK (use_ssl IN (0,1)) NOT NULL DEFAULT 0,
    default_hostgroup INT NOT NULL DEFAULT 0,
    default_schema VARCHAR,
    schema_locked INT CHECK (schema_locked IN (0,1)) NOT NULL DEFAULT 0,
    transaction_persistent INT CHECK (transaction_persistent IN (0,1)) NOT NULL DEFAULT 1,
    fast_forward INT CHECK (fast_forward IN (0,1)) NOT NULL DEFAULT 0,
    backend INT CHECK (backend IN (0,1)) NOT NULL DEFAULT 1,
    frontend INT CHECK (frontend IN (0,1)) NOT NULL DEFAULT 1,
    max_connections INT CHECK (max_connections &amp;gt;=0) NOT NULL DEFAULT 10000,
    PRIMARY KEY (username, backend),
    UNIQUE (username, frontend))
1 row in set (0.00 sec)
MySQL [main] 09:13:08 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;username,password：连接到后端MySQL或ProxySQL实例的凭证,参考密码管理。&lt;br&gt;密码可插入明文，也可通过PASSWORD()插入密文，proxysql以*开头判断插入是否是密文。&lt;br&gt;但是runtime_mysql_users里统一是密文，所以明文插入，再SAVE MYSQL USERS TO MEM，此时看到的也是HASH密文。&lt;/p&gt;
&lt;p&gt;active：是否生效该用户，active=0的用户将在数据库中被跟踪，但不会加载到内存中的数据结构中。&lt;br&gt;default_hostgroup：这个用户的请求没有匹配到规则时，默认发到hostgroup，默认0。&lt;br&gt;default_schema：这个用户连接时没有指定schema时，默认使用的schema。&lt;br&gt;默认为NULL，实际上受变量mysql-default_schema的影响，默认为information_schema。&lt;br&gt;transaction_persistent： 如果设置为1，连接上ProxySQL的会话后，如果在一个hostgroup上开启了事务，那么后续的sql都继续维持在这个hostgroup上，不论是否会匹配上其它路由规则，直到事务结束。&lt;br&gt;frontend：如果设置为1，则用户名、密码对ProxySQL进行身份验证。&lt;br&gt;backend：如果设置为1，则用户名、密码根据任何主机组向mysqld服务器进行身份验证。&lt;br&gt;注意，目前所有用户都需要将“前端”和“后端“都设置为1，未来版本的ProxySQL将分离前端和后端之间的crendentials。以这种方式，前端将永远不会知道直接连接到后端的凭据，强制所有通过ProxySQL的连接并增加系统的安全性。&lt;/p&gt;
&lt;p&gt;mysql_replication_hostgroups表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [main] 10:18:15 &amp;gt; show create table mysql_replication_hostgroups\G
*************************** 1. row ***************************
       table: mysql_replication_hostgroups
Create Table: CREATE TABLE mysql_replication_hostgroups (
    writer_hostgroup INT CHECK (writer_hostgroup&amp;gt;=0) NOT NULL PRIMARY KEY,
    reader_hostgroup INT NOT NULL CHECK (reader_hostgroup&amp;lt;&amp;gt;writer_hostgroup AND reader_hostgroup&amp;gt;0),
    comment VARCHAR,
    UNIQUE (reader_hostgroup))
1 row in set (0.00 sec)
MySQL [main] 10:18:22 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义hostgroup的主从关系。ProxySQL monitor模块会监控hostgroup后端所有servers的read_only变量，如果发现从库的read_only变为0、主库变为1，则认为角色互换了，自动改写mysql_servers表里面hostgroup关系，达到failover效果。&lt;/p&gt;
&lt;h4 id=&quot;mysql-query-rules查询规则表&quot;&gt;&lt;a href=&quot;#mysql-query-rules查询规则表&quot; class=&quot;headerlink&quot; title=&quot;mysql_query_rules查询规则表&quot;&gt;&lt;/a&gt;mysql_query_rules查询规则表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [main] 10:25:22 &amp;gt; show create table mysql_query_rules\G           
*************************** 1. row ***************************
       table: mysql_query_rules
Create Table: CREATE TABLE mysql_query_rules (
    rule_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
    active INT CHECK (active IN (0,1)) NOT NULL DEFAULT 0,
    username VARCHAR,
    schemaname VARCHAR,
    flagIN INT NOT NULL DEFAULT 0,
    client_addr VARCHAR,
    proxy_addr VARCHAR,
    proxy_port INT,
    digest VARCHAR,
    match_digest VARCHAR,
    match_pattern VARCHAR,
    negate_match_pattern INT CHECK (negate_match_pattern IN (0,1)) NOT NULL DEFAULT 0,
    re_modifiers VARCHAR DEFAULT &amp;apos;CASELESS&amp;apos;,
    flagOUT INT,
    replace_pattern VARCHAR,
    destination_hostgroup INT DEFAULT NULL,
    cache_ttl INT CHECK(cache_ttl &amp;gt; 0),
    reconnect INT CHECK (reconnect IN (0,1)) DEFAULT NULL,
    timeout INT UNSIGNED,
    retries INT CHECK (retries&amp;gt;=0 AND retries &amp;lt;=1000),
    delay INT UNSIGNED,
    next_query_flagIN INT UNSIGNED,
    mirror_flagOUT INT UNSIGNED,
    mirror_hostgroup INT UNSIGNED,
    error_msg VARCHAR,
    OK_msg VARCHAR,
    sticky_conn INT CHECK (sticky_conn IN (0,1)),
    multiplex INT CHECK (multiplex IN (0,1,2)),
    log INT CHECK (log IN (0,1)),
    apply INT CHECK(apply IN (0,1)) NOT NULL DEFAULT 0,
    comment VARCHAR)
1 row in set (0.00 sec)
MySQL [main] 10:25:34 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;rule_id：表主键，自增，规则处理是以rule_id为顺序进行。&lt;/p&gt;
&lt;p&gt;active：只有active=1时的规则才会参与匹配。&lt;br&gt;username：过滤匹配用户名的条件，如果是非空值，则仅当连接使用正确的用户名时，查询才匹配。&lt;br&gt;schemaname：匹配schemaname的过滤条件，如果是非空值，则仅当连接schemaname用作默认模式时，查询才匹配。&lt;br&gt;flagIN,flagOUT,apply：用来定义路由链chains of rules&lt;br&gt;首先会检查flagIN=0的规则，以rule_id的顺序；如果没有匹配上，则走这个用户的default_hostgroup。&lt;br&gt;当匹配一条规则后，会检查flagOUT。&lt;br&gt;如果不为NULL，并且flagIN!=flagOUT，则进入以flagIN为上一个flagOUT值的新规则链。&lt;br&gt;如果不为NULL，并且flagIN=flagOUT，则应用这条规则。&lt;br&gt;如果为NULL，或者apply=1，则结束，应用这条规则。&lt;br&gt;如果最终没有匹配到，则找到这个用户的default_hostgroup。&lt;br&gt;client_addr：匹配客户端来源IP。&lt;br&gt;proxy_addr,proxy_port：匹配本地proxysql的ip、端口。&lt;br&gt;digest：精确匹配的查询。&lt;br&gt;match_digest：正则匹配查询。query,digest是指对查询去掉具体值后进行”模糊化“后的查询，类似pt-query-digest的效果。&lt;br&gt;match_pattern：正则匹配查询。&lt;br&gt;以上都是匹配查询的规则，1.4版本可以通过变量mysql-query_processor_regex设置，支持RE2和PCRE，1.4版本开始默认为PCRE。&lt;br&gt;negate_match_pattern：反向匹配，相当于对match_digest/match_pattern的匹配取反。&lt;br&gt;re_modifiers：修改正则匹配的参数，比如默认的：忽略大小写CASELESS、禁用GLOBAL。&lt;br&gt;下面是匹配后的行为：&lt;br&gt;replace_pattern：查询重写，默认为空。&lt;br&gt;destination_hostgroup：路由查询到这个hostgroup，当然如果用户显式start transaction且transaction_persistent=1,那么即使匹配到了，也依然按照事务里第一条sql的路由规则去走的。&lt;br&gt;cache_ttl：查询结果缓存的毫秒数。&lt;br&gt;timeout：这一类查询执行的的最大时间(毫秒),超时则自动kill。&lt;br&gt;这是对后端DB的保护机制，相当于阿里云RDS的loose_max_statement_time变量的功能，但不同的是，阿里云这个变量的时间时不包括DML操作出现InnoDB行锁等待的时间，而ProxySQL的这个timeout是计算从发送sql到等待响应的时间。默认mysql-default_query_timeout是10h。&lt;br&gt;retries：语句在执行失败时，重试次数。默认由mysql-query_retries_on_failure变量指定，为1。建议不要重试，有风险。&lt;br&gt;delay：查询延迟执行，这是ProxySQL提供的限流机制，会让其它的查询优先执行。&lt;br&gt;默认值mysql-default_query_delay为0。&lt;br&gt;mirror_flagOUT,mirror_hostgroup：与镜像相关的设置。&lt;br&gt;error_msg：默认为NULL，如果指定了则这个查询直接被block掉，将error_msg返回给客户端。&lt;br&gt;multiplex：连接是否利用，请参考文章。&lt;br&gt;log：是否记录查询日志，可以看到log是否记录的对象是根据规则。&lt;br&gt;要开启日志记录，需要设置变量mysql-eventslog_filename来指定文件名，然后这个log标记为1。但是目前proxysql记录的日志是二进制格式，需要特定的工具才能读取：eventslog_reader_sample。这个工具在源码目录 tools下面。&lt;/p&gt;
&lt;h4 id=&quot;scheduler调度表&quot;&gt;&lt;a href=&quot;#scheduler调度表&quot; class=&quot;headerlink&quot; title=&quot;scheduler调度表&quot;&gt;&lt;/a&gt;scheduler调度表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [main] 10:27:52 &amp;gt; show create table scheduler\G
*************************** 1. row ***************************
       table: scheduler
Create Table: CREATE TABLE scheduler (
    id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
    active INT CHECK (active IN (0,1)) NOT NULL DEFAULT 1,
    interval_ms INTEGER CHECK (interval_ms&amp;gt;=100 AND interval_ms&amp;lt;=100000000) NOT NULL,
    filename VARCHAR NOT NULL,
    arg1 VARCHAR,
    arg2 VARCHAR,
    arg3 VARCHAR,
    arg4 VARCHAR,
    arg5 VARCHAR,
    comment VARCHAR NOT NULL DEFAULT &amp;apos;&amp;apos;)
1 row in set (0.00 sec)
MySQL [main] 11:09:59 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;id：调度程序作业的唯一标识符。&lt;/p&gt;
&lt;p&gt;active：如果设置为1，则作业处于活动状态。&lt;br&gt;interval_ms：工作的开始频率(以毫秒为单位)，最小interval_ms为100毫秒。&lt;br&gt;filename：可执行文件的完整路径。&lt;br&gt;arg1-arg5：传递作业的参数。最多5个。&lt;br&gt;comment：注释。&lt;br&gt;参考文档&lt;/p&gt;
&lt;h3 id=&quot;disk库&quot;&gt;&lt;a href=&quot;#disk库&quot; class=&quot;headerlink&quot; title=&quot;disk库&quot;&gt;&lt;/a&gt;disk库&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;MySQL [main] 15:12:14 &amp;gt; show tables from disk;
+------------------------------------+
| tables                             |
+------------------------------------+
| global_variables                   |
| mysql_collations                   |
| mysql_group_replication_hostgroups |
| mysql_query_rules                  |
| mysql_replication_hostgroups       |
| mysql_servers                      |
| mysql_users                        |
| proxysql_servers                   |
| scheduler                          |
+------------------------------------+
9 rows in set (0.00 sec)
MySQL [main] 15:12:26 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体的表介绍和main库一致。&lt;/p&gt;
&lt;h3 id=&quot;stats库&quot;&gt;&lt;a href=&quot;#stats库&quot; class=&quot;headerlink&quot; title=&quot;stats库&quot;&gt;&lt;/a&gt;stats库&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;MySQL [main] 15:12:26 &amp;gt; show tables from stats;
+-----------------------------------+
| tables                            |
+-----------------------------------+
| global_variables                  |
| stats_memory_metrics              |
| stats_mysql_commands_counters     |
| stats_mysql_connection_pool       |
| stats_mysql_connection_pool_reset |
| stats_mysql_global                |
| stats_mysql_processlist           |
| stats_mysql_query_digest          |
| stats_mysql_query_digest_reset    |
| stats_mysql_query_rules           |
| stats_mysql_users                 |
| stats_proxysql_servers_metrics    |
| stats_proxysql_servers_status     |
+-----------------------------------+
13 rows in set (0.00 sec)
MySQL [main] 15:13:53 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;stats-mysql-commands-counters表&quot;&gt;&lt;a href=&quot;#stats-mysql-commands-counters表&quot; class=&quot;headerlink&quot; title=&quot;stats_mysql_commands_counters表&quot;&gt;&lt;/a&gt;stats_mysql_commands_counters表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:15:36 &amp;gt; show create table stats.stats_mysql_commands_counters\G
*************************** 1. row ***************************
       table: stats_mysql_commands_counters
Create Table: CREATE TABLE stats_mysql_commands_counters (
    Command VARCHAR NOT NULL PRIMARY KEY,
    Total_Time_us INT NOT NULL,
    Total_cnt INT NOT NULL,
    cnt_100us INT NOT NULL,
    cnt_500us INT NOT NULL,
    cnt_1ms INT NOT NULL,
    cnt_5ms INT NOT NULL,
    cnt_10ms INT NOT NULL,
    cnt_50ms INT NOT NULL,
    cnt_100ms INT NOT NULL,
    cnt_500ms INT NOT NULL,
    cnt_1s INT NOT NULL,
    cnt_5s INT NOT NULL,
    cnt_10s INT NOT NULL,
    cnt_INFs)
1 row in set (0.00 sec)
MySQL [stats] 15:15:58 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;command：已执行的SQL命令的类型，如FLUSH、INSERT、KILL、SELECT FOR UPDATE等。&lt;br&gt;Total_Time_us：执行该类型命令的总时间(以毫秒为单位)。&lt;br&gt;Total_cnt：执行该类型的命令的总数。&lt;br&gt;cnt_100us-cnt_INFs：在指定的时间限制内执行的给定类型的命令总数和前一个命令的总数。&lt;/p&gt;
&lt;h4 id=&quot;stats-mysql-connection-pool表&quot;&gt;&lt;a href=&quot;#stats-mysql-connection-pool表&quot; class=&quot;headerlink&quot; title=&quot;stats_mysql_connection_pool表&quot;&gt;&lt;/a&gt;stats_mysql_connection_pool表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:15:58 &amp;gt; show create table stats.stats_mysql_connection_pool \G 
*************************** 1. row ***************************
       table: stats_mysql_connection_pool
Create Table: CREATE TABLE stats_mysql_connection_pool (
    hostgroup INT,
    srv_host VARCHAR,
    srv_port INT,
    status VARCHAR,
    ConnUsed INT,
    ConnFree INT,
    ConnOK INT,
    ConnERR INT,
    Queries INT,
    Bytes_data_sent INT,
    Bytes_data_recv INT,
    Latency_us INT)
1 row in set (0.00 sec)
MySQL [stats] 15:20:08 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;hostgroup：后端服务器所属的主机组，单个后端服务器可以属于多个主机组。&lt;/p&gt;
&lt;p&gt;srv_host,srv_port：mysqld后端服务器正在侦听连接的TCP端点的IP和Port。&lt;br&gt;status：后端服务器的状态。可以有ONLINE，SHUNNED，OFFLINE_SOFT，OFFLINE_HARD。&lt;br&gt;ConnUsed：ProxySQL当前使用多少个连接来向后端服务器发送查询。&lt;br&gt;ConnFree：目前有多少个连接是空闲。&lt;br&gt;ConnOK：成功建立了多少个连接。&lt;br&gt;ConnERR：没有成功建立多少个连接。&lt;br&gt;Queries：路由到此特定后端服务器的查询数。&lt;br&gt;Bytes_data_sent：发送到后端的数据量。&lt;br&gt;Bytes_data_recv：从后端接收的数据量。&lt;br&gt;Latency_ms：从Monitor报告的当前ping以毫秒为单位的延迟时间。&lt;/p&gt;
&lt;h4 id=&quot;stats-mysql-global表&quot;&gt;&lt;a href=&quot;#stats-mysql-global表&quot; class=&quot;headerlink&quot; title=&quot;stats_mysql_global表&quot;&gt;&lt;/a&gt;stats_mysql_global表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:20:08 &amp;gt; show create table stats.stats_mysql_global\G          
*************************** 1. row ***************************
       table: stats_mysql_global
Create Table: CREATE TABLE stats_mysql_global (
    Variable_Name VARCHAR NOT NULL PRIMARY KEY,
    Variable_Value VARCHAR NOT NULL)
1 row in set (0.00 sec)
MySQL [stats] 15:22:35 &amp;gt;
Variable_Name：代表与MySQL相关的代理级别的全局统计
如Client_Connections_aborted：由于无效凭据或max_connections而导致的前端连接数已达到；
如Client_Connections_connected：当前连接的前端连接数。
如Client_Connections_created：到目前为止创建的前端连接数。等等。

Variable_Value：统计所对应的值。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;stats-mysql-processlist表&quot;&gt;&lt;a href=&quot;#stats-mysql-processlist表&quot; class=&quot;headerlink&quot; title=&quot;stats_mysql_processlist表&quot;&gt;&lt;/a&gt;stats_mysql_processlist表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:24:11 &amp;gt; show create table stats.stats_mysql_processlist\G
*************************** 1. row ***************************
       table: stats_mysql_processlist
Create Table: CREATE TABLE stats_mysql_processlist (
    ThreadID INT NOT NULL,
    SessionID INTEGER PRIMARY KEY,
    user VARCHAR,
    db VARCHAR,
    cli_host VARCHAR,
    cli_port INT,
    hostgroup INT,
    l_srv_host VARCHAR,
    l_srv_port INT,
    srv_host VARCHAR,
    srv_port INT,
    command VARCHAR,
    time_ms INT NOT NULL,
    info VARCHAR)
1 row in set (0.00 sec)
MySQL [stats] 15:26:43 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ThreadID：ProxySQL线程的内部ID。&lt;/p&gt;
&lt;p&gt;SessionID：ProxySQL会话ID，通过这个ID可以进行kill操作。&lt;br&gt;user：与MySQL客户端连接到ProxySQL的用户。&lt;br&gt;db：当前选择的数据库。&lt;br&gt;cli_host,cli_port：连接ProxySQL的IP和TCP端口。&lt;br&gt;hostgroup：当前主机组。如果正在处理查询，则是查询已被路由或将要路由的主机组，或默认主机组。可以通过这个查看该SQL到底是到哪个HG里。&lt;br&gt;l_srv_host,l_srv_port：ProxySQL的IP和TCP端口。&lt;br&gt;srv_host,srv_port：后端MySQL服务器的IP和端口。&lt;br&gt;command：正在执行的MySQL查询的类型。&lt;br&gt;time_ms：命令执行的时间(以毫秒为单位)。&lt;br&gt;info：正在执行的SQL。&lt;/p&gt;
&lt;h4 id=&quot;stats-mysql-query-digest表&quot;&gt;&lt;a href=&quot;#stats-mysql-query-digest表&quot; class=&quot;headerlink&quot; title=&quot;stats_mysql_query_digest表&quot;&gt;&lt;/a&gt;stats_mysql_query_digest表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:26:43 &amp;gt; show create table stats.stats_mysql_query_digest\G
*************************** 1. row ***************************
       table: stats_mysql_query_digest
Create Table: CREATE TABLE stats_mysql_query_digest (
    hostgroup INT,
    schemaname VARCHAR NOT NULL,
    username VARCHAR NOT NULL,
    digest VARCHAR NOT NULL,
    digest_text VARCHAR NOT NULL,
    count_star INTEGER NOT NULL,
    first_seen INTEGER NOT NULL,
    last_seen INTEGER NOT NULL,
    sum_time INTEGER NOT NULL,
    min_time INTEGER NOT NULL,
    max_time INTEGER NOT NULL,
    PRIMARY KEY(hostgroup, schemaname, username, digest))
1 row in set (0.00 sec)
MySQL [stats] 15:29:27 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;hostgroup：发送查询的主机组。值-1表示查询查询缓存。&lt;/p&gt;
&lt;p&gt;schemaname：查询的数据库。&lt;br&gt;user：连接ProxySQL的用户名。&lt;br&gt;digest：一个十六进制散列，表示其参数剥离的SQL。&lt;br&gt;digest_text：参数剥离的实际SQL文本&lt;br&gt;count_star：执行查询的总次数（参数的值不同）。&lt;br&gt;first_seen：unix时间戳，是通过代理路由查询的第一时刻。&lt;br&gt;last_seen：unix时间戳，当查询通过代理路由时的最后一刻（到目前为止）。&lt;br&gt;sum_time：执行此类查询的总时间（以微秒为单位）。&lt;br&gt;这对于确定应用程序工作负载中花费的最多时间在哪里是非常有用的，并为改进的地方提供了一个良好的起点。&lt;br&gt;min_time,max_time - 执行此类查询时期望的持续时间范围。&lt;br&gt;min_time是到目前为止所看到的最小执行时间，而max_time表示最大执行时间，以微秒为单位。&lt;/p&gt;
&lt;h4 id=&quot;stats-mysql-query-rules表&quot;&gt;&lt;a href=&quot;#stats-mysql-query-rules表&quot; class=&quot;headerlink&quot; title=&quot;stats_mysql_query_rules表&quot;&gt;&lt;/a&gt;stats_mysql_query_rules表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:29:27 &amp;gt; show create table stats.stats_mysql_query_rules\G 
*************************** 1. row ***************************
       table: stats_mysql_query_rules
Create Table: CREATE TABLE stats_mysql_query_rules (
    rule_id INTEGER PRIMARY KEY,
    hits INT NOT NULL)
1 row in set (0.00 sec)
MySQL [stats] 15:31:57 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;rule_id：路由规则的ID与main.mysql_query_rules的id对应。&lt;/p&gt;
&lt;p&gt;hits：此路由规则的匹配总数。 如果当前传入的查询符合规则，则会记录一次命中。&lt;br&gt;monitor库&lt;/p&gt;
&lt;p&gt;对后端MySQL的健康检查，由变量mysql-monitor_enabled来确定是否开启Monitor模块。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:35:32 &amp;gt; show tables from monitor;                               
+------------------------------------+
| tables                             |
+------------------------------------+
| mysql_server_connect               |
| mysql_server_connect_log           |
| mysql_server_group_replication_log |
| mysql_server_ping                  |
| mysql_server_ping_log              |
| mysql_server_read_only_log         |
| mysql_server_replication_lag_log   |
+------------------------------------+
7 rows in set (0.00 sec)
MySQL [stats] 15:35:52 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;mysql-server-connect-mysql-server-connect-log表&quot;&gt;&lt;a href=&quot;#mysql-server-connect-mysql-server-connect-log表&quot; class=&quot;headerlink&quot; title=&quot;mysql_server_connect/mysql_server_connect_log表&quot;&gt;&lt;/a&gt;mysql_server_connect/mysql_server_connect_log表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:37:39 &amp;gt; show create table monitor.mysql_server_connect\G  
*************************** 1. row ***************************
       table: mysql_server_connect
Create Table: CREATE TABLE mysql_server_connect (
    hostname VARCHAR NOT NULL,
    port INT NOT NULL DEFAULT 3306,
    time_since INT NOT NULL DEFAULT 0,
    time_until INT NOT NULL DEFAULT 0,
    connect_success_count INT NOT NULL DEFAULT 0,
    connect_success_first INT NOT NULL DEFAULT 0,
    connect_success_last INT NOT NULL DEFAULT 0,
    connect_success_time_min INT NOT NULL DEFAULT 0,
    connect_success_time_max INT NOT NULL DEFAULT 0,
    connect_success_time_total INT NOT NULL DEFAULT 0,
    connect_failure_count INT NOT NULL DEFAULT 0,
    connect_failure_first INT NOT NULL DEFAULT 0,
    connect_failure_last INT NOT NULL DEFAULT 0,
    PRIMARY KEY (hostname, port))
1 row in set (0.00 sec)
MySQL [stats] 15:37:46 &amp;gt; show create table monitor.mysql_server_connect_log\G
*************************** 1. row ***************************
       table: mysql_server_connect_log
Create Table: CREATE TABLE mysql_server_connect_log (
    hostname VARCHAR NOT NULL,
    port INT NOT NULL DEFAULT 3306,
    time_start_us INT NOT NULL DEFAULT 0,
    connect_success_time_us INT DEFAULT 0,
    connect_error VARCHAR,
    PRIMARY KEY (hostname, port, time_start_us))
1 row in set (0.00 sec)
MySQL [stats] 15:37:51 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;连接到所有MySQL服务器以检查它们是否可用，该表用来存放检测连接的日志。由变量mysql-monitor_connect_interval来控制其检测的时间间隔，由参数mysql-monitor_connect_timeout控制连接是否超时（默认200毫秒）。&lt;/p&gt;
&lt;h4 id=&quot;mysql-server-ping-mysql-server-ping-log表&quot;&gt;&lt;a href=&quot;#mysql-server-ping-mysql-server-ping-log表&quot; class=&quot;headerlink&quot; title=&quot;mysql_server_ping/mysql_server_ping_log表&quot;&gt;&lt;/a&gt;mysql_server_ping/mysql_server_ping_log表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:39:23 &amp;gt; show create table monitor.mysql_server_ping\G       
*************************** 1. row ***************************
       table: mysql_server_ping
Create Table: CREATE TABLE mysql_server_ping (
    hostname VARCHAR NOT NULL,
    port INT NOT NULL DEFAULT 3306,
    time_since INT NOT NULL DEFAULT 0,
    time_until INT NOT NULL DEFAULT 0,
    ping_success_count INT NOT NULL DEFAULT 0,
    ping_success_first INT NOT NULL DEFAULT 0, ping_success_last INT NOT NULL DEFAULT 0,
    ping_success_time_min INT NOT NULL DEFAULT 0,
    ping_success_time_max INT NOT NULL DEFAULT 0,
    ping_success_time_total INT NOT NULL DEFAULT 0,
    ping_failure_count INT NOT NULL DEFAULT 0,
    ping_failure_first INT NOT NULL DEFAULT 0,
    ping_failure_last INT NOT NULL DEFAULT 0,
    PRIMARY KEY (hostname, port))
1 row in set (0.00 sec)
MySQL [stats] 15:40:12 &amp;gt; show create table monitor.mysql_server_ping_log\G
*************************** 1. row ***************************
       table: mysql_server_ping_log
Create Table: CREATE TABLE mysql_server_ping_log (
     hostname VARCHAR NOT NULL,
    port INT NOT NULL DEFAULT 3306,
    time_start_us INT NOT NULL DEFAULT 0,
    ping_success_time_us INT DEFAULT 0,
    ping_error VARCHAR,
    PRIMARY KEY (hostname, port, time_start_us))
1 row in set (0.00 sec)
MySQL [stats] 15:40:15 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用mysql_ping API ping后端MySQL服务器检查它们是否可用，该表用来存放ping的日志。由变量mysql-monitor_ping_interval控制ping的时间间隔，默认值：10000（毫秒，相当于10秒）。&lt;/p&gt;
&lt;h4 id=&quot;mysql-server-replication-lag-log表&quot;&gt;&lt;a href=&quot;#mysql-server-replication-lag-log表&quot; class=&quot;headerlink&quot; title=&quot;mysql_server_replication_lag_log表&quot;&gt;&lt;/a&gt;mysql_server_replication_lag_log表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:40:53 &amp;gt; show create table monitor.mysql_server_replication_lag_log\G
*************************** 1. row ***************************
       table: mysql_server_replication_lag_log
Create Table: CREATE TABLE mysql_server_replication_lag_log (
     hostname VARCHAR NOT NULL,
    port INT NOT NULL DEFAULT 3306,
    time_start_us INT NOT NULL DEFAULT 0,
    success_time_us INT DEFAULT 0,
    repl_lag INT DEFAULT 0,
    error VARCHAR,
    PRIMARY KEY (hostname, port, time_start_us))
1 row in set (0.00 sec)
MySQL [stats] 15:41:12 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;后端MySQL服务主从延迟的检测。由参数mysql-monitor_replication_lag_interval控制检测间隔时间， 如果复制滞后太大，可以暂时关闭从。由mysql_servers.max_replication_lag列控制。默认值：10000（毫秒，相当于10秒）。&lt;/p&gt;
&lt;h2 id=&quot;内置参数&quot;&gt;&lt;a href=&quot;#内置参数&quot; class=&quot;headerlink&quot; title=&quot;内置参数&quot;&gt;&lt;/a&gt;内置参数&lt;/h2&gt;&lt;p&gt;global_variables 1.4版本中有95个参数，参数较多，解释请参考文档。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [main] 11:16:22 &amp;gt; show variables;
+-----------------------------------------------------+--------------------+
| Variable_name                                       | Value              |
+-----------------------------------------------------+--------------------+
| admin-admin_credentials                             | admin:admin        |
| admin-cluster_check_interval_ms                     | 1000               |
| admin-cluster_password                              |                    |
| admin-cluster_username                              |                    |
| admin-hash_passwords                                | true               |
| admin-mysql_ifaces                                  | 0.0.0.0:6032       |
| admin-read_only                                     | false              |
| admin-refresh_interval                              | 2000               |
| admin-stats_credentials                             | stats:stats        |
| admin-telnet_admin_ifaces                           | (null)             |
| admin-telnet_stats_ifaces                           | (null)             |
| admin-version                                       | 1.4.1-45-gab4e6ee  |
| mysql-client_found_rows                             | true               |
| mysql-commands_stats                                | true               |
| mysql-connect_retries_delay                         | 1                  |
| mysql-connect_retries_on_failure                    | 10                 |
| mysql-connect_timeout_server                        | 3000               |
| mysql-connect_timeout_server_max                    | 10000              |
| mysql-connection_delay_multiplex_ms                 | 0                  |
| mysql-connection_max_age_ms                         | 0                  |
| mysql-default_charset                               | utf8               |
| mysql-default_max_latency_ms                        | 1000               |
| mysql-default_query_delay                           | 0                  |
| mysql-default_query_timeout                         | 36000000           |
| mysql-default_reconnect                             | true               |
| mysql-default_schema                                | information_schema |
| mysql-default_sql_mode                              |                    |
| mysql-default_time_zone                             | SYSTEM             |
| mysql-enforce_autocommit_on_reads                   | false              |
| mysql-eventslog_filename                            |                    |
| mysql-eventslog_filesize                            | 104857600          |
| mysql-forward_autocommit                            | false              |
| mysql-free_connections_pct                          | 10                 |
| mysql-have_compress                                 | true               |
| mysql-hostgroup_manager_verbose                     | 1                  |
| mysql-init_connect                                  | (null)             |
| mysql-interfaces                                    | 0.0.0.0:6033       |
| mysql-long_query_time                               | 1000               |
| mysql-max_allowed_packet                            | 4194304            |
| mysql-max_connections                               | 2048               |
| mysql-max_stmts_cache                               | 10000              |
| mysql-max_stmts_per_connection                      | 20                 |
| mysql-max_transaction_time                          | 14400000           |
| mysql-mirror_max_concurrency                        | 16                 |
| mysql-mirror_max_queue_length                       | 32000              |
| mysql-monitor_connect_interval                      | 60000              |
| mysql-monitor_connect_timeout                       | 600                |
| mysql-monitor_enabled                               | true               |
| mysql-monitor_groupreplication_healthcheck_interval | 5000               |
| mysql-monitor_groupreplication_healthcheck_timeout  | 800                |
| mysql-monitor_history                               | 600000             |
| mysql-monitor_password                              | monitor            |
| mysql-monitor_ping_interval                         | 10000              |
| mysql-monitor_ping_max_failures                     | 3                  |
| mysql-monitor_ping_timeout                          | 1000               |
| mysql-monitor_query_interval                        | 60000              |
| mysql-monitor_query_timeout                         | 100                |
| mysql-monitor_read_only_interval                    | 1500               |
| mysql-monitor_read_only_timeout                     | 500                |
| mysql-monitor_replication_lag_interval              | 10000              |
| mysql-monitor_replication_lag_timeout               | 1000               |
| mysql-monitor_slave_lag_when_null                   | 60                 |
| mysql-monitor_username                              | monitor            |
| mysql-monitor_wait_timeout                          | true               |
| mysql-monitor_writer_is_also_reader                 | true               |
| mysql-multiplexing                                  | true               |
| mysql-ping_interval_server_msec                     | 120000             |
| mysql-ping_timeout_server                           | 500                |
| mysql-poll_timeout                                  | 2000               |
| mysql-poll_timeout_on_failure                       | 100                |
| mysql-query_cache_size_MB                           | 256                |
| mysql-query_digests                                 | true               |
| mysql-query_digests_lowercase                       | false              |
| mysql-query_digests_max_digest_length               | 2048               |
| mysql-query_digests_max_query_length                | 65000              |
| mysql-query_processor_iterations                    | 0                  |
| mysql-query_processor_regex                         | 1                  |
| mysql-query_retries_on_failure                      | 1                  |
| mysql-server_capabilities                           | 45578              |
| mysql-server_version                                | 5.5.30             |
| mysql-servers_stats                                 | true               |
| mysql-session_idle_ms                               | 1000               |
| mysql-session_idle_show_processlist                 | true               |
| mysql-sessions_sort                                 | true               |
| mysql-shun_on_failures                              | 5                  |
| mysql-shun_recovery_time_sec                        | 10                 |
| mysql-ssl_p2s_ca                                    | (null)             |
| mysql-ssl_p2s_cert                                  | (null)             |
| mysql-ssl_p2s_cipher                                | (null)             |
| mysql-ssl_p2s_key                                   | (null)             |
| mysql-stacksize                                     | 1048576            |
| mysql-threads                                       | 4                  |
| mysql-threshold_query_length                        | 524288             |
| mysql-threshold_resultset_size                      | 4194304            |
| mysql-wait_timeout                                  | 28800000           |
+-----------------------------------------------------+--------------------+
95 rows in set (0.00 sec)
MySQL [main] 11:16:33 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;ProxySQL多层配置设计&quot;&gt;&lt;a href=&quot;#ProxySQL多层配置设计&quot; class=&quot;headerlink&quot; title=&quot;ProxySQL多层配置设计&quot;&gt;&lt;/a&gt;ProxySQL多层配置设计&lt;/h2&gt;&lt;h3 id=&quot;ProxySQL设计模型介绍&quot;&gt;&lt;a href=&quot;#ProxySQL设计模型介绍&quot; class=&quot;headerlink&quot; title=&quot;ProxySQL设计模型介绍&quot;&gt;&lt;/a&gt;ProxySQL设计模型介绍&lt;/h3&gt;&lt;p&gt;ProxySQL使用多层配置系统，适合满足以下需求：&lt;/p&gt;
&lt;p&gt;允许自动更新配置，与MySQL兼容管理界面；&lt;br&gt;允许在线修改配置，不用重启ProxySQL；&lt;br&gt;允许回滚配置；&lt;br&gt;多层配置系统的实现，如下图：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------------------------+
|         RUNTIME         |
+-------------------------+
       /|\          |
        |           |
    [1] |       [2] |
        |          \|/
+-------------------------+
|         MEMORY          |
+-------------------------+ _
       /|\          |      |\
        |           |        \
    [3] |       [4] |         \ [5]
        |          \|/         \
+-------------------------+  +-------------------------+
|          DISK           |  |       CONFIG FILE       |
+-------------------------+  +-------------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RUNTIME代表ProxySQL当前生效的配置，包括global_variables、mysql_servers、mysql_users、mysql_query_rules。无法直接修改这里的配置，必须要从下一层load过来。&lt;/p&gt;
&lt;p&gt;MEMORY(main)代表平时在mysql命令行修改的main里的配置，可以认为是SQLite数据库在内存的镜像。可修改以下：&lt;/p&gt;
&lt;p&gt;mysql_server        后端服务器列表&lt;br&gt;mysql_users         连接到ProxySQL的用户列表及其凭据&lt;br&gt;mysql_query_rules   将流量路由到不同的后端服务器的规则列表&lt;br&gt;global_variables    全局变量列表&lt;br&gt;mysql_collat        MySQL排序规则列表&lt;br&gt;DISK和CONFIG FILE表示磁盘上SQLite数据库，默认位置在$datadir/proxysql.db，在重新启动过程中，内存中未被保存的配置将丢失。/etc/proxysql.cnf文件只在第一次初始化的时候用到。如要修改端口，还是需要在管理命令行里修改，再save到磁盘。&lt;/p&gt;
&lt;p&gt;ProxySQL多层配置修改示例&lt;/p&gt;
&lt;p&gt;mysql users&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LOAD MYSQL USERS TO RUNTIME / LOAD MYSQL USERS FROM MEMORY
SAVE MYSQL USERS TO MEMORY / SAVE MYSQL USERS FROM RUNTIME
LOAD MYSQL USERS TO MEMORY / LOAD MYSQL USERS FROM DISK
SAVE MYSQL USERS TO DISK /  SAVE MYSQL USERS FROM MEMORY
LOAD MYSQL USERS FROM CONFIG
mysql servers

LOAD MYSQL SERVERS TO RUNTIME   让修改的配置生效
SAVE MYSQL SERVERS TO MEMORY
LOAD MYSQL SERVERS TO MEMORY
SAVE MYSQL SERVERS TO DISK      将修改的配置持久化
LOAD MYSQL SERVERS FROM CONFIG
mysql query rules

load mysql query rules to run
save mysql query rules to mem
load mysql query rules to mem
save mysql query rules to disk
load mysql query rules from config
mysql variables

load mysql variables to runtime
save mysql variables to memory
load mysql variables to memory
save mysql variables to disk
load mysql variables from config
admin variables

load admin variables to runtime
save admin variables to memory
load admin variables to memory
save admin variables to disk
load admin variables from config
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sysown/proxysql/wiki/Multi-layer-configuration-system&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sysown/proxysql/wiki/Multi-layer-configuration-system&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://severalnines.com/blog/mysql-load-balancing-proxysql-overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://severalnines.com/blog/mysql-load-balancing-proxysql-overview&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://seanlook.com/2017/04/10/mysql-proxysql-install-config/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://seanlook.com/2017/04/10/mysql-proxysql-install-config/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;ProxySQL读写分离示例&quot;&gt;&lt;a href=&quot;#ProxySQL读写分离示例&quot; class=&quot;headerlink&quot; title=&quot;ProxySQL读写分离示例&quot;&gt;&lt;/a&gt;ProxySQL读写分离示例&lt;/h1&gt;&lt;h2 id=&quot;准备-1&quot;&gt;&lt;a href=&quot;#准备-1&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;Master:192.168.56.101:3306&lt;br&gt;Slave :192.168.56.102:3306(192.168.56.102)&lt;br&gt;ProxySQL：192.168.56.102:3306(192.168.56.102)&lt;br&gt;版本：percona-server 5.7.18&lt;/p&gt;
&lt;h2 id=&quot;安装配置&quot;&gt;&lt;a href=&quot;#安装配置&quot; class=&quot;headerlink&quot; title=&quot;安装配置&quot;&gt;&lt;/a&gt;安装配置&lt;/h2&gt;&lt;p&gt;主从安装配置省略。&lt;/p&gt;
&lt;h2 id=&quot;示例目标&quot;&gt;&lt;a href=&quot;#示例目标&quot; class=&quot;headerlink&quot; title=&quot;示例目标&quot;&gt;&lt;/a&gt;示例目标&lt;/h2&gt;&lt;p&gt;客户端通过访问ProxySQL的ip，实际访问Master和Slave的效果。&lt;/p&gt;
&lt;h2 id=&quot;添加后端DB服务&quot;&gt;&lt;a href=&quot;#添加后端DB服务&quot; class=&quot;headerlink&quot; title=&quot;添加后端DB服务&quot;&gt;&lt;/a&gt;添加后端DB服务&lt;/h2&gt;&lt;p&gt;100是主库，101是从库，同时主库也处理1/10的读请求，登录ProxySQL管理端设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 14:22:06 &amp;gt; insert into mysql_servers(hostgroup_id,hostname,port,weight,comment) values(100, &amp;apos;192.168.56.101&amp;apos;, 3306, 1, &amp;apos;db0,ReadWrite&amp;apos;),(101, &amp;apos;192.168.56.102&amp;apos;, 3306, 9, &amp;apos;db0,ReadOnly&amp;apos;);
Query OK, 2 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;添加访问用户&quot;&gt;&lt;a href=&quot;#添加访问用户&quot; class=&quot;headerlink&quot; title=&quot;添加访问用户&quot;&gt;&lt;/a&gt;添加访问用户&lt;/h2&gt;&lt;p&gt;登录Master主库设置监控用户和程序用户(由于是测试使用，权限较大，主机允许所有)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 15:51:32 &amp;gt; create user &amp;apos;monitor&amp;apos;@&amp;apos;%&amp;apos; identified by &amp;apos;monitor&amp;apos;;
Query OK, 0 rows affected (0.00 sec)
MySQL [(none)] 15:51:37 &amp;gt; grant select,super,process,show databases,replication client,replication slave on *.* to &amp;apos;monitor&amp;apos;@&amp;apos;%&amp;apos;;
Query OK, 0 rows affected (0.00 sec)
MySQL [(none)] 15:45:23 &amp;gt; create user &amp;apos;user0&amp;apos;@&amp;apos;%&amp;apos; identified by &amp;apos;password0&amp;apos;;                   
Query OK, 0 rows affected (0.00 sec)
MySQL [(none)] 15:49:42 &amp;gt; GRANT SELECT, RELOAD, PROCESS, SHOW DATABASES, SUPER, LOCK TABLES, EXECUTE, SHOW VIEW, TRIGGER, EVENT ON *.* TO &amp;apos;read0&amp;apos;@&amp;apos;%&amp;apos;;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;登录ProxySQL管理端设置：&lt;br&gt;这里default_hostgroup指定了hostgroup为100的主库，下文会设置SELECT …FOR UPDATE规则到100，SELECT到101，其他所有的SQL到default_hostgroup，也就是主库。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 14:22:15 &amp;gt; INSERT INTO mysql_users (username, password, active, default_hostgroup, max_connections) VALUES (&amp;apos;user0&amp;apos;, &amp;apos;password0&amp;apos;, 1, 100, 1000); 
Query OK, 2 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;添加复制关系&quot;&gt;&lt;a href=&quot;#添加复制关系&quot; class=&quot;headerlink&quot; title=&quot;添加复制关系&quot;&gt;&lt;/a&gt;添加复制关系&lt;/h2&gt;&lt;p&gt;登录ProxySQL管理端设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [main] 17:32:46 &amp;gt; INSERT INTO mysql_replication_hostgroups VALUES(100,101,&amp;apos;db0&amp;apos;);
Query OK, 1 row affected (0.00 sec)
MySQL [main] 17:33:30 &amp;gt; load mysql variables to runtime;
Query OK, 0 rows affected (0.00 sec)
MySQL [main] 17:33:54 &amp;gt; save mysql variables to disk;
Query OK, 83 rows affected (0.01 sec)
MySQL [main] 17:35:53 &amp;gt; SELECT * FROM monitor.mysql_server_read_only_log ORDER BY time_start_us DESC LIMIT 10;
+---------------+------+------------------+-----------------+-----------+-------+
| hostname      | port | time_start_us    | success_time_us | read_only | error |
+---------------+------+------------------+-----------------+-----------+-------+
| 192.168.56.102  | 3306 | 1504085770195146 | 630             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504085770194710 | 23722           | 0         | NULL  |
| 192.168.56.102  | 3306 | 1504085768695087 | 650             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504085768694620 | 23706           | 0         | NULL  |
| 192.168.56.102  | 3306 | 1504085767194957 | 628             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504085767194507 | 23686           | 0         | NULL  |
| 192.168.56.102  | 3306 | 1504085765694834 | 634             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504085765694387 | 23669           | 0         | NULL  |
| 192.168.56.102  | 3306 | 1504085764194744 | 641             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504085764194301 | 23729           | 0         | NULL  |
+---------------+------+------------------+-----------------+-----------+-------+
10 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;修改全局变量&quot;&gt;&lt;a href=&quot;#修改全局变量&quot; class=&quot;headerlink&quot; title=&quot;修改全局变量&quot;&gt;&lt;/a&gt;修改全局变量&lt;/h2&gt;&lt;p&gt;登录ProxySQL管理端设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 14:25:07 &amp;gt; set mysql-query_retries_on_failure=0;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-max_stmts_per_connection=1000;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-eventslog_filename=&amp;apos;queries.log&amp;apos;;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-monitor_slave_lag_when_null=7200;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-ping_timeout_server=1500;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-monitor_connect_timeout=1000;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-default_max_latency_ms=2000;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-monitor_username=&amp;apos;monitor&amp;apos;;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-monitor_password=&amp;apos;monitor&amp;apos;;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-server_version=&amp;apos;5.7.18&amp;apos;;
Query OK, 1 row affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;全局变量生效并保存到磁盘：&lt;br&gt;登录ProxySQL管理端设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 14:25:07 &amp;gt; load mysql users to runtime;
Query OK, 0 rows affected (0.00 sec)
MySQL [(none)] 14:25:27 &amp;gt; load mysql servers to runtime;
Query OK, 0 rows affected (0.00 sec)
MySQL [(none)] 14:25:27 &amp;gt; load mysql variables to runtime;
Query OK, 0 rows affected (0.00 sec)
MySQL [(none)] 14:25:28 &amp;gt; save mysql users to disk;
Query OK, 0 rows affected (0.02 sec)
MySQL [(none)] 14:25:36 &amp;gt; save mysql servers to disk;
save mysql variables to disk;Query OK, 0 rows affected (0.03 sec)
MySQL [(none)] 14:25:37 &amp;gt; save mysql variables to disk;
Query OK, 83 rows affected (0.01 sec)
MySQL [(none)] 14:25:37 &amp;gt; save mysql users to mem;  -- 可以屏蔽看到的明文密码
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;路由规则&quot;&gt;&lt;a href=&quot;#路由规则&quot; class=&quot;headerlink&quot; title=&quot;路由规则&quot;&gt;&lt;/a&gt;路由规则&lt;/h2&gt;&lt;p&gt;ProxySQL使用查询规则来确定路由，如果没有规则用于查询，默认会访问hostgroup 0主机组，会报以下错误：&lt;/p&gt;
&lt;p&gt;[root@mysql_slave ~]# mysql -uuser0 -ppassword0 -h 127.0.0.1 -P6033 -e “SELECT 1”&lt;br&gt;mysql: [Warning] Using a password on the command line interface can be insecure.&lt;br&gt;ERROR 9001 (HY000) at line 1: Max connect timeout reached while reaching hostgroup 1 after 2000ms&lt;br&gt;设置路由规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 09:29:14 &amp;gt; use main;
Database changed
MySQL [main] 09:29:17 &amp;gt; INSERT INTO mysql_query_rules (active, match_pattern, destination_hostgroup, cache_ttl) VALUES (1, &amp;apos;^.*&amp;apos;, 101, NULL);
MySQL [main] 09:29:15 &amp;gt; INSERT INTO mysql_query_rules (active, match_pattern, destination_hostgroup, cache_ttl) VALUES (1, &amp;apos;^SELECT .* FOR UPDATE&amp;apos;, 100, NULL);
Query OK, 1 row affected (0.00 sec)
MySQL [main] 09:29:17 &amp;gt; INSERT INTO mysql_query_rules (active, match_pattern, destination_hostgroup, cache_ttl) VALUES (1, &amp;apos;^SELECT .*&amp;apos;, 101, NULL);
Query OK, 1 row affected (0.00 sec)
MySQL [main] 09:29:18 &amp;gt; load mysql query rules to run;
Query OK, 0 rows affected (0.00 sec)
MySQL [main] 09:29:56 &amp;gt; save mysql query rules to disk;
Query OK, 0 rows affected (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;常用查询&quot;&gt;&lt;a href=&quot;#常用查询&quot; class=&quot;headerlink&quot; title=&quot;常用查询&quot;&gt;&lt;/a&gt;常用查询&lt;/h2&gt;&lt;p&gt;查询连接日志：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:45:08 &amp;gt; SELECT * FROM monitor.mysql_server_connect_log ORDER BY time_start_us DESC LIMIT 10;
+---------------+------+------------------+-------------------------+---------------+
| hostname      | port | time_start_us    | connect_success_time_us | connect_error |
+---------------+------+------------------+-------------------------+---------------+
| 192.168.56.102  | 3306 | 1504590343795072 | 410                     | NULL          |
| 192.168.56.101 | 3306 | 1504590343780010 | 69662                   | NULL          |
| 192.168.56.102  | 3306 | 1504590283795083 | 521                     | NULL          |
| 192.168.56.101 | 3306 | 1504590283779977 | 68310                   | NULL          |
| 192.168.56.102  | 3306 | 1504590223794987 | 533                     | NULL          |
| 192.168.56.101 | 3306 | 1504590223779913 | 53220                   | NULL          |
| 192.168.56.102  | 3306 | 1504590163794887 | 497                     | NULL          |
| 192.168.56.101 | 3306 | 1504590163779772 | 71389                   | NULL          |
| 192.168.56.102  | 3306 | 1504590103794788 | 487                     | NULL          |
| 192.168.56.101 | 3306 | 1504590103779728 | 68372                   | NULL          |
+---------------+------+------------------+-------------------------+---------------+
10 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询ping日志：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:46:22 &amp;gt; SELECT * FROM monitor.mysql_server_ping_log ORDER BY time_start_us DESC LIMIT 10;
+---------------+------+------------------+----------------------+------------+
| hostname      | port | time_start_us    | ping_success_time_us | ping_error |
+---------------+------+------------------+----------------------+------------+
| 192.168.56.102  | 3306 | 1504590413773092 | 100                  | NULL       |
| 192.168.56.101 | 3306 | 1504590413770521 | 23105                | NULL       |
| 192.168.56.102  | 3306 | 1504590403773088 | 168                  | NULL       |
| 192.168.56.101 | 3306 | 1504590403770479 | 23080                | NULL       |
| 192.168.56.102  | 3306 | 1504590393772977 | 135                  | NULL       |
| 192.168.56.101 | 3306 | 1504590393770364 | 23078                | NULL       |
| 192.168.56.102  | 3306 | 1504590383772899 | 138                  | NULL       |
| 192.168.56.101 | 3306 | 1504590383770309 | 23205                | NULL       |
| 192.168.56.102  | 3306 | 1504590373772885 | 102                  | NULL       |
| 192.168.56.101 | 3306 | 1504590373770291 | 23099                | NULL       |
+---------------+------+------------------+----------------------+------------+
10 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询后端DB状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:46:55 &amp;gt; SELECT * FROM mysql_servers;
+--------------+---------------+------+--------+--------+-------------+-----------------+---------------------+---------+----------------+---------------+
| hostgroup_id | hostname      | port | status | weight | compression | max_connections | max_replication_lag | use_ssl | max_latency_ms | comment       |
+--------------+---------------+------+--------+--------+-------------+-----------------+---------------------+---------+----------------+---------------+
| 100          | 192.168.56.101 | 3306 | ONLINE | 1      | 0           | 1000            | 0                   | 0       | 0              | db0,ReadWrite |
| 101          | 192.168.56.102  | 3306 | ONLINE | 9      | 0           | 1000            | 0                   | 0       | 0              | db0,ReadOnly  |
+--------------+---------------+------+--------+--------+-------------+-----------------+---------------------+---------+----------------+---------------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询监控状态：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:47:56 &amp;gt; SELECT * FROM monitor.mysql_server_read_only_log ORDER BY time_start_us DESC LIMIT 10;   
+---------------+------+------------------+-----------------+-----------+-------+
| hostname      | port | time_start_us    | success_time_us | read_only | error |
+---------------+------+------------------+-----------------+-----------+-------+
| 192.168.56.102  | 3306 | 1504590524103828 | 577             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504590524103406 | 23499           | 0         | NULL  |
| 192.168.56.102  | 3306 | 1504590522603717 | 646             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504590522603268 | 23487           | 0         | NULL  |
| 192.168.56.102  | 3306 | 1504590521103641 | 629             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504590521103182 | 23497           | 0         | NULL  |
| 192.168.56.102  | 3306 | 1504590519603662 | 639             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504590519603201 | 23525           | 0         | NULL  |
| 192.168.56.102  | 3306 | 1504590518103492 | 618             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504590518103062 | 23508           | 0         | NULL  |
+---------------+------+------------------+-----------------+-----------+-------+
10 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询用户信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:49:28 &amp;gt;  SELECT * FROM mysql_users;   
+----------+-----------+--------+---------+-------------------+----------------+---------------+------------------------+--------------+---------+----------+-----------------+
| username | password  | active | use_ssl | default_hostgroup | default_schema | schema_locked | transaction_persistent | fast_forward | backend | frontend | max_connections |
+----------+-----------+--------+---------+-------------------+----------------+---------------+------------------------+--------------+---------+----------+-----------------+
| user0    | password0 | 1      | 0       | 100               | NULL           | 0             | 1                      | 0            | 1       | 1        | 1000            |
+----------+-----------+--------+---------+-------------------+----------------+---------------+------------------------+--------------+---------+----------+-----------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询连接池：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:51:19 &amp;gt; SELECT * FROM stats.stats_mysql_connection_pool;
+-----------+---------------+----------+--------+----------+----------+--------+---------+---------+-----------------+-----------------+------------+
| hostgroup | srv_host      | srv_port | status | ConnUsed | ConnFree | ConnOK | ConnERR | Queries | Bytes_data_sent | Bytes_data_recv | Latency_us |
+-----------+---------------+----------+--------+----------+----------+--------+---------+---------+-----------------+-----------------+------------+
| 100       | 192.168.56.101 | 3306     | ONLINE | 0        | 1        | 1      | 0       | 3       | 58              | 233             | 23059      |
| 101       | 192.168.56.102  | 3306     | ONLINE | 0        | 1        | 3      | 88      | 5       | 106             | 360             | 102        |
+-----------+---------------+----------+--------+----------+----------+--------+---------+---------+-----------------+-----------------+------------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询执行命令统计信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:51:47 &amp;gt; SELECT * FROM stats_mysql_commands_counters WHERE Total_cnt;
+---------+---------------+-----------+-----------+-----------+---------+---------+----------+----------+-----------+-----------+--------+--------+---------+----------+
| Command | Total_Time_us | Total_cnt | cnt_100us | cnt_500us | cnt_1ms | cnt_5ms | cnt_10ms | cnt_50ms | cnt_100ms | cnt_500ms | cnt_1s | cnt_5s | cnt_10s | cnt_INFs |
+---------+---------------+-----------+-----------+-----------+---------+---------+----------+----------+-----------+-----------+--------+--------+---------+----------+
| SELECT  | 167664        | 27        | 15        | 4         | 0       | 6       | 0        | 1        | 0         | 1         | 0      | 0      | 0       | 0        |
| SET     | 0             | 2         | 2         | 0         | 0       | 0       | 0        | 0        | 0         | 0         | 0      | 0      | 0       | 0        |
| SHOW    | 13818         | 1         | 0         | 0         | 0       | 0       | 0        | 1        | 0         | 0         | 0      | 0      | 0       | 0        |
+---------+---------------+-----------+-----------+-----------+---------+---------+----------+----------+-----------+-----------+--------+--------+---------+----------+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询路由规则的详情：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:53:05 &amp;gt; SELECT * FROM stats_mysql_query_digest ORDER BY sum_time DESC;
+-----------+--------------------+----------+--------------------+----------------------------------+------------+------------+------------+----------+----------+----------+
| hostgroup | schemaname         | username | digest             | digest_text                      | count_star | first_seen | last_seen  | sum_time | min_time | max_time |
+-----------+--------------------+----------+--------------------+----------------------------------+------------+------------+------------+----------+----------+----------+
| 100       | information_schema | user0    | 0xA322907BCBC120DD | select * from tables limit ?     | 1          | 1504589288 | 1504589288 | 133826   | 133826   | 133826   |
| 100       | information_schema | user0    | 0x02033E45904D3DF0 | show databases                   | 1          | 1504589886 | 1504589886 | 13818    | 13818    | 13818    |
| 100       | information_schema | user0    | 0x3765930C7143F468 | select * from t1                 | 1          | 1504589311 | 1504589311 | 13466    | 13466    | 13466    |
| 101       | information_schema | user0    | 0xA322907BCBC120DD | select * from tables limit ?     | 2          | 1504582304 | 1504583327 | 7325     | 3564     | 3761     |
| 101       | test               | user0    | 0x814EDBB68FBACD5D | select * from neworders limit ?  | 2          | 1504583184 | 1504583242 | 5959     | 2964     | 2995     |
| 101       | test               | user0    | 0x3765930C7143F468 | select * from t1                 | 3          | 1504583288 | 1504589859 | 3386     | 64       | 3056     |
| 101       | test               | user0    | 0xA322907BCBC120DD | select * from tables limit ?     | 2          | 1504583168 | 1504583299 | 3095     | 117      | 2978     |
| 101       | information_schema | user0    | 0x620B328FE9D6D71A | SELECT DATABASE()                | 2          | 1504589729 | 1504589859 | 607      | 193      | 414      |
| 100       | information_schema | user0    | 0x226CD90D52A2BA0B | select @@version_comment limit ? | 8          | 1504582304 | 1504589886 | 0        | 0        | 0        |
| 100       | test               | user0    | 0x52B8B04283B3A18D | set names utf8                   | 1          | 1504583162 | 1504583162 | 0        | 0        | 0        |
| 100       | information_schema | user0    | 0x52B8B04283B3A18D | set names utf8                   | 1          | 1504582582 | 1504582582 | 0        | 0        | 0        |
| 100       | test               | user0    | 0x226CD90D52A2BA0B | select @@version_comment limit ? | 6          | 1504583162 | 1504583299 | 0        | 0        | 0        |
+-----------+--------------------+----------+--------------------+----------------------------------+------------+------------+------------+----------+----------+----------+
12 rows in set (0.00 sec)
MySQL [(none)] 13:55:46 &amp;gt; SELECT hostgroup hg, sum_time, count_star, digest_text FROM stats_mysql_query_digest ORDER BY sum_time DESC;
+-----+----------+------------+----------------------------------+
| hg  | sum_time | count_star | digest_text                      |
+-----+----------+------------+----------------------------------+
| 100 | 133826   | 1          | select * from tables limit ?     |
| 100 | 13818    | 1          | show databases                   |
| 100 | 13466    | 1          | select * from t1                 |
| 101 | 7325     | 2          | select * from tables limit ?     |
| 101 | 5959     | 2          | select * from neworders limit ?  |
| 101 | 3386     | 3          | select * from t1                 |
| 101 | 3095     | 2          | select * from tables limit ?     |
| 101 | 607      | 2          | SELECT DATABASE()                |
| 100 | 0        | 8          | select @@version_comment limit ? |
| 100 | 0        | 1          | set names utf8                   |
| 100 | 0        | 1          | set names utf8                   |
| 100 | 0        | 6          | select @@version_comment limit ? |
+-----+----------+------------+----------------------------------+
12 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询路由规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:57:12 &amp;gt; SELECT rule_id, match_digest, match_pattern, replace_pattern, cache_ttl, apply FROM mysql_query_rules ORDER BY rule_id;
+---------+--------------+-----------------------+-----------------+-----------+-------+
| rule_id | match_digest | match_pattern         | replace_pattern | cache_ttl | apply |
+---------+--------------+-----------------------+-----------------+-----------+-------+
| 10      | NULL         | ^SELECT .* FOR UPDATE | NULL            | NULL      | 0     |
| 11      | NULL         | ^SELECT .*            | NULL            | NULL      | 0     |
+---------+--------------+-----------------------+-----------------+-----------+-------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sysown/proxysql/wiki/ProxySQL-Configuration#p6033&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sysown/proxysql/wiki/ProxySQL-Configuration#p6033&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://seanlook.com/2017/04/17/mysql-proxysql-route-rw_split/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://seanlook.com/2017/04/17/mysql-proxysql-route-rw_split/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://severalnines.com/blog/how-proxysql-adds-failover-and-query-control-your-mysql-replication-setup&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://severalnines.com/blog/how-proxysql-adds-failover-and-query-control-your-mysql-replication-setup&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;ProxySQL监控&quot;&gt;&lt;a href=&quot;#ProxySQL监控&quot; class=&quot;headerlink&quot; title=&quot;ProxySQL监控&quot;&gt;&lt;/a&gt;ProxySQL监控&lt;/h1&gt;&lt;p&gt;PMM是Percona推出的一款很好的监控MySQL和MongoDB的开源工具，安装方便，功能丰富，图表美观，同时也支持ProxySQL的监控，故选择PMM作为ProxySQL的监控软件。&lt;br&gt;这里以ProxySQL服务端(192.168.56.102)为例，作为PMM的客户端，PMM服务器为192.168.56.111,仅演示ProxySQL安装PMM客户端，服务器安装配置省略。&lt;/p&gt;
&lt;h2 id=&quot;PMM-Client安装&quot;&gt;&lt;a href=&quot;#PMM-Client安装&quot; class=&quot;headerlink&quot; title=&quot;PMM Client安装&quot;&gt;&lt;/a&gt;PMM Client安装&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;[root@mysql_slave ~]# yum localinstall -y /hwdata/duanwenjie/test/proxysql-1.4.1-1-centos67.x86_64.rpm 
Loaded plugins: security
Setting up Local Package Process
Examining /hwdata/duanwenjie/test/proxysql-1.4.1-1-centos67.x86_64.rpm: proxysql-1.4.1-1.x86_64
Marking /hwdata/duanwenjie/test/proxysql-1.4.1-1-centos67.x86_64.rpm to be installed
Resolving Dependencies
There are unfinished transactions remaining. You might consider running yum-complete-transaction first to finish them.
--&amp;gt; Running transaction check
---&amp;gt; Package proxysql.x86_64 0:1.4.1-1 will be installed
--&amp;gt; Finished Dependency Resolution
Dependencies Resolved
========================================================================================================================================================================
 Package                           Arch                            Version                             Repository                                                  Size
========================================================================================================================================================================
Installing:
 proxysql                          x86_64                          1.4.1-1                             /proxysql-1.4.1-1-centos67.x86_64                           19 M
Transaction Summary
========================================================================================================================================================================
Install       1 Package(s)
Total size: 19 M
Installed size: 19 M
Downloading Packages:
Running rpm_check_debug
Running Transaction Test
Transaction Test Succeeded
Running Transaction
Warning: RPMDB altered outside of yum.
** Found 1 pre-existing rpmdb problem(s), &amp;apos;yum check&amp;apos; output follows:
mysql-community-libs-5.7.16-1.el6.x86_64 has missing requires of mysql-community-common(x86-64) &amp;gt;= (&amp;apos;0&amp;apos;, &amp;apos;5.7.9&amp;apos;, None)
  Installing : proxysql-1.4.1-1.x86_64                                                                                                                              1/1 
  Verifying  : proxysql-1.4.1-1.x86_64                                                                                                                              1/1 
Installed:
  proxysql.x86_64 0:1.4.1-1                                                                                                                                             
Complete!
[root@mysql_slave ~]#
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;PMM-Client配置&quot;&gt;&lt;a href=&quot;#PMM-Client配置&quot; class=&quot;headerlink&quot; title=&quot;PMM Client配置&quot;&gt;&lt;/a&gt;PMM Client配置&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;[root@mysql_slave ~]# ifconfig  #查看IP地址
eth0      Link encap:Ethernet  HWaddr 00:16:3E:00:DC:49  
          inet addr:192.168.56.102  Bcast:192.168.15.255  Mask:255.255.240.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1017660 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1380639 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:273791594 (261.1 MiB)  TX bytes:116287303 (110.9 MiB)
lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:1297762 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1297762 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:141606631 (135.0 MiB)  TX bytes:141606631 (135.0 MiB)
[root@mysql_slave ~]# pmm-admin config --bind-address 192.168.56.102 --client-address 192.168.56.102 --server 192.168.56.111:8080 --client-name ProxySQL_Test   #添加config
OK, PMM server is alive.
PMM Server      | 192.168.56.111:8080 
Client Name     | ProxySQL_Test
Client Address  | 192.168.56.102 (192.168.56.102)
[root@mysql_slave ~]# pmm-admin add linux:metrics --force ProxySQL_Test     #添加Linux监控
OK, now monitoring this system.
[root@mysql_slave ~]# 
[root@mysql_slave ~]# pmm-admin add proxysql:metrics --dsn &amp;quot;admin:admin@tcp(127.0.0.1:6032)/&amp;quot; proxysql6032 #添加ProxySQL监控
OK, now monitoring ProxySQL metrics using DSN admin:***@tcp(localhost:6032)
[root@mysql_slave ~]# 
[root@mysql_slave ~]# pmm-admin list    #查看状态
pmm-admin 1.3.0
PMM Server      | 192.168.56.111:8080 
Client Name     | ProxySQL_Test
Client Address  | 192.168.56.102 (192.168.56.102)
Service Manager | unix-systemv
----------------- -------------- ----------- -------- ------------------------------ --------
SERVICE TYPE      NAME           LOCAL PORT  RUNNING  DATA SOURCE                    OPTIONS 
----------------- -------------- ----------- -------- ------------------------------ --------
linux:metrics     ProxySQL_Test  42000       YES      -                                      
mysql:metrics     ProxySQL_Test  42002       YES      root:***@tcp(127.0.0.1:3306)           
proxysql:metrics  proxysql6032   42004       YES      admin:***@tcp(127.0.0.1:6032)          
[root@mysql_slave ~]#
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PMM Server监控项包括：&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;ProxySQL是一款很出色的MySQL中间件，在稳定性上、易用性、高性能等方面表现很不错。由于发布的时间较短，功能可能还不太完善，需要多做测试，特别是查询路由和规则方面需要详情的了解，测试。可重点关注。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在MySQL的高可用集群环境中，中间件是不可缺少的一部分，它提供了读写分离、负载均衡等各种功能，满足集群的横向、纵向的可扩展。由于
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="读写分离" scheme="http://idber.github.io/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>内存的80％？应该如何调整你的innodb_buffer_pool_size</title>
    <link href="http://idber.github.io/2018/08/26-%E5%86%85%E5%AD%98%E7%9A%8480%EF%BC%85%EF%BC%9F%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E4%BD%A0%E7%9A%84innodb_buffer_pool_size.html"/>
    <id>http://idber.github.io/2018/08/26-内存的80％？应该如何调整你的innodb_buffer_pool_size.html</id>
    <published>2018-08-26T02:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.935Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;现在看来，如果有人知道如何调优InnoDB，那就是你必须将innodb_buffer_pool_size调整到物理内存的80％。多数都是这样建议，它似乎深深植根于DBA的脑海中。&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL手册&lt;/a&gt;引用了这个规则，那么谁能责怪DBA呢？问题是：这有意义吗？&lt;/p&gt;
&lt;h1 id=&quot;什么使用服务器上的内存？&quot;&gt;&lt;a href=&quot;#什么使用服务器上的内存？&quot; class=&quot;headerlink&quot; title=&quot;什么使用服务器上的内存？&quot;&gt;&lt;/a&gt;什么使用服务器上的内存？&lt;/h1&gt;&lt;p&gt;在我们质疑这样的建议之前，让我们考虑一下在典型的MySQL服务器中可以占用RAM的广泛类别。这个列表不一定完整，但我认为它概述了MySQL服务器消耗内存的大面积。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;操作系统：内核，正在运行的进程，文件系统缓存等。
MySQL固定使用：查询缓存，InnoDB缓冲池大小，mysqld rss等。
基于MySQL工作负载的使用：连接，每个查询缓冲区（连接缓冲区，排序缓冲区等）
MySQL复制：  二进制日志缓存，复制连接，Galera gcache和证书索引等。
同一服务器上的任何其他服务： Web服务器，缓存服务器，cronjobs等。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;毫无疑问，对于调优InnoDB，innodb_buffer_pool_size是最重要的变量。预计它将占用专用MySQL / Innodb服务器上的大部分RAM，但当然其他本地服务可能会影响它的调整方式。如果它（以及服务器上的其他内存消耗）太大，交换可能会启动并迅速降低性能。&lt;/p&gt;
&lt;p&gt;此外，MySQL服务器本身的工作量可能会导致很多变化。服务器是否有大量的开放连接和活动查询工作负载消耗内存？由此引起的内存消耗可能与服务器有很大不同。&lt;/p&gt;
&lt;p&gt;最后，像Galera这样的复制机制有自己的内存使用模式，可能需要对缓冲池进行一些调整。&lt;/p&gt;
&lt;p&gt;我们可以清楚地看到，80％的规则并不像现实那样微妙。&lt;/p&gt;
&lt;h1 id=&quot;经验法则&quot;&gt;&lt;a href=&quot;#经验法则&quot; class=&quot;headerlink&quot; title=&quot;经验法则&quot;&gt;&lt;/a&gt;经验法则&lt;/h1&gt;&lt;p&gt;但是，为了论证，让我们说80％的规则是一个起点。根据经验，帮助我们获得快速调整数字以使服务器运行。假设我们对系统的工作负载还不知道，但我们知道该系统专用于InnoDB，我们的80％规则怎么能发挥作用呢？&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;服务器总RAM&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;具有80％规则的缓冲池&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;剩余的RAM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;800MB&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;200MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;16G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;13G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;3G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;32G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;26G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;6G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;64G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;51G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;13G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;128G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;102G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;26G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;256G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;205G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;51G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;512G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;409G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;103G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1024G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;819G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;205G&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;数字较低，我们的80％规则看起来很合理。然而，当我们进入大型服务器时，它似乎开始变得不那么理智了。要使规则成立，它必须意味着工作负载内存消耗与缓冲池所需大小成比例增加，但通常情况并非如此。我们的服务器具有1TB的RAM可能不需要205G来处理连接和查询之类的东西（可能MySQL无法处理那么多活动连接和查询）。&lt;/p&gt;
&lt;p&gt;那么，如果你真的把所有的钱花在了一台强大的服务器上，你是否真的想因为这个经验法则对该资源征收20％的税？&lt;/p&gt;
&lt;h1 id=&quot;规则的起源&quot;&gt;&lt;a href=&quot;#规则的起源&quot; class=&quot;headerlink&quot; title=&quot;规则的起源&quot;&gt;&lt;/a&gt;规则的起源&lt;/h1&gt;&lt;p&gt;在我的第一次MySQL会议上，可能是在2006-2007我在雅虎工作时，我参加了由Heikki Tuuri（InnoDB的原作者）和Peter Zaitsev主持的InnoDB调优讲座。我清楚地记得询问80％的规则，因为当时雅虎有一些强大的64G服务器而且规则并不适合我。&lt;/p&gt;
&lt;p&gt;Heikki的答案让我印象深刻。他说了一些（不是直接引用）的结果：“好吧，我测试的服务器有1GB内存，80％似乎是正确的”。然后，如果记忆服务，他澄清了它并说它不会适用于更大的服务器。&lt;/p&gt;
&lt;h1 id=&quot;你应该如何调整？&quot;&gt;&lt;a href=&quot;#你应该如何调整？&quot; class=&quot;headerlink&quot; title=&quot;你应该如何调整？&quot;&gt;&lt;/a&gt;你应该如何调整？&lt;/h1&gt;&lt;p&gt;80％可能是一个很好的开始和经验法则。您确实希望确保服务器有足够的可用RAM用于操作系统和通常未知的工作负载。但是，正如我们上面所看到的，服务器越大，规则就越有可能浪费RAM。我认为对于大多数人来说，它以经验法则开始和结束，主要是因为更改InnoDB缓冲池需要在当前版本中重新启动。&lt;/p&gt;
&lt;p&gt;那么什么是更好的经验法则？我的规则是，当系统运行生产工作负载时，您可以在不使用swap的情况下调整innodb_buffer_pool_size尽可能大。原则上听起来不错，但同样需要一堆重启，说起来容易做起来难。&lt;/p&gt;
&lt;p&gt;幸运的是，  MySQL 5.7及其在线缓冲池调整大小功能应该使这个原则更容易理解。看到大量的空闲RAM（或者文件系统缓存使用）？动态调高缓冲池。看到一些交换活动？只需将其关闭即可，无需重启。在实践中，我怀疑使用此功能会有一些与性能相关的打嗝，但这至少是朝着正确方向迈出的一大步。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;现在看来，如果有人知道如何调优InnoDB，那就是你必须将innodb_buffer_pool_size调整到物理内存的80％。多数都是这样建议，它似乎深深植根于DBA的脑海中。&lt;a href=&quot;https://dev.mysql.com/doc/refman/5
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="性能" scheme="http://idber.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 5.7新特性系列二</title>
    <link href="http://idber.github.io/2018/08/24-MySQL%205.7%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%E4%BA%8C.html"/>
    <id>http://idber.github.io/2018/08/24-MySQL 5.7新特性系列二.html</id>
    <published>2018-08-23T22:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.929Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;系统变量&lt;br&gt;5.7以后System and status 变量需要从performance_schema中进行获取，information_schema仍然保留了GLOBAL_STATUS，GLOBAL_VARIABLES两个表做兼容。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[兼容性]&lt;br&gt;如果希望沿用information_schema中进行查询的习惯，5.7提供了show_compatibility_56参数，设置为ON可以兼容5.7之前的用法，否则就会报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ERROR 3167 (HY000): The &amp;apos;INFORMATION_SCHEMA.GLOBAL_STATUS&amp;apos; feature is disabled; see the documentation for &amp;apos;show_compatibility_56&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.7.6之后，在performance_schema新增了如下的表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;performance_schema.global_variables
performance_schema.session_variables
performance_schema.variables_by_thread
performance_schema.global_status
performance_schema.session_status
performance_schema.status_by_thread
performance_schema.status_by_account
performance_schema.status_by_host
performance_schema.status_by_user
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.7.9之前，需要有SELECT_ACL权限才能进行show查询，但5.7.9之后，默认这些表是不需要任何权限就可以访问了。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;sys schema&lt;br&gt;新增了sys数据库，主要是performance_schema收集的信息，帮助DBA和开发人员方便诊断问题。 sys下的一共包括三种对象：1. view，2. procedure 3 function 这些对象都是基于performance_schema下的表，进行了可读性的聚合，没有真正存储数据，只存储了定义。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[兼容性]&lt;br&gt;mysql_install_db可以选择–skip-sys-schema跳过安装过程， 但默认mysql_upgrade会帮你创建sys下面的对象。不存在兼容性的问题&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;p&gt;异常栈&lt;br&gt;5.7开始支持异常诊断栈信息，通过GET STACKED DIAGNOSTICS可以获取栈内的信息。 具体的使用方法参考：&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/diagnostics-area.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/diagnostics-area.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Triggers&lt;br&gt;支持在一个table对象上建多个trigger。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Generated Columns&lt;br&gt;5.7.6开始，支持生成列，这个列可以是虚拟的列，也可以是实体存储数据的列。 比如：&lt;/p&gt;
&lt;p&gt; CREATE TABLE triangle (&lt;br&gt;   sidea DOUBLE,&lt;br&gt;   sideb DOUBLE,&lt;br&gt;   sidec DOUBLE AS (SQRT(sidea &lt;em&gt; sidea + sideb &lt;/em&gt; sideb))&lt;br&gt; );&lt;br&gt;VIRTUAL： 表示这个字段是虚拟列，并不进行存储，查询的时候，通过计算得到&lt;br&gt;STORED： 需要存储空间，并且可以被索引的列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;exchange partition不验证&lt;br&gt;这个是在oracle分区表上支持的功能，dba在做大表维护的时候，非常有用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;语法： ALTER TABLE … EXCHANGE PARTITION WITHOUT VALIDATION&lt;br&gt;如果不验证，那么只有元数据信息的更改，就可以完成exchange，否则，就需要读取每一行数据进行验证，维护时间将根据这个表大小有关系。&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;&lt;p&gt;dump线程增强&lt;br&gt;5.7.2之前，master dump线程需要持有LOCK_log锁去读取binlog然后发送到备库，而这时会阻塞client端去写入binlog。5.7.2之后，dump线程只需要持有LOCK_binlog_end_pos这个锁去读取binlog的当前的位置，来决定是否发送到备库去，这样就可以做到不阻塞任何binlog的写入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多源复制&lt;br&gt;多源复制可以从多个master复制到一个slave端，在数据库集群进行扩容和缩容的时候，非常有用。我们会在后面的系列单独来介绍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在线更改replication master&lt;br&gt;可以不用stop slave，然后在线更改replication master信息。 但这里并不是不需要slave停掉， 而是change master涉及到几个动作：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果只是更改当前relay的信息，那么只需要sql线程是不工作的就可以了，IO thread可以继续&lt;br&gt;如果只是更改主库的信息，那么只需要IO线程不工作就可以了。 sql thread可以继续&lt;br&gt;如果需要重新启动主库和备库的恢复信息，比如master_auto_positioin=1，那么就需要IO和sql线程都停掉。&lt;/p&gt;
&lt;ol start=&quot;10&quot;&gt;
&lt;li&gt;Group Replication&lt;br&gt;并行复制支持按照主库组提交的形式在备库进行回放。下一个系列进行单独来介绍&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面单独介绍一下MySQL 5.7对临时表进行的改动。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;背景&lt;br&gt;MySQL包括两类临时表，一类是通过create temporary table创建的临时表，一类是在query过程中using temporary而创建的临时表。 5.7之前，using temporary创建的临时表，默认只能使用myisam引擎，而在5.7之后，可以选择InnoDB引擎来创建。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;临时表的引擎选择使用下面的这两个参数来决定：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show global variables like &amp;apos;%tmp%&amp;apos;;
+----------------------------------+---------------------------------------+
| Variable_name                    | Value                                 |
+----------------------------------+---------------------------------------+
| default_tmp_storage_engine       | InnoDB                                |
| internal_tmp_disk_storage_engine | InnoDB                                |
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;临时表空间&lt;br&gt;5.7之后，使用了独立的临时表空间来存储临时表数据，但不能是压缩表。临时表空间在实例启动的时候进行创建，shutdown的时候进行删除。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如如下的配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show global variables like &amp;apos;%innodb_temp%&amp;apos;; 
+----------------------------+-----------------------+
| Variable_name              | Value                 |
+----------------------------+-----------------------+
| innodb_temp_data_file_path | ibtmp1:12M:autoextend |
+----------------------------+-----------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;create temporary table和using temporary table将共用这个临时表空间。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;临时表优化&lt;br&gt;临时表会伴随着大量的数据写入和读取，尤其是internal_tmp_table。所以，InnoDB专门对临时表进行了优化。&lt;br&gt;InnoDB使用如下两个标示临时表：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;dict_tf2_temporary： 表示普通临时表&lt;br&gt;dict_tf2_intrinsic： 表示内部临时表&lt;br&gt;这两个标示，会在IBD文件的segment header占用两个bit位。intrinsic一定是temproary，也就是temproary上进行的优化 完全适用于intrinsic表上。&lt;/p&gt;
&lt;p&gt;下面来看下具体的优化：&lt;/p&gt;
&lt;p&gt;3.1. redo&lt;br&gt;临时表在连接断开或者数据库实例关闭的时候，会进行删除，所以，临时表的数据不需要redo来保护，即recovery的过程中 不恢复临时表，只有临时表的metadata使用了redo保护，保护元数据的完整性，以便异常启动后进行清理工作。&lt;/p&gt;
&lt;p&gt;临时表的元数据，5.7之后，使用了一个独立的表进行保存，这样就不要使用redo保护，元数据也只保存在内存中。 但这有一个前提，必须使用共享的临时表空间，如果使用file-per-table，仍然需要持久化元数据，以便异常恢复清理。&lt;/p&gt;
&lt;p&gt;3.2 undo&lt;br&gt;temporary table仍然需要语句级的回滚，所以，需要为数据生成undo。但intrinsic table不需要回滚，所以，intrinsic table 减少了undo的生成，性能更高。&lt;/p&gt;
&lt;p&gt;3.3 lock&lt;br&gt;因为临时表只有本线程可以看见，所以减少了InnoDB的加锁过程。&lt;/p&gt;
&lt;p&gt;可以看下insert的时候，进行的分支判断：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; row_insert_for_mysql(
    const byte*        mysql_rec,
    row_prebuilt_t*        prebuilt)
{
    /* For intrinsic tables there a lot of restrictions that can be
    relaxed including locking of table, transaction handling, etc.
    Use direct cursor interface for inserting to intrinsic tables. */
    if (dict_table_is_intrinsic(prebuilt-&amp;gt;table)) {
        return(row_insert_for_mysql_using_cursor(mysql_rec, prebuilt));
    } else {
        return(row_insert_for_mysql_using_ins_graph(
            mysql_rec, prebuilt));
    }
}
row_insert_for_mysql_using_cursor直接跳过了加锁的lock_table过程。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后，如果是intrinsic table，就直接插入，减少了undo的生成。&lt;br&gt;如果不是，需要加lock，并生成undo信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (dict_table_is_intrinsic(index-&amp;gt;table)) {

            index-&amp;gt;rec_cache.rec_size = rec_size;

            *rec = page_cur_tuple_direct_insert(
                page_cursor, entry, index, n_ext, mtr);
        } else {
            /* Check locks and write to the undo log,
            if specified */
            err = btr_cur_ins_lock_and_undo(flags, cursor, entry,
                            thr, mtr, &amp;amp;inherit);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;插入的时候，如果是临时表。就关闭redo的生成。如下面的代码所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (dict_table_is_temporary(index-&amp;gt;table)) {
        /* Disable REDO logging as the lifetime of temp-tables is
        limited to server or connection lifetime and so REDO
        information is not needed on restart for recovery.
        Disable locking as temp-tables are local to a connection. */

        ut_ad(flags &amp;amp; BTR_NO_LOCKING_FLAG);
        ut_ad(!dict_table_is_intrinsic(index-&amp;gt;table)
              || (flags &amp;amp; BTR_NO_UNDO_LOG_FLAG));

        mtr.set_log_mode(MTR_LOG_NO_REDO);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;未完待续，下一个系列，我们将介绍一下undo的新特性，包括online truncated undo。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;系统变量&lt;br&gt;5.7以后System and status 变量需要从performance_schema中进行获取，information_schema仍然保留了GLOBAL_STATUS，GLOBAL_VARIABLES两个表做兼容。&lt;/li&gt;

    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="新特性" scheme="http://idber.github.io/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>MySQL经典模板参数详解</title>
    <link href="http://idber.github.io/2018/08/19-MySQL%E7%BB%8F%E5%85%B8%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3.html"/>
    <id>http://idber.github.io/2018/08/19-MySQL经典模板参数详解.html</id>
    <published>2018-08-18T22:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.931Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;最近两天整理的参数文件详细说明，常用的参数都涉及到了，主要适用于MySQL 5.6，参考姜承尧老师的mysql_best_configuration，时间匆忙，后续发现错误会及时更正。&lt;br&gt;&lt;a href=&quot;https://github.com/jdaaaaaavid/mysql_best_configuration&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源文件&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[mysql]
prompt=\\u@\\d \\r:\\m:\\s&amp;gt;
default_character_set=utf8 #character_set_client、character_set_connection、character_set_results这3个参数值是由客户端每次连接进来设置的，和服务器端没关系。我们登陆进mysql后，执行 set names utf8; 实际就是同时修改上面的这3个参数值的。
no_auto_rehash #启用自动补全功能，类似linux下tab补全。默认情况下，此选项处于启用状态，可以使数据库，表和列名称完成。使用 --disable-auto-rehash 禁用换汤不换药。禁用会导致mysql启动得更快，可以在连接时指定参数，例：mysql -u root --auto-rehash

[mysqld_safe]
malloc_lib=tcmalloc  #tcmalloc是Google开源的一个内存管理库， 作为glibc malloc的替代品。目前已经在chrome、safari等知名软件中运用。

[mysqldump]
single_transaction #single-transaction 选项和 lock-all-tables 选项是二选一的，前者是在导出开始时设置事务隔离状态并使用一致性快照开始事务,而后马上unlock tables，然后执行导出,导出过程不影响其它事务或业务连接，但只支持类似innodb多版本特性的引擎，因为必须保证即使导出期间其它操作(事务点t2)改变了数据，而导出时仍能取出导出开始的事务点t1时的数据。而lock-all-tables则一开始就 FLUSH TABLES WITH READ LOCK; 加全局读锁，直到dump完毕。
# -- 关于一致性快照，简单地说，就是通过回滚段能记录不同的事务点的各版本数据
# -- single-transaction 的流程如下：

[mysqld]
# basic settings #
user = mysql #mysql以什么用户运行 #-u, --user=name     Run mysqld daemon as user.
# sql_mode = &amp;quot;STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER&amp;quot;
# STRICT_TRANS_TABLES：严格模式，在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做任何限制
# NO_ZERO_IN_DATE：在严格模式，不接受月或日部分为0的日期。如果使用IGNORE选项，我们为类似的日期插入&amp;apos;0000-00-00&amp;apos;。在非严格模式，可以接受该日期，但会生成警告。
# NO_ZERO_DATE：在严格模式，不要将 &amp;apos;0000-00-00&amp;apos;做为合法日期。你仍然可以用IGNORE选项插入零日期。在非严格模式，可以接受该日期，但会生成警告
# ERROR_FOR_DIVISION_BY_ZERO：在严格模式，在INSERT或UPDATE过程中，如果被零除(或MOD(X，0))，则产生错误(否则为警告)。如果未给出该模式，被零除时MySQL返回NULL。如果用到INSERT IGNORE或UPDATE IGNORE中，MySQL生成被零除警告，但操作结果为NULL
# NO_AUTO_CREATE_USER：防止GRANT自动创建新用户，除非还指定了密码。
# NO_ENGINE_SUBSTITUTION：如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常autocommit = 1
server_id=8888 #指定服务器ID。此变量由--server-id选项设置 。在复制主服务器和每个复制从服务器上， 必须指定--server-id用于建立1到2 32到1范围内的唯一复制ID 的 选项。 “ 唯一 ”表示每个ID必须与任何正在使用的其他ID不同其他复制主机或从机。
character_set_server= utf8  #即使在配置文件里根本就没有配置character_set_database，重启mysql后character_set_database变量值也会和character_set_server保持一致，故只需要配置character_set_server就行了。如果库里有latin1，character_set_database会显示为latin1，需要把latin1的库改为utf8，character_set_database无法直接在配置文件里设置，会报错The server quit without updating PID file [FAILED]ysql/mysql/data/mysql.pid).
basedir=/home/mysql/mysql #MySQL安装基目录的路径
datadir=/home/mysql/mysql/data #MySQL服务器数据目录的路径。
transaction_isolation=READ-COMMITTED #事务隔离级别RC 如果您的查询和事务很短：请使用默认的REPEATABLE-READ模式！如果您的查询很长并且读取了很多可能被其他事务并行修改的数据：那么使用READ-COMMITTED模式 - 这将允许您在查询进行时读取已提交的更改并避免丢失而不是扫描旧页面图像（正如PeterZ在他的故事中向你展示的那样;-)）
explicit_defaults_for_timestamp = 1 #主要解决默认值为NULL的问题，应该放弃timestamp类型，此参数就不用设置了
max_allowed_packet=1073741824 #设置1G #MySQL根据配置文件会限制Server接受的数据包大小。有时候大的插入和更新会受 max_allowed_packet 参数限制，导致写入或者更新失败。
event_scheduler = 1 #全局变量event_scheduler用来设定是否服务器端运行执行计划任务，该变量有如下三种值：
# OFF：计划任务处于停止状态，event scheduler线程没有运行。是event_scheduler的默认值（执行一下任意一条命令关闭）；
# ON：计划任务处于运行状态，event scheduler线程启动，并执行所有的计划任务（执行一下任意一条命令开启）；
# DISABLED：该值将致使计划任务不可运行
lower_case_table_names=1 #0敏感1不敏感2不敏感     unix、linux下lower_case_table_names默认值为 0 .Windows下默认值是 1 .Mac OS X下默认值是 2 ,linux下不生效.
open_files_limit=65536 #操作系统允许mysqld打开的文件数 。此变量在运行时的值是系统允许的实际值，可能与您在服务器启动时指定的值不同。在MySQL无法更改打开文件数的系统上，该值为0。
default_storage_engine=INNODB

# connection #
interactive_timeout = 1800 
wait_timeout = 1800 #1. 控制连接最大空闲时长的wait_timeout参数。
# 2. 对于非交互式连接，类似于jdbc连接，wait_timeout的值继承自服务器端全局变量wait_timeout。对于交互式连接，类似于mysql客户单连接，wait_timeout的值继承自服务器端全局变量interactive_timeout。
# 3. 判断一个连接的空闲时间，可通过show processlist输出中Sleep状态的时间
lock_wait_timeout = 1800 #此变量指定尝试获取元数据锁的超时（以秒为单位）。允许值范围为1到31536000（1年）。默认值为31536000。此超时适用于使用元数据锁的所有语句。这些措施包括对表，视图DML和DDL操作，存储过程和存储功能，以及 LOCK TABLES， FLUSH TABLES WITH READ LOCK和HANDLER语句。
skip_name_resolve = 1 #此变量是从--skip-name-resolve选项的值设置的 。如果是OFF，mysqld 在检查客户端连接时解析主机名。如果是 ON，mysqld只使用IP号码; 在这种情况下，Host授权表中的所有列值必须是IP地址或 localhost。
max_connections = 4500 #允许的最大同时客户端连接数。默认情况下是151
max_user_connections = 256 #允许任何给定MySQL用户帐户的最大并发连接数。值0（默认值）表示 “ 无限制。”
max_connect_errors = 1000000 #如果来自主机的多个连续连接请求在没有成功连接的情况下中断，则服务器会阻止该主机进一步连接。您可以通过刷新主机缓存来取消阻止阻止的主机。为此，请发出FLUSH HOSTS声明或执行mysqladmin flush-hosts 命令。如果max_connect_errors 在先前连接中断后少于尝试的连接成功建立连接，则主机的错误计数将清零。但是，一旦主机被阻止，刷新主机缓存是解除阻塞的唯一方法。默认值为100。


# table cache performance settings
table_open_cache = 4096 #所有线程的打开表的数量。
table_definition_cache = 4096 #.frm可以存储在定义高速缓存中 的表定义（来自文件）的数量 。如果使用大量表，则可以创建大型表定义高速缓存以加快表的打开速度。与普通表缓存不同，表定义缓存占用的空间更少，不使用文件描述符。
table_open_cache_instances = 64 #打开表缓存实例的数量（默认为1）。为了通过减少会话之间的争用来提高可伸缩性，可以将开放表缓存划分为几个较小的大小table_open_cache/的 缓存实例 table_open_cache_instances。会话需要仅锁定一个实例以访问DML语句。这会在实例之间对高速缓存进行分段，从而在有许多会话访问表时允许使用高速缓存的操作具有更高的性能。（DDL语句仍然需要锁定整个缓存，但这些语句比DML语句要频繁得多。）对于常规使用16个或更多内核的系统，建议使用值8或16。

# session memory settings #
read_buffer_size = 16M #对于所有存储引擎，此选项也在以下上下文中使用：在为行排序时，用于缓存临时文件（不是临时表）中的索引ORDER BY。用于批量插入分区。用于缓存嵌套查询的结果。
read_rnd_buffer_size = 32M #此变量用于从MyISAM 表中读取，对于任何存储引擎，用于多范围读取优化。将变量设置为较大的值可以大大提高ORDER BY 性能。但是，这是为每个客户端分配的缓冲区，因此不应将全局变量设置为较大的值。而是仅从需要运行大型查询的客户端中更改会话变量。
sort_buffer_size = 32M #必须执行排序的每个会话都会分配此大小的缓冲区。sort_buffer_size 并非特定于任何存储引擎，并且以一般方式应用于优化。至少该 sort_buffer_size值必须足够大，以容纳排序缓冲区中的十五个元组。此外，增加价值 max_sort_length可能需要增加价值 sort_buffer_size。
tmp_table_size = 64M #内部内存临时表的最大大小。此变量不适用于用户创建的 MEMORY表。实际限制是根据tmp_table_size和 max_heap_table_size的较小值确定的 。如果内存中的临时表超出限制，MySQL会自动将其转换为磁盘上的 MyISAM表。如果您执行许多高级 查询并且内存很多tmp_table_size，max_heap_table_size则增加（以及 必要时）的值 GROUP BY。您可以将创建的内部磁盘上临时表的数量与通过比较Created_tmp_disk_tables和 Created_tmp_tables 变量的值创建的内部临时表的总数进行比较 。
join_buffer_size = 128M
thread_cache_size = 64

# log settings #
log_error=error.log #错误日志 默认保存在data目录
log_bin = binlog  #是否启用了二进制日志。如果使用该 --log-bin选项，则该变量的值为ON; 否则就是OFF。
general_log_file = general.log #通用日志文件的名称。默认值为 host_name.log，但可以使用该--general_log_file选项更改初始值 。
slow_query_log = 1  #是否启用慢查询日志。该值可以是0（或 OFF）以禁用日志，或1（或 ON）以启用日志。默认值取决于是否--slow_query_log给出了该选项。日志输出的目标由log_output系统变量控制 ; 如果该值为NONE，则即使启用了日志，也不会写入日志条目。
slow_query_log_file = slow.log #慢查询日志，默认值为 host_name-slow.log，但可以使用该--slow_query_log_file选项更改初始值 。 默认保存在data目录
log_queries_not_using_indexes = 1 #是否将不使用索引的查询记录到慢查询日志中。
log_slow_admin_statements = 1 #在写入慢查询日志的语句中包含慢速管理语句。行政陈述包括ALTER TABLE， ANALYZE TABLE， CHECK TABLE， CREATE INDEX， DROP INDEX， OPTIMIZE TABLE，和 REPAIR TABLE。
log_slow_slave_statements = 1 #启用慢速查询日志时，此变量将启用long_query_time对从服务器上执行时间超过几秒的查询的日志记录 。这个变量是在MySQL 5.6.11中添加的。请注意，即使log_slow_slave_statements已启用，也不会在主服务器的慢速日志中记录主服务器中以行格式记录的所有语句 。
log_throttle_queries_not_using_indexes = 10 #如果 log_queries_not_using_indexes 启用，则 log_throttle_queries_not_using_indexes 变量限制可以写入慢查询日志的每分钟此类查询的数量。值0（默认值）表示“ 无限制 ”。
expire_logs_days = 90 #自动二进制日志文件删除的天数。默认值为0，表示“ 不自动删除。“可能的删除发生在启动时和刷新二进制日志时。发生日志刷新，如第5.4节“MySQL服务器日志”中所示。要手动删除二进制日志文件，请使用该 PURGE BINARY LOGS语句。
long_query_time = 2 #如果查询花费的时间超过此秒数，则服务器会递增Slow_queries 状态变量。如果启用了慢查询日志，则查询将记录到慢查询日志文件中。此值是实时测量的，而不是CPU时间，因此在负载较轻的系统上低于阈值的查询可能会高于严重负载的阈值。最小值和默认值分别long_query_time为0和10。该值可以指定为微秒的分辨率。对于记录到文件，写入包括微秒部分的时间。对于记录到表，只写入整数倍; 微秒部分被忽略。
min_examined_row_limit = 100 #检查少于此行数的查询不会记录到慢查询日志中。
log_bin_trust_function_creators = 1 #启用二进制日志记录时，此变量适用。它控制是否可以信任存储的函数创建者不创建将导致不安全事件写入二进制日志的存储函数。如果设置为0（默认值），用户不允许创建或更改存储功能，除非他们有SUPER 除了特权CREATE ROUTINE或ALTER ROUTINE特权。设置为0还强制执行必须使用DETERMINISTIC特征或使用 READS SQL DATA或声明函数的限制 NO SQL特性。如果变量设置为1，则MySQL不会对存储的函数创建强制实施这些限制。此变量也适用于触发器创建。
log_slave_updates = 1 #从服务器从主服务器接收的更新是否应记录到从属服务器自己的二进制日志中。必须在从站上启用二进制日志记录才能使此变量生效。

# innodb settings #
innodb_page_size = 16384 #InnoDB页面大小（默认为16KB）。许多值都以页数计算; 页面大小使它们可以轻松转换为字节。
innodb_buffer_pool_size = 500M #在一个独立的只使用InnoDB引擎的MySQL服务器中，根据经验，推荐设置innodb-buffer-pool-size为服务器总可用内存的80%。
# 为什么不是90%或者100%呢？
# 因为其它的东西也需要内存：
# * 每个查询至少需要几K的内存(有时候是几M)
# * 有各种其它内部的MySQL结构和缓存
# * InnoDB有一些结构是不用缓冲池的内存的(字典缓存，文件系统，锁系统和页哈希表等)
# * 也有一些MySQL文件是在OS缓存里的(binary日志，relay日志,innodb事务日志等)
# * 此处，你也必须为操作系统留出些内存
innodb_buffer_pool_instances = 16 #InnoDB 缓冲池分区 的区域数。对于具有数千兆字节范围的缓冲池的系统，将缓冲池划分为单独的实例可以通过减少不同线程读取和写入缓存页面时的争用来提高并发性。存储在缓冲池中或从缓冲池读取的每个页面都使用散列函数随机分配给其中一个缓冲池实例。每个缓冲池管理自己的空闲列表， 刷新列表， LRU以及连接到缓冲池的所有其他数据结构，并受其自己的缓冲池互斥锁保护。
innodb_buffer_pool_load_at_startup = 1  #指定在MySQL服务器启动时， 通过加载较早时保存的相同页面来自动预热InnoDB 缓冲池。通常与innodb_buffer_pool_dump_at_shutdown结合使用 。 
innodb_buffer_pool_dump_at_shutdown = 1 #指定在MySQL服务器关闭时是否记录InnoDB 缓冲池中缓存的页面 ，以便在下次重新启动时缩短 预热过程。通常与innodb_buffer_pool_load_at_startup。结合使用 。
innodb_lru_scan_depth = 4096 #影响缓冲池刷新操作 的算法和启发式的参数。主要是性能专家调整I / O密集型工作负载的兴趣。它为每个缓冲池实例指定缓冲池LRU页面列表向下清除页面清理器线程扫描查找要刷新的脏页的距离。这是每秒执行一次的后台操作。 小于默认值的设置通常适用于大多数工作负载。高于必要值的值可能会影响性能。如果在典型工作负载下具有备用I / O容量，则仅考虑增加该值。相反，如果写入密集型工作负载使I / O容量饱和，请减小该值，尤其是在大型缓冲池的情况下。调整时innodb_lru_scan_depth，从较低的值开始并向上配置设置，目标是很少看到零空闲页面。此外，考虑innodb_lru_scan_depth在更改缓冲池实例的数量时进行调整，因为 innodb_lru_scan_depth* innodb_buffer_pool_instances 定义页清除程序线程每秒执行的工作量。
innodb_lock_wait_timeout = 5 #放弃之前InnoDB 事务等待行锁定的时间长度（以秒为单位）。默认值为50秒。尝试访问由另一个InnoDB事务锁定的行的 事务在发出以下错误之前最多等待这一行以便对该行进行写访问：ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction发生锁定等待超时时，将回滚当前语句 （而不是整个事务）。要使整个事务回滚，请使用该--innodb_rollback_on_timeout 选项启动服务器 
innodb_io_capacity = 200 #该innodb_io_capacity 参数设置InnoDB后台任务每秒执行的I / O操作数的上限，例如 从缓冲池刷新页面和合并来自更改缓冲区的数据 。该innodb_io_capacity限制适用于所有缓冲池实例总限额。刷新脏页时，限制在缓冲池实例之间平均分配。innodb_io_capacity应设置为大约系统每秒可执行的I / O操作数。理想情况下，保持设置尽可能低，但不要低到背景活动落后。如果该值太高，则会从缓冲池中删除数据并过快地插入缓冲区以进行缓存以提供显着的好处。默认值为200.对于具有更高I / O速率的繁忙系统，可以设置更高的值以帮助服务器处理与高速行更改相关的后台维护工作。通常，您可以根据InnoDB I / O 使用的驱动器数量增加该值。例如，您可以增加使用多个磁盘或固态磁盘（SSD）的系统的值。对于低端SSD，默认设置200通常就足够了。对于更高端的总线连接SSD，请考虑更高的设置，例如1000。对于具有单独5400 RPM或7200 RPM驱动器的系统，您可以将值降低到100，这表示可执行大约100 IOPS的旧一代磁盘驱动器可用的每秒I / O操作（IOPS）的估计比例。虽然您可以指定一个非常高的值，例如一百万，但实际上这样的大值几乎没有任何好处。通常，建议不要使用20000或更高的值，除非您已经证明较低的值不足以满足您的工作负载。
innodb_io_capacity_max = 400 #如果冲洗活动落后，InnoDB 可以比施加的限制更积极地冲洗 innodb_io_capacity。 在这种情况下innodb_io_capacity_max，InnoDB后台任务定义每秒执行的I / O操作数的上限 。该innodb_io_capacity_max 设置是所有缓冲池实例的总限制。如果innodb_io_capacity在启动时指定 设置但未指定值 innodb_io_capacity_max，则 innodb_io_capacity_max默认值为值的两倍 innodb_io_capacity，最小值为2000。配置时innodb_io_capacity_max，两倍innodb_io_capacity 往往是一个很好的起点。默认值2000适用于使用固态磁盘（SSD）或多个常规磁盘驱动器的工作负载。对于不使用SSD或多个磁盘驱动器的工作负载，2000的设置可能太高，并且可能允许过多的刷新。对于单个常规磁盘驱动器，建议设置介于200和400之间。对于高端，总线连接的SSD，请考虑更高的设置，例如2500.与 innodb_io_capacity设置一样，保持设置尽可能低，但不要太低 ，如果必要，InnoDB不能充分扩展到超出innodb_io_capacity限制。
innodb_flush_method = O_DIRECT #定义用于将 数据刷新到 InnoDB 数据文件和日志文件的方法，这可能会影响I / O吞吐量。如果innodb_flush_method设置为 NULL类Unix系统，则fsync默认使用该 选项。如果 在Windows上innodb_flush_method设置为 NULL，则async_unbuffered默认使用该 选项。innodb_flush_method类Unix系统 的选项包括：
# fsync：InnoDB使用fsync()系统调用来刷新数据和日志文件。fsync是默认设置。
# O_DSYNC：InnoDB用于 O_SYNC打开和刷新日志文件，以及fsync()刷新数据文件。 InnoDB不O_DSYNC直接使用 ，因为在很多种Unix上都存在问题。
# littlesync：此选项用于内部性能测试，目前不受支持。使用风险由您自己承担。
# nosync：此选项用于内部性能测试，目前不受支持。使用风险由您自己承担。
# O_DIRECT：InnoDB 使用O_DIRECT（或 directio()在Solaris上）打开数据文件，并用于fsync()刷新数据和日志文件。某些GNU / Linux版本，FreeBSD和Solaris上提供了此选项。
# O_DIRECT_NO_FSYNC： 在刷新I / O期间InnoDB使用O_DIRECT，但之后跳过 fsync()系统调用。此设置适用于某些类型的文件系统，但不适用于其他类型。例如，它不适合XFS。如果您不确定您使用的文件系统是否需要 fsync()（例如保留所有文件元数据），请O_DIRECT改用。
innodb_undo_logs = 128 #定义InnoDB回滚段的数量。innodb_undo_logs是innodb_rollback_segments的别名。定义 用于生成撤消记录的数据修改事务所使用的回滚段数 InnoDB。每个回滚段最多可支持1023个数据修改事务。如果您观察到与撤消日志相关的互斥争用，则此设置适用于调整性​​能。虽然您可以增加或减少使用的回滚段InnoDB数，但系统中实际存在的回滚段数不会减少。因此，您可以从此参数的低值开始并逐渐增加它，以避免分配不需要的回滚段。的 innodb_rollback_segments 默认值是128，这也是最大值。
#innodb_undo_tablespaces = 3 #回滚段表空间数量。默认值为0。由于在长时间运行的事务期间undo日志会变大，因此在多个表空间中使用撤消日志会减少任何一个表空间的最大大小。撤消表空间文件是在定义的位置创建的 innodb_undo_directory，其名称形式为 ，其中是表示空间ID的一系列整数（包括前导零）。undo表空间文件的默认大小为10MiB。 undoNN重要innodb_undo_tablespaces只能在初始化MySQL实例之前配置，之后不能更改。如果未指定任何值，则使用默认设置0初始化实例。尝试InnoDB使用比MySQL实例初始化时指定的更多数量的撤消表空间重新启动会导致启动失败并显示错误，指出InnoDB未找到预期的撤消表空间的数量。
innodb_flush_neighbors = 0 #指定是否刷从一个页面InnoDB缓冲池也可以清空其他脏页在相同的段。默认值1从缓冲池中刷新相同范围内的连续脏页。设置为0将 innodb_flush_neighbors关闭，并且不会从缓冲池中刷新其他脏页。设置为2会从缓冲池中刷新相同范围内的脏页。当表数据存储在传统 HDD存储设备上时， 与在不同时间刷新各个页面相比，在一次操作中刷新这些邻居页面减少了I / O开销（主要用于磁盘搜索操作）。对于存储在SSD上的表数据 ，查找时间不是一个重要因素，您可以关闭此设置以分散写入操作。
innodb_log_file_size = 1G #在每个字节大小日志文件在日志组。日志文件（innodb_log_file_size* innodb_log_files_in_group）的总大小不能超过略小于512GB的最大值。例如，一对255 GB的日志文件接近限制但不超过它。默认值为48MB。通常，日志文件的总大小应该足够大，以至于服务器可以消除工作负载活动中的高峰和低谷，这通常意味着有足够的重做日志空间来处理超过一小时的写入活动。值越大，缓冲池中需要的检查点刷新活动越少，从而节省磁盘I / O. 较大的日志文件也会使崩溃恢复速度变慢，但MySQL 5.5及更高版本中恢复性能的改进使得日志文件大小不再考虑。
innodb_log_files_in_group = 2 #数日志文件 中日志组。 InnoDB以循环方式写入文件。默认（和推荐）值为2.文件的位置由innodb_log_group_home_dir。指定 。日志文件（innodb_log_file_size* innodb_log_files_in_group）的总大小最大可达512GB。
innodb_log_buffer_size = 64M #InnoDB 用于写入磁盘上日志文件 的缓冲区的大小（以字节为单位）。默认值为8MB。大型 日志缓冲区使大型事务能够运行，而无需在事务提交之前将日志写入磁盘。因此，如果您有更新，插入或删除许多行的事务，则使日志缓冲区更大可以节省磁盘I / O. 
innodb_purge_threads = 4 #InnoDB专用于清除操作的后台线程数 。默认值和最小值1表示清除操作始终由后台线程执行，而不是作为主线程的一部分 。在一个或多个后台线程中运行清除操作有助于减少内部争用 InnoDB，从而提高可伸缩性。将值增加到大于1会创建许多单独的清除线程，这可以提高在多个表上执行DML操作的系统的效率 。最大值为32。
innodb_large_prefix = 1 #启用此选项以允许InnoDB使用DYNAMIC 或 COMPRESSED 行格式的表的 索引键前缀长度超过767字节（最多3072字节）。（创建此类表也需要选项值 innodb_file_format=barracuda 和 innodb_file_per_table=true。）有关与各种设置下的索引键前缀关联的最大值，
innodb_thread_concurrency = 64 #InnoDB尝试将操作系统线程的数量同时保持在 InnoDB小于或等于此变量给定的限制（InnoDB使用操作系统线程来处理用户事务）。一旦线程数达到此限制，额外的线程被置于等待状态一内“ 先入先出 ” （FIFO）队列以供执行。等待锁的线程不计入并发执行线程的数量。此变量的范围是0到1000.值0（默认值）被解释为无限并发（无并发检查）。禁用线程并发检查可以InnoDB根据需要创建任意数量的线程。值0也禁用queries inside InnoDB和queries in queue counters在ROW OPERATIONS 第SHOW ENGINE INNODB STATUS 输出。如果您的MySQL实例与其他应用程序共享CPU资源，或者您的工作负载或并发用户数正在增长，请考虑设置此变量。正确的设置取决于工作负载，计算环境以及您运行的MySQL版本。您需要测试一系列值以确定提供最佳性能的设置。innodb_thread_concurrency是一个动态变量，它允许您在实时测试系统上试验不同的设置。如果特定设置表现不佳，您可以快速设置 innodb_thread_concurrency回0。使用以下准则来帮助查找和维护适当的设置：如果工作负载的并发用户线程数小于64，请进行设置 innodb_thread_concurrency=0。如果您的工作负载一直很大或偶尔会出现峰值，请先设置 innodb_thread_concurrency=128然后将值降低到96,80,64等，直到找到提供最佳性能的线程数。例如，假设您的系统通常有40到50个用户，但是这个数字会定期增加到60,70甚至200.您会发现80个并发用户的性能稳定但开始显示高于此数字的回归。在这种情况下，您将设置 innodb_thread_concurrency=80为避免影响性能。如果您不希望InnoDB为用户线程使用超过一定数量的虚拟CPU（例如，20个虚拟CPU），请设置 innodb_thread_concurrency为此数字（或者可能更低，具体取决于性能结果）。如果您的目标是将MySQL与其他应用程序隔离，则可以考虑将该mysqld进程专门绑定 到虚拟CPU。但请注意，如果mysqld进程不是一直很忙，那么独占绑定可能会导致非最佳硬件使用 。在这种情况下，您可以绑定 mysqld 处理虚拟CPU但也允许其他应用程序使用部分或全部虚拟CPU。
innodb_print_all_deadlocks = 1 #当启用该选项，所有信息 死锁在 InnoDB用户交易被记录在 mysqld 错误日志。否则，您将使用该SHOW ENGINE INNODB STATUS命令查看有关上次死锁的信息。偶尔的 InnoDB死锁不一定是个问题，因为InnoDB立即检测到条件并自动回滚其中一个事务。如果应用程序没有适当的错误处理逻辑来检测回滚并重试其操作，则可以使用此选项来解决发生死锁的原因。大量死锁可能表明需要重构为多个表发出 DML或SELECT ... FOR UPDATE语句的事务，以便每个事务以相同的顺序访问表，从而避免死锁条件。
innodb_strict_mode = 1 #当innodb_strict_mode启用时， InnoDB将返回错误，而不是警告了一定的条件。严格模式有助于防止SQL中忽略的拼写错误和语法错误，或操作模式和SQL语句的各种组合的其他意外后果。当 innodb_strict_mode启用时， InnoDB提出了在某些情况下错误条件，而不是发出警告和处理指定的声明（也许无意的行为）。这类似于 sql_modeMySQL，它控制MySQL接受的SQL语法，并确定它是否默默地忽略错误，或验证输入语法和数据值。
innodb_sort_buffer_size = 128M #指定在创建InnoDB索引期间用于对数据进行排序的排序缓冲区的大小。指定的大小定义读入内存以进行内部排序然后写入磁盘的数据量。该过程称为“ 运行 ”。在合并阶段，读入并合并指定大小的缓冲区对。设置越大，运行和合并的次数就越少。此排序区域仅在索引创建期间用于合并排序，而不是在以后的索引维护操作期间。索引创建完成后，将释放缓冲区。
innodb_write_io_threads = 16 #用于写入操作的I / O线程数 InnoDB。默认值为4.
innodb_read_io_threads = 16 #用于读取操作的I / O线程数 InnoDB。
innodb_file_per_table = 1 #当innodb_file_per_table启用（默认），InnoDB存储数据和索引在一个单独的每个新创建的表 .ibd 文件，而不是系统表空间。删除或截断表时，将回收这些表的存储。此设置启用 InnoDB表压缩等功能 。
innodb_stats_persistent_sample_pages = 64 #估计索引列的基数和其他 统计信息时要采样 的索引页数，例如计算的列 。增加该值会提高索引统计信息的准确性，从而可以提高查询执行计划的执行过程中，在增加的I / O的费用 为表。
innodb_autoinc_lock_mode = 2 #用于生成 自动增量值的锁定模式。对于传统，连续或交错，允许值分别为0,1或2。默认设置为1（连续）。 当innodb_autoinc_lock_mode设置为2时，所有insert种类的SQL都可以立马获得锁并释放，这时的效率最高。但是会引入一个新的问题：当binlog_format为statement时，这时的复制没法保证安全，因为批量的insert，比如insert ..select..语句在这个情况下，也可以立马获取到一大批的自增id值，不必锁整个表，slave在回放这个sql时必然会产生错乱。我们做个测试验证复制不是安全的。
innodb_online_alter_log_max_size=1G #指定在表的联机DDL操作期间使用的临时日志文件大小的上限（以字节为单位）InnoDB。每个正在创建的索引或要更改的表都有一个这样的日志文件。此日志文件存储在DDL操作期间在表中插入，更新或删除的数据。临时日志文件在需要时扩展为值 innodb_sort_buffer_size，最大为指定的最大值 innodb_online_alter_log_max_size。如果临时日志文件超过了大小上限，则 ALTER TABLE操作失败，并回滚所有未提交的并发DML操作。因此，此选项的较大值允许在联机DDL操作期间发生更多DML，但在表被锁定以应用日志中的数据时，还会延长DDL操作结束时的时间段。
innodb_open_files=4096 #仅当您使用多个InnoDB 表空间时，此配置选项才有意义 。它指定MySQL一次可以保持打开的最大.ibd 文件数 。最小值为10.从MySQL 5.6.6开始，如果innodb_file_per_table未启用，则默认值为300;如果不启用， 则默认值为300 table_open_cache。在5.6.6之前，默认值为300。用于文件的文件描述符仅.ibd用于InnoDB表。它们独立于--open-files-limit服务器选项指定的那些 ，并且不影响表缓存的操作。

# replication settings #
master_info_repository = TABLE #该文件保存slave连接master的状态以及配置信息，如用户名，密码，日志执行的位置等。在5.6版本之前，都是使用master.info文件，从5.6开始，通过在my.cnf  中配置 --master-info-repository=TABLE。这些信息会被写入mysql.slave_master_info 表中，代替原来的master.info文件了。
relay_log_info_repository = TABLE #该文件保存slave上relay log的执行位置。在5.6版本之前，都是使用relay-log.info文件，从5.6开始，通过在my.cnf中配置 --relay-log-info-repository=TABLE，使用mysql.slave_relay_log_info表代替原来的文件。每次当slave上执行start slave时，就会读取该表中的位置信息。
sync_binlog = 1 #sync_binlog参数来控制数据库的binlog刷到磁盘上去。最安全的就是sync_binlog=1了，表示每次事务提交，MySQL都会把binlog刷下去，是最安全但是性能损耗最大的设置。
gtid_mode = on #开启GTID复制
enforce_gtid_consistency = 1 #保证GTID安全的参数
log_slave_updates  #relay-log里的日志内容再记录到slave本地的binlog里
binlog_format = ROW #此变量设置二进制日志格式，并且可以是任何一个STATEMENT，ROW或MIXED。
binlog_rows_query_log_events = 1 #可以在binlog_format=row中记录执行的具体SQL语句。
relay_log = relay.log #开启中继日志
relay_log_recovery = 1 #当slave从库宕机后，假如relay-log损坏了，导致一部分中继日志没有处理，则自动放弃所有未执行的relay-log，并且重新从master上获取日志，这样就保证了relay-log的完整性。默认情况下该功能是关闭的，将relay_log_recovery的值设置为1时，可在slave从库上开启该功能，建议开启。
slave_skip_errors = ddl_exist_errors #复制经常会遇到错误而导致slave端复制中断，这个时候一般就需要人工干预，跳过错误才能继续 ddl_exist_errors值却比较特别，它代表了一组errorCode的组合，分别是：
# 1007：数据库已存在，创建数据库失败
# 1008：数据库不存在，删除数据库失败
# 1050：数据表已存在，创建数据表失败
# 1050：数据表不存在，删除数据表失败
# 1054：字段不存在，或程序文件跟数据库有冲突
# 1060：字段重复，导致无法插入
# 1061：重复键名
# 1068：定义了多个主键
# 1094：位置线程ID
# 1146：数据表缺失，请恢复数据库
slave_rows_search_algorithms = &amp;apos;INDEX_SCAN,HASH_SCAN&amp;apos; #部分解决无主键表导致的复制延迟问题，其基本思路是对于在一个ROWS EVENT中的所有前镜像收集起来，然后在一次扫描全表时，判断HASH中的每一条记录进行更新。
skip_slave_start=0 #auto_start_slave
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;最近两天整理的参数文件详细说明，常用的参数都涉及到了，主要适用于MySQL 5.6，参考姜承尧老师的mysql_best_configuration，时间匆忙，后续发现错误会及时更正。&lt;br&gt;&lt;a href=&quot;https://github.com/jdaaaaaa
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="性能" scheme="http://idber.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>【译】MySQL 5.7中InnoDB事务隔离模式的影响</title>
    <link href="http://idber.github.io/2018/08/18-MySQL%205.7%E4%B8%ADInnoDB%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BD%B1%E5%93%8D.html"/>
    <id>http://idber.github.io/2018/08/18-MySQL 5.7中InnoDB事务隔离模式的影响.html</id>
    <published>2018-08-17T22:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.928Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;http://dimitrik.free.fr/blog/archives/2015/02/mysql-performance-impact-of-innodb-transaction-isolation-modes-in-mysql-57.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;via&lt;/a&gt;&lt;br&gt;过去几年，其他人已经写了很多有价值的文章，解释了InnoDB事务隔离级别的所有细节以及如何解决这个问题。因此，我将避免重复已经说过的内容; 我的注意力吸引了PeterZ的性能研究并发表在以下文章中：&lt;a href=&quot;https://www.percona.com/blog/2015/01/14/mysql-performance-implications-of-innodb-isolation-modes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.percona.com/blog/2015/01/14/mysql-performance-implications-of-innodb-isolation-modes/&lt;/a&gt; 这篇文章非常好，可以很好地分析观察问题所在，可以通过修改隔离级别为READ-COMMITTED替代REPEATABLE-READ（InnoDB默认级别）来解决。那么问题来了：为什么我们没有默认的READ-COMMITTED模式？有什么危险吗？&lt;/p&gt;
&lt;p&gt;让我们一起探讨&lt;/p&gt;
&lt;p&gt;首先，你应该记住你的理论，不仅仅是在InnoDB中实现所有这些东西的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB中的事务隔离/ MVCC是通过ReadViews实现的&lt;/li&gt;
&lt;li&gt;每次创建ReadView时，都应该获取互斥锁（trx_sys）&lt;/li&gt;
&lt;li&gt;在REPEATABLE-READ模式下，在事务启动时创建ReadView&lt;/li&gt;
&lt;li&gt;在READ-COMMITTED模式下，在每个语句上创建一个ReadView&lt;/li&gt;
&lt;li&gt;意味着，如果您的陈述很短 - 您可能会在工作负载中遇到trx_sys互斥争用风暴。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，一切都取决于工作量，如果你很幸运，你可能会在这里看到一个好处（一切皆有可能，对吧？ - 至少在理论上）&lt;/p&gt;
&lt;p&gt;现在让我告诉你一些你会觉得自己不那么幸运的情况&lt;/p&gt;
&lt;p&gt;对于我的测试用例，我将使用：&lt;/p&gt;
&lt;p&gt;40cores-HT服务器&lt;br&gt;运行OEL 6.5 2.6.32-504内核&lt;br&gt;极快的闪存（Fusion-io ioMemory）&lt;br&gt;每个工作负载使用64个并发用户&lt;br&gt;每个工作负载执行3个测试用例：&lt;br&gt;配置REPEATABLE-READ模式（RR）&lt;br&gt;READ-COMMITTED模式已配置（RC）&lt;br&gt;已配置READ-UNCOMMITTED模式（RU）&lt;/p&gt;
&lt;p&gt;DBT-2 500W工作负载（TPC-C）：&lt;br&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/01Impact%20of%20InnoDB%20Transaction%20Isolation%20Modes%20in%20MySQL%205.7.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;观察 ：&lt;br&gt;你可能已经观察到，与第一个（RR）相比，第二（RC）和第三（RU）测试案例的TPS略低一些&lt;br&gt;“回归”不是很大，但值得注意&lt;br&gt;现在让我们来看看InnoDB中的内部锁定争用。&lt;br&gt;锁定争议：&lt;br&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/02Impact%20of%20InnoDB%20Transaction%20Isolation%20Modes%20in%20MySQL%205.7.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;观察 ：&lt;br&gt;对于RC和RU测试，trx_sys互斥锁的跳跃争用非常明显&lt;br&gt;然而，它还不是太大，不会造成严重的损害..&lt;/p&gt;
&lt;p&gt;现在，让我们转移到一个沉重的Sysbench OLTP_RW - 我在这里通过在我的测试中添加读/写比率稍微改变了“经典”OLTP_RW：&lt;br&gt;最初负载以128：1的比率开始（主要是读取，少写入）&lt;br&gt;那么16：1&lt;br&gt;那么4：1&lt;br&gt;那么2：1&lt;br&gt;最后1：1&lt;/p&gt;
&lt;p&gt;我也在使用这个测试用例来评估写入在事务中的影响等。&lt;/p&gt;
&lt;p&gt;到目前为止：&lt;/p&gt;
&lt;p&gt;Sysbench OLTP_RW 32x10M-tables，rw128 / 16/4/2/1：&lt;br&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/03Impact%20of%20InnoDB%20Transaction%20Isolation%20Modes%20in%20MySQL%205.7.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;观察 ：&lt;br&gt;这里的影响更多只是值得注意的;-)&lt;br&gt;这只是因为trx_sys互斥争用？或者是其他东西？..&lt;br&gt;锁定争议：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/04Impact%20of%20InnoDB%20Transaction%20Isolation%20Modes%20in%20MySQL%205.7.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;观察 ：&lt;br&gt;哦，确实，trx_sys现在跳得太高了！&lt;br&gt;它会更糟糕吗？&lt;/p&gt;
&lt;p&gt;让我们看看;-) &lt;/p&gt;
&lt;p&gt;下一个工作负载的代码名称是“OLTP_RW-p_sel10” - 这个测试中的所有读取都被10个点选择所取代，这就是全部，使得写入时的负载更加激进，读取时更快和更快：&lt;/p&gt;
&lt;p&gt;Sysbench OLTP_RW-p_sel10 32x10M表，rw128 / 16/4/2/1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/05Impact%20of%20InnoDB%20Transaction%20Isolation%20Modes%20in%20MySQL%205.7.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;观察 ：&lt;br&gt;事实上，看到x2时间更糟糕的表现真的是杀人..&lt;br&gt;仍然由于trx_sys互斥？&lt;br&gt;锁定争论：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/06Impact%20of%20InnoDB%20Transaction%20Isolation%20Modes%20in%20MySQL%205.7.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;嗯，你可能仍然会说这只是因为这个服务器太大了，这就是我观察所有这些争论的原因，你将离现实不远 - 在较小的机器上所有这些争论当然都会降​​低 - 但是！仍然“值得注意”;-)）&lt;/p&gt;
&lt;p&gt;相同的OLTP_RW-p_sel10，但在20cores-HT上:(&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/07Impact%20of%20InnoDB%20Transaction%20Isolation%20Modes%20in%20MySQL%205.7.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;虽然今天许多x2 CPU Intel机器总共拥有超过32个-cx-HT，所以“小”HW变得很大; - ））&lt;/p&gt;
&lt;p&gt;总结：&lt;br&gt;那么，我们最终应该从所有这些东西中得出结论?&lt;br&gt;PeterZ告诉我们一个如此美好的故事，现在你带着你的实验来表明PeterZ错了……&lt;br&gt;伙计们，PeterZ没错！&lt;br&gt;?? - 所以，你在撒谎??????&lt;br&gt;而且我也不是在撒谎;-)）&lt;br&gt;??? …..&lt;br&gt;那么，你应该记住的是，没有“银弹”，大多数情况下最普遍的答案将是“它取决于” ;&lt;br&gt;与InnoDB交易隔离在这里是一样的故事！&lt;br&gt;一般规则如下：&lt;br&gt;如果您的查询和事务很短：请使用默认的REPEATABLE-READ模式！&lt;br&gt;如果您的查询很长并且读取了很多可能被其他事务并行修改的数据：那么使用READ-COMMITTED模式 - 这将允许您在查询进行时读取已提交的更改并避免丢失而不是扫描旧页面图像（正如PeterZ在他的故事中向你展示的那样;-)）&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;http://dimitrik.free.fr/blog/archives/2015/02/mysql-performance-impact-of-innodb-transaction-isolation-modes-in-mysql-57.ht
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="性能" scheme="http://idber.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 5.7新特性系列一</title>
    <link href="http://idber.github.io/2018/08/17-MySQL%205.7%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%E4%B8%80.html"/>
    <id>http://idber.github.io/2018/08/17-MySQL 5.7新特性系列一.html</id>
    <published>2018-08-16T22:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.929Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h1&gt;&lt;p&gt;MySQL 5.7在2015-10-21发布了GA版本，即5.7.9，目前小版本已经到了5.7.23。5.7新增了许多新的feature和优化，接下来一个系列，我们就一起来尝尝鲜。首先这次主要是预览feature的变化以及兼容性问题。后面的系列，会针对重要的feature展开来学习。&lt;/p&gt;
&lt;h1 id=&quot;2-安全相关的特性&quot;&gt;&lt;a href=&quot;#2-安全相关的特性&quot; class=&quot;headerlink&quot; title=&quot;2 安全相关的特性&quot;&gt;&lt;/a&gt;2 安全相关的特性&lt;/h1&gt;&lt;h2 id=&quot;2-1-认证插件&quot;&gt;&lt;a href=&quot;#2-1-认证插件&quot; class=&quot;headerlink&quot; title=&quot;2.1 认证插件&quot;&gt;&lt;/a&gt;2.1 认证插件&lt;/h2&gt;&lt;p&gt;mysql.user表中的plugin更改成not null，5.7开始不再支持mysql_old_password的认证插件，推荐全部使用mysql_native_password。从低版本升级到5.7的时候，需要处理两个兼容性问题。&lt;/p&gt;
&lt;p&gt;[兼容性] 需要先迁移mysql_old_password的用户，然后进行user表结构的升级：&lt;/p&gt;
&lt;h3 id=&quot;1-迁移mysql-old-password用户&quot;&gt;&lt;a href=&quot;#1-迁移mysql-old-password用户&quot; class=&quot;headerlink&quot; title=&quot;1. 迁移mysql_old_password用户&quot;&gt;&lt;/a&gt;1. 迁移mysql_old_password用户&lt;/h3&gt;&lt;p&gt; MySQL 5.7.2之前的版本，是根据password的hash value来判断使用的认证插件类型，5.7.2以后的版本，plugin字段为not null，就直接根据plugin来判断了。新的密码从password字段中，保存到新的字段authentication_string中，password字段废弃处理。&lt;/p&gt;
&lt;p&gt;如果user是隐式的mysql_native_password。直接使用sql进行变更：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE mysql.user SET plugin = &amp;apos;mysql_native_password&amp;apos; WHERE plugin = &amp;apos;&amp;apos; AND (Password = &amp;apos;&amp;apos; OR LENGTH(Password) = 41);
FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果user是隐式的或者显示的mysql_old_password， 首先通过以下sql进行查询：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT User, Host, Password FROM mysql.user WHERE (plugin = &amp;apos;&amp;apos; AND LENGTH(Password) = 16) OR plugin = &amp;apos;mysql_old_password&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果存在记录，就表示还有使用mysql_old_password的user，使用以下sql进行用户的迁移：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER USER &amp;apos;user1&amp;apos;@&amp;apos;localhost&amp;apos; IDENTIFIED WITH mysql_native_password BY &amp;apos;DBA-chosen-password&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-user表结构升级&quot;&gt;&lt;a href=&quot;#2-user表结构升级&quot; class=&quot;headerlink&quot; title=&quot;2. user表结构升级&quot;&gt;&lt;/a&gt;2. user表结构升级&lt;/h3&gt;&lt;p&gt;通过mysql_upgrade直接进行升级，步骤如下[5.6-&amp;gt;5.7]：&lt;/p&gt;
&lt;p&gt;stop MySQL 5.6实例&lt;br&gt;替换5.7的mysqld二进制版本&lt;br&gt;使用5.7启动实例&lt;br&gt;run mysql_upgrade升级系统表&lt;br&gt;重启MySQL 5.7实例&lt;/p&gt;
&lt;h2 id=&quot;2-2-密码过期&quot;&gt;&lt;a href=&quot;#2-2-密码过期&quot; class=&quot;headerlink&quot; title=&quot;2.2 密码过期&quot;&gt;&lt;/a&gt;2.2 密码过期&lt;/h2&gt;&lt;p&gt;用户可以通过 ALTER USER ‘test‘@’localhost’ PASSWORD EXPIRE;这样的语句来使用户的密码过期。 并新增加 default_password_lifetime来表示用户密码自动过期时间，从5.7.10开始，其默认值从0变更到了360，也就是默认一年过期。 可以通过以下两种方法禁止过期：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. SET GLOBAL default_password_lifetime = 0;
2. ALTER USER &amp;apos;test&amp;apos;@&amp;apos;localhost&amp;apos; PASSWORD EXPIRE NEVER;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[兼容性] 只需要通过mysql_upgrade升级mysql.user系统表就可以使用密码过期新功能。&lt;/p&gt;
&lt;h2 id=&quot;2-3-账号锁定&quot;&gt;&lt;a href=&quot;#2-3-账号锁定&quot; class=&quot;headerlink&quot; title=&quot;2.3 账号锁定&quot;&gt;&lt;/a&gt;2.3 账号锁定&lt;/h2&gt;&lt;p&gt;用户可以通过以下语法进行账号锁定，阻止这个用户进行登录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER USER &amp;apos;test&amp;apos;@&amp;apos;localhost&amp;apos; ACCOUNT LOCK;
ALTER USER &amp;apos;test&amp;apos;@&amp;apos;localhost&amp;apos; ACCOUNT UNLOCK;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[兼容性] 只需要通过mysql_upgrade升级mysql.user系统表就可以使用密码过期新功能。&lt;/p&gt;
&lt;h2 id=&quot;2-4-SSL连接&quot;&gt;&lt;a href=&quot;#2-4-SSL连接&quot; class=&quot;headerlink&quot; title=&quot;2.4 SSL连接&quot;&gt;&lt;/a&gt;2.4 SSL连接&lt;/h2&gt;&lt;p&gt;如果mysqld编译使用的openssl，在启动的时候，默认创建SSL， RSA certificate 和 key 文件。 但不管是openssl还是yassl，如果没有设置ssl相关的参数，mysqld都会在data directory里查找ssl认证文件，来尽量打开ssl特性。&lt;/p&gt;
&lt;p&gt;[兼容性] 不存在兼容性的问题&lt;/p&gt;
&lt;h2 id=&quot;2-5-安装数据库&quot;&gt;&lt;a href=&quot;#2-5-安装数据库&quot; class=&quot;headerlink&quot; title=&quot;2.5 安装数据库&quot;&gt;&lt;/a&gt;2.5 安装数据库&lt;/h2&gt;&lt;p&gt;5.7开始建议用户使用 mysqld –initialize来初始化数据库，放弃之前的mysql_install_db的方式，新的方式只创建了一个root@localhost的用户，随机密码保存在~/.mysql_secret文件中，并且账号是expired，第一次使用必须reset password，并且不再创建test db。&lt;/p&gt;
&lt;p&gt;[兼容性] 不存在兼容性的问题&lt;/p&gt;
&lt;h1 id=&quot;3-sql-mode变更&quot;&gt;&lt;a href=&quot;#3-sql-mode变更&quot; class=&quot;headerlink&quot; title=&quot;3 sql mode变更&quot;&gt;&lt;/a&gt;3 sql mode变更&lt;/h1&gt;&lt;p&gt;5.7 sql_mode的默认值变更为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mode_no_engine_substitution |
mode_only_full_group_by |
mode_strict_trans_tables |
mode_no_zero_in_date |
mode_no_zero_date |
mode_error_for_division_by_zero |
mode_no_auto_create_user
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而在5.7之前，sql_mode的默认值都只有mode_no_engine_substitution。 所以在5.7默认的情况下，比如grant不存在的用户的时候，会报一下错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ERROR 1133 (42000): Can&amp;apos;t find any matching row in the user table
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;必须先使用create user，然后再使用grant user。&lt;/p&gt;
&lt;p&gt;[兼容性] 默认sql mode发生变更会导致sql的行为不一致。&lt;/p&gt;
&lt;h1 id=&quot;4-online-alter-table&quot;&gt;&lt;a href=&quot;#4-online-alter-table&quot; class=&quot;headerlink&quot; title=&quot;4. online alter table&quot;&gt;&lt;/a&gt;4. online alter table&lt;/h1&gt;&lt;p&gt;支持online rename index操作， in_place并且不需要table copy。 [兼容性] 不存在兼容性的问题&lt;/p&gt;
&lt;h1 id=&quot;5-InnoDB增强&quot;&gt;&lt;a href=&quot;#5-InnoDB增强&quot; class=&quot;headerlink&quot; title=&quot;5. InnoDB增强&quot;&gt;&lt;/a&gt;5. InnoDB增强&lt;/h1&gt;&lt;h3 id=&quot;5-1-varchar长度变更支持inplace&quot;&gt;&lt;a href=&quot;#5-1-varchar长度变更支持inplace&quot; class=&quot;headerlink&quot; title=&quot;5.1 varchar长度变更支持inplace&quot;&gt;&lt;/a&gt;5.1 varchar长度变更支持inplace&lt;/h3&gt;&lt;p&gt;变更varchar 类型字段的长度支持inplace方法，但有一个限制，即用于表示varchar字段长度的字节数不能发生变化，也就是支持比如varchar的长度在255以下变更或者255以上的范围进行变更，因为从小于255变更到大于255，其size的字节需要从1个增加到2个。&lt;/p&gt;
&lt;p&gt;注意：减少varchar的长度，仍然需要table copy。&lt;/p&gt;
&lt;h3 id=&quot;5-2-优化InnoDB临时表&quot;&gt;&lt;a href=&quot;#5-2-优化InnoDB临时表&quot; class=&quot;headerlink&quot; title=&quot;5.2 优化InnoDB临时表&quot;&gt;&lt;/a&gt;5.2 优化InnoDB临时表&lt;/h3&gt;&lt;p&gt;因为InnoDB临时表的数据不再不受redo保护，而redo只保护临时表的元数据，所以大幅提升了临时表的性能。 并且InnoDB临时表的元数据保存在一个新的系统表中即innodb_temp_table_info， 临时表将建立一个统一的表空间，我们称之为临时表空间，其目录地址可以通过参数innodb_temp_data_file_path来设置。系统在启动的时候，都会新建这个表空间，重启会删除重建。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show global variables like &amp;apos;%temp_data_file_path%&amp;apos;;
+----------------------------+-----------------------+
| Variable_name              | Value                 |
+----------------------------+-----------------------+
| innodb_temp_data_file_path | ibtmp1:12M:autoextend |
+----------------------------+-----------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并且5.7存储引擎默认都变更成InnoDB了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show global variables like &amp;apos;%storage_engine%&amp;apos;;
+----------------------------------+--------+
| Variable_name                    | Value  |
+----------------------------------+--------+
| default_storage_engine           | InnoDB |
| default_tmp_storage_engine       | InnoDB |
| disabled_storage_engines         |        |
| internal_tmp_disk_storage_engine | InnoDB |
+----------------------------------+--------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意： 在开启gtid的情况下，非auto commit或者显示begin的context下，create 或者drop 临时表，仍然和5.6一样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ERROR 1787 (HY000): Statement violates GTID consistency: CREATE TEMPORARY TABLE and DROP TEMPORARY TABLE can only be executed outside transactional context.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外， insert into t select * from t也会遇到错误，不能在一个sql语句中reference两次临时表。&lt;/p&gt;
&lt;p&gt;备注： 因为InnoDB临时表进行了比较大的变动，我们会专门进行一次详细的介绍。&lt;/p&gt;
&lt;h3 id=&quot;5-3-InnoDB原生支持DATA-GEOMETRY类型&quot;&gt;&lt;a href=&quot;#5-3-InnoDB原生支持DATA-GEOMETRY类型&quot; class=&quot;headerlink&quot; title=&quot;5.3 InnoDB原生支持DATA_GEOMETRY类型&quot;&gt;&lt;/a&gt;5.3 InnoDB原生支持DATA_GEOMETRY类型&lt;/h3&gt;&lt;p&gt;并且支持在spatial data types上建立index，加速查询。&lt;/p&gt;
&lt;h3 id=&quot;5-4-buffer-pool-dump&quot;&gt;&lt;a href=&quot;#5-4-buffer-pool-dump&quot; class=&quot;headerlink&quot; title=&quot;5.4 buffer pool dump&quot;&gt;&lt;/a&gt;5.4 buffer pool dump&lt;/h3&gt;&lt;p&gt;buffer pool dump和load支持一个新的参数innodb_buffer_pool_dump_pct，即dump的比例，并且使用innodb_io_capacity 来控制load过程中的IO吞吐量。&lt;/p&gt;
&lt;h3 id=&quot;5-5-多线程flush-dirty&quot;&gt;&lt;a href=&quot;#5-5-多线程flush-dirty&quot; class=&quot;headerlink&quot; title=&quot;5.5 多线程flush dirty&quot;&gt;&lt;/a&gt;5.5 多线程flush dirty&lt;/h3&gt;&lt;p&gt;从5.7.4开始，innodb_page_cleaners参数可以设置，支持多线程flush dirty page，加快脏块的刷新。&lt;/p&gt;
&lt;h3 id=&quot;5-6-NVM-file-system&quot;&gt;&lt;a href=&quot;#5-6-NVM-file-system&quot; class=&quot;headerlink&quot; title=&quot;5.6 NVM file system&quot;&gt;&lt;/a&gt;5.6 NVM file system&lt;/h3&gt;&lt;p&gt;MySQL 一直使用double write buffer来解决一个page写入的partial write问题，但在linux系统上的Fusion-io Non-Volatile Memory (NVM) file system支持原子的写入。 这样就可以省略掉double write buffer的使用， 5.7.4以后，如果Fusion-io devices支持atomic write，那么MySQL自动把dirty block直接写入到数据文件了。这样减少了一次内存copy和IO操作。&lt;/p&gt;
&lt;h3 id=&quot;5-7-InnoDB分区表&quot;&gt;&lt;a href=&quot;#5-7-InnoDB分区表&quot; class=&quot;headerlink&quot; title=&quot;5.7 InnoDB分区表&quot;&gt;&lt;/a&gt;5.7 InnoDB分区表&lt;/h3&gt;&lt;p&gt;MySQL 5.7之前的版本，InnoDB并不支持分区表，分区表的支持是在ha_partition引擎上支持的，从5.7开始，InnoDB支持原生的分区表，并且可以使用传输表空间。&lt;/p&gt;
&lt;p&gt;[兼容性] mysql_upgrade会扫描ha_partition引擎支持的InnoDB表，并升级成InnoDB分区表，5.7.9之后，可以通过命令ALTER TABLE … UPGRADE PARTITIONING.进行升级。如果之前的版本大量使用了分区表，要注意使用mysql_upgrade会消耗非常长的时间来升级分区表。&lt;/p&gt;
&lt;h3 id=&quot;5-8-动态调整buffer-pool-size&quot;&gt;&lt;a href=&quot;#5-8-动态调整buffer-pool-size&quot; class=&quot;headerlink&quot; title=&quot;5.8 动态调整buffer pool size&quot;&gt;&lt;/a&gt;5.8 动态调整buffer pool size&lt;/h3&gt;&lt;p&gt;MySQL 5.7.5之后，可以online动态调整buffer pool size，通过设置动态的参数innodb_buffer_pool_size来调整，并且根据Innodb_buffer_pool_resize_status状态来查看resize的进度，因为resize的过程是以chunk为大小，把pages从一个内存区域copy到另一片内存的。&lt;/p&gt;
&lt;h3 id=&quot;5-9-加快recovery&quot;&gt;&lt;a href=&quot;#5-9-加快recovery&quot; class=&quot;headerlink&quot; title=&quot;5.9 加快recovery&quot;&gt;&lt;/a&gt;5.9 加快recovery&lt;/h3&gt;&lt;p&gt;MySQL 5.7.5之前，在recovery的过程中，需要扫描所有的ibd文件，获取元信息， 5.7.5之后，新加了一种redo log类型，即MLOG_FILE_NAME， 记录从上一次checkpoint以来，发生过变更的文件，这样在recovery的过程中，只需要打开这些文件就可以了。 [兼容性] 因为增加了新的log record type，需要安全的关闭5.7之前的实例，清理掉redo。&lt;/p&gt;
&lt;h3 id=&quot;5-10-表空间管理&quot;&gt;&lt;a href=&quot;#5-10-表空间管理&quot; class=&quot;headerlink&quot; title=&quot;5.10 表空间管理&quot;&gt;&lt;/a&gt;5.10 表空间管理&lt;/h3&gt;&lt;p&gt;支持创建表空间，例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLESPACE `tablespace_name`
ADD DATAFILE &amp;apos;file_name.ibd&amp;apos;
[FILE_BLOCK_SIZE = n]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并可以在创建表的时候，指定属于哪个表空间，&lt;/p&gt;
&lt;p&gt;[兼容性] 因为可以任意指定空间目录，要注意升级过程中，不要漏掉目录。&lt;/p&gt;
&lt;h3 id=&quot;5-11-InnoDB-Tablespace-Encryption&quot;&gt;&lt;a href=&quot;#5-11-InnoDB-Tablespace-Encryption&quot; class=&quot;headerlink&quot; title=&quot;5.11 InnoDB Tablespace Encryption&quot;&gt;&lt;/a&gt;5.11 InnoDB Tablespace Encryption&lt;/h3&gt;&lt;p&gt;支持InnoDB数据文件加密，其依赖keyring plugin来进行秘钥的管理，后面我们单独来介绍InnoDB加密的方法，并且RDS也实现了一种InnoDB数据文件透明加密方法，并通过KMS系统来管理秘钥。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table t(id int) encryption=&amp;apos;y&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;未完待续&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h1&gt;&lt;p&gt;MySQL 5.7在2015-10-21发布了GA版本，即5.7.9，目前小版本已经到了5.7.23。5.7新
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="新特性" scheme="http://idber.github.io/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>RC or RR</title>
    <link href="http://idber.github.io/2018/08/16-RC%20or%20RR.html"/>
    <id>http://idber.github.io/2018/08/16-RC or RR.html</id>
    <published>2018-08-16T02:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.933Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;数据库事务隔离级别分为四种（级别递减）：&lt;/p&gt;
&lt;p&gt;1、Serializable （串行化）：最严格的级别，事务串行执行，资源消耗最大；&lt;/p&gt;
&lt;p&gt;2、REPEATABLE READ（重复读） ：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但不能避免“幻读”(MySQL通过Next-Key lock算法解决了幻读问题)，但是带来了更多的性能损失。&lt;/p&gt;
&lt;p&gt;3、READ COMMITTED （提交读）：大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”，但不能避免“幻读”和“不可重复读取”。该级别适用于大多数系统。&lt;/p&gt;
&lt;p&gt;4、Read Uncommitted（未提交读） ：事务中的修改，即使没有提交，其他事务也可以看得到，会导致“脏读”、“幻读”和“不可重复读取”。&lt;/p&gt;
&lt;p&gt;脏读、不可重复读、幻读：&lt;/p&gt;
&lt;p&gt;也许有很多读者会对上述隔离级别中提及到的 脏读、不可重复读、幻读 的理解有点吃力，我在这里尝试使用通俗的方式来解释这三种语义：&lt;/p&gt;
&lt;p&gt;脏读：所谓的脏读，其实就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。&lt;/p&gt;
&lt;p&gt;也就是说，当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。&lt;/p&gt;
&lt;p&gt;不可重复读：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。&lt;/p&gt;
&lt;p&gt;也就是说，当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。&lt;/p&gt;
&lt;p&gt;幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。&lt;/p&gt;
&lt;p&gt;也就是说，当前事务读第一次取到的数据比后来读取到数据条目少。&lt;/p&gt;
&lt;p&gt;不可重复读和幻读比较：&lt;/p&gt;
&lt;p&gt;两者有些相似，但是前者针对的是update或delete，后者针对的insert。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、隔离级别&quot;&gt;&lt;a href=&quot;#一、隔离级别&quot; class=&quot;headerlink&quot; title=&quot;一、隔离级别&quot;&gt;&lt;/a&gt;一、隔离级别&lt;/h1&gt;&lt;p&gt;事务的隔离级别有4种: SQL-1992 ，但是我只想介绍其中两种，因为其他的两个根本就用不上&lt;/p&gt;
&lt;h4 id=&quot;1-1-什么叫一致性锁定读-和-一致性非锁定读&quot;&gt;&lt;a href=&quot;#1-1-什么叫一致性锁定读-和-一致性非锁定读&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么叫一致性锁定读 和 一致性非锁定读&quot;&gt;&lt;/a&gt;1.1 什么叫一致性锁定读 和 一致性非锁定读&lt;/h4&gt;&lt;h5 id=&quot;一致性锁定读&quot;&gt;&lt;a href=&quot;#一致性锁定读&quot; class=&quot;headerlink&quot; title=&quot;一致性锁定读&quot;&gt;&lt;/a&gt;一致性锁定读&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;读数据的时候，会去加S-lock、x-lock&lt;/li&gt;
&lt;li&gt;eg：select … for update , select … lock in share mode&lt;/li&gt;
&lt;li&gt;dml语句&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&quot;一致性非锁定读&quot;&gt;&lt;a href=&quot;#一致性非锁定读&quot; class=&quot;headerlink&quot; title=&quot;一致性非锁定读&quot;&gt;&lt;/a&gt;一致性非锁定读&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;读数据的时候，不加任何的锁，快照读（snapshot read）    &lt;/li&gt;
&lt;li&gt;eg: select … 最普通的查询语句&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;1-2-什么是幻读&quot;&gt;&lt;a href=&quot;#1-2-什么是幻读&quot; class=&quot;headerlink&quot; title=&quot;1.2 什么是幻读&quot;&gt;&lt;/a&gt;1.2 什么是幻读&lt;/h4&gt;&lt;p&gt;概念&lt;br&gt;一个事务内的同一条【一致性锁定读】SQL多次执行，读到的结果不一致，我们称之为幻读。&lt;br&gt;实战&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set global tx_isolation=&amp;apos;READ-COMMITTED&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事务一: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root:test&amp;gt; begin;select * from lc for update;
+------+
| id   |
+------+
|    1 |
|    2 |
+------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事务二：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root:test&amp;gt;begin; insert into lc values(3);
Query OK, 1 row affected (0.00 sec)
root:test&amp;gt; commit ;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事务一：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root:test&amp;gt; select * from lc for update;  
+------+
| id   |
+------+
|    1 |
|    2 |
|    3 |
+------+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;同一个事务一中，同一条select * from lc for update (一致性锁定读) 执行两次，得到的结果不一致，说明产生了幻读&lt;/li&gt;
&lt;li&gt;同一个事务一中，同一条select * from lc  (一致性非锁定读) 执行两次，得到的结果不一致，说明产生了幻读&lt;/li&gt;
&lt;li&gt;我们姑且认为，幻读和不可重复读为一个概念，实际上也差不多一个概念。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;1-3-什么是脏读&quot;&gt;&lt;a href=&quot;#1-3-什么是脏读&quot; class=&quot;headerlink&quot; title=&quot;1.3 什么是脏读&quot;&gt;&lt;/a&gt;1.3 什么是脏读&lt;/h4&gt;&lt;p&gt;这个大家都很多好理解，就是事务一还没有提交的事务，却被事务二读到了，这就是脏读&lt;/p&gt;
&lt;p&gt;repeatable-read（RR）可重复读&lt;br&gt;顾名思义：一个事务内的同一条【一致性锁定读】SQL多次执行，读到的结果一致，我们称之为可重复读。&lt;br&gt;解决了幻读的问题&lt;br&gt;read-committed （RC）读已提交&lt;br&gt;顾名思义: 只要其他事务提交了，我就能读到&lt;br&gt;解决了脏读的问题，没有解决幻读的问题&lt;/p&gt;
&lt;h1 id=&quot;二、隔离级别是如何实现的&quot;&gt;&lt;a href=&quot;#二、隔离级别是如何实现的&quot; class=&quot;headerlink&quot; title=&quot;二、隔离级别是如何实现的&quot;&gt;&lt;/a&gt;二、隔离级别是如何实现的&lt;/h1&gt;&lt;p&gt;就拿上面那个简单的例子来佐证好了&lt;/p&gt;
&lt;p&gt;环境&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dba:lc_4&amp;gt; show create table lc;
+-------+--------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                           |
+-------+--------------------------------------------------------------------------------------------------------+
| lc    | CREATE TABLE `lc` (
  `id` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 |
+-------+--------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
dba:lc_4&amp;gt; select * from lc;
+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
+----+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RR&lt;/p&gt;
&lt;p&gt;RR 如何解决幻读问题？&lt;br&gt;RR 的锁算法：next-key lock&lt;/p&gt;
&lt;p&gt;解决幻读的案例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dba:lc_4&amp;gt; set tx_isolation=&amp;apos;repeatable-read&amp;apos;;
Query OK, 0 rows affected (0.00 sec)
dba:lc_4&amp;gt; select * from lc for update ;
+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
+----+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时候，查看下锁的情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;------------
TRANSACTIONS
------------
Trx id counter 133588361
Purge done for trx&amp;apos;s n:o &amp;lt; 133588356 undo n:o &amp;lt; 0 state: running but idle
History list length 892
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 421565826150000, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 421565826149088, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 133588360, ACTIVE 4 sec
2 lock struct(s), heap size 1136, 4 row lock(s)
MySQL thread id 135, OS thread handle 140001104295680, query id 1176 localhost dba cleaning up
TABLE LOCK table `lc_4`.`lc` trx id 133588360 lock mode IX
RECORD LOCKS space id 289 page no 3 n bits 72 index PRIMARY of table `lc_4`.`lc` trx id 133588360 lock_mode X  --next key lock ， 锁记录和范围
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;   --next-key lock, 锁住正无穷大
Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000001; asc     ;;  --next-key lock, 锁住1和1之前的区间，包括记录 (negtive,1]
 1: len 6; hex 000007f6657e; asc     e~;;
 2: len 7; hex e5000040220110; asc    @&amp;quot;  ;;
Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000002; asc     ;;  --next-key lock, 锁住2和1之前的区间，包括记录 (1,2]
 1: len 6; hex 000007f6657f; asc     e ;;
 2: len 7; hex e6000040330110; asc    @3  ;;
Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000003; asc     ;;  --next-key lock, 锁住3和2之间的区间，包括记录 (2,3]
 1: len 6; hex 000007f66584; asc     e ;;
 2: len 7; hex e9000040240110; asc    @$  ;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总结下来就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(negtive bounds,1] ， (1,2] ， (2,3]，(3,positive bounds) –锁住的记录和范围，相当于表锁  &lt;/li&gt;
&lt;li&gt;这时候，session 2 插入任何一条记录，会被锁住，所以幻读可以避免，尤其彻底解决了幻读的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RC&lt;/p&gt;
&lt;p&gt;RC 的锁算法：record locks&lt;br&gt;幻读对线上影响大吗？ oracle默认就是RC隔离级别&lt;/p&gt;
&lt;p&gt;不解决幻读的案例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dba:lc_4&amp;gt; set tx_isolation=&amp;apos;read-committed&amp;apos;;
Query OK, 0 rows affected (0.00 sec)
dba:lc_4&amp;gt; select * from lc for update ;
+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
+----+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看锁的信息如下  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;------------
TRANSACTIONS
------------
Trx id counter 133588362
Purge done for trx&amp;apos;s n:o &amp;lt; 133588356 undo n:o &amp;lt; 0 state: running but idle
History list length 892
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 421565826150000, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 421565826149088, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 133588361, ACTIVE 3 sec
2 lock struct(s), heap size 1136, 3 row lock(s)
MySQL thread id 138, OS thread handle 140001238955776, query id 1192 localhost dba cleaning up
TABLE LOCK table `lc_4`.`lc` trx id 133588361 lock mode IX
RECORD LOCKS space id 289 page no 3 n bits 72 index PRIMARY of table `lc_4`.`lc` trx id 133588361 lock_mode X locks rec but not gap  --记录锁，只锁记录
Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000001; asc     ;;   -- 记录锁，锁住1
 1: len 6; hex 000007f6657e; asc     e~;;
 2: len 7; hex e5000040220110; asc    @&amp;quot;  ;;
Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000002; asc     ;;  -- 记录锁，锁住2
 1: len 6; hex 000007f6657f; asc     e ;;
 2: len 7; hex e6000040330110; asc    @3  ;;
Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000003; asc     ;; -- 记录锁，锁住3
 1: len 6; hex 000007f66584; asc     e ;;
 2: len 7; hex e9000040240110; asc    @$  ;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总结下来&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;锁住的是哪些？  [1,2,3] 这些记录被锁住  &lt;/li&gt;
&lt;li&gt;那么session 2 除了1，2，3 不能插入之外，其他的记录都能，比如； insert into lc select 4 , 那么再次select * from lc for udpate 的时候，就是4条记录了，由此产生幻读&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RC vs RR 安全性&lt;/p&gt;
&lt;p&gt;RC 和 binlog&lt;/p&gt;
&lt;p&gt;RC 模式，binlog 必须使用Row 模式&lt;br&gt;为什么RC的binlog必须使用Row&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;session 1:
begin;
delete from  tb_1 where id &amp;gt; 0;

session 2:
begin;
insert into tb_1 select 100;
commit;

session 1:
commit;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果RC模式下的binlog是statement模式，结果会是怎么样呢？&lt;br&gt;master :  结果是 100&lt;br&gt;slave  :  结果是 空&lt;br&gt;这样就导致master和slave结果不一致了: 因为在slave上，先执行insert into tb_1 select 100; 再执行delete from  tb_1 where id &amp;gt; 0; 当然等于空咯    &lt;/p&gt;
&lt;p&gt;如果RC模式下的binlog是ROW模式，结果会是怎么样呢？&lt;br&gt;master :  结果是 100&lt;br&gt;slave :  结果是 100&lt;br&gt;主从结果一致，因为binlog是row模式，slave并不是逻辑的执行上述sql，而记录的都是行的变化&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;RC 的优点&lt;/p&gt;
&lt;p&gt;1.由于降低了隔离级别，那么实现起来简单，对锁的开销小，基本上不会有Gap lock，那么导致死锁和锁等待的可能就小&lt;br&gt;2.当然RC也不是完全没有Gap lock，当purge 和 唯一性索引存在的时候会产生特殊的Gap lock，这个后面会具体讲&lt;/p&gt;
&lt;p&gt;RC 的缺点&lt;br&gt;1.会有幻读发生&lt;br&gt;2.事务内的每条select，都会产生新的read-view，造成资源浪费&lt;/p&gt;
&lt;p&gt;RR 的优点&lt;br&gt;1.一个事务，只有再开始的时候才会产生read-view，有且只有一个，所以这块消耗比较小&lt;br&gt;2.解决了幻读的问题, 实现了真正意义上的隔离级别&lt;/p&gt;
&lt;p&gt;RR 的缺点&lt;br&gt;由于RR的实现，是通过Gap-lock实现，经常会锁定一个范围，那么导致死锁和所等待的概率非常大&lt;br&gt;我们的选择&lt;br&gt;一般我们生产环境的标配，都是RC+Row 模式，谁用谁知道哦&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;数据库事务隔离级别分为四种（级别递减）：&lt;/p&gt;
&lt;p&gt;1、Serializable （串行化）：最严格的级别，事务串行执行，资源消耗最大；&lt;/p&gt;
&lt;p&gt;2、REPEATABLE READ（重复读） ：保证了一个事务不会修改已经由另一个
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="事务" scheme="http://idber.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>隔离级别</title>
    <link href="http://idber.github.io/2018/08/15-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html"/>
    <id>http://idber.github.io/2018/08/15-隔离级别.html</id>
    <published>2018-08-15T02:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.939Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;开始介绍之前，先让我们了解一些基本概念。ANSI SQL STANDARD定义了递增4类隔离级别（READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE)，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级别一般支持更高的并发处理，并拥有更低的系统开销。&lt;/p&gt;
&lt;h4 id=&quot;Read-Uncommitted（读未提交）&quot;&gt;&lt;a href=&quot;#Read-Uncommitted（读未提交）&quot; class=&quot;headerlink&quot; title=&quot;* Read Uncommitted（读未提交）&quot;&gt;&lt;/a&gt;* Read Uncommitted（读未提交）&lt;/h4&gt;&lt;p&gt;在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。&lt;/p&gt;
&lt;h4 id=&quot;Read-Committed（读已提交）&quot;&gt;&lt;a href=&quot;#Read-Committed（读已提交）&quot; class=&quot;headerlink&quot; title=&quot;* Read Committed（读已提交）&quot;&gt;&lt;/a&gt;* Read Committed（读已提交）&lt;/h4&gt;&lt;p&gt;一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。&lt;/p&gt;
&lt;h4 id=&quot;Repeatable-Read（可重读）&quot;&gt;&lt;a href=&quot;#Repeatable-Read（可重读）&quot; class=&quot;headerlink&quot; title=&quot;* Repeatable Read（可重读）&quot;&gt;&lt;/a&gt;* Repeatable Read（可重读）&lt;/h4&gt;&lt;p&gt;这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。&lt;/p&gt;
&lt;h4 id=&quot;Serializable（可串行化）&quot;&gt;&lt;a href=&quot;#Serializable（可串行化）&quot; class=&quot;headerlink&quot; title=&quot;* Serializable（可串行化）&quot;&gt;&lt;/a&gt;* Serializable（可串行化）&lt;/h4&gt;&lt;p&gt;这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 这四种隔离级别采取不同的锁类型来实现。并发控制中读取同一个表的数据，可能出现如下问题：&lt;/p&gt;
&lt;h4 id=&quot;脏读-Drity-Read-：&quot;&gt;&lt;a href=&quot;#脏读-Drity-Read-：&quot; class=&quot;headerlink&quot; title=&quot;脏读(Drity Read)：&quot;&gt;&lt;/a&gt;脏读(Drity Read)：&lt;/h4&gt;&lt;p&gt;事务T1修改了一行数据，事务T2在事务T1提交之前读到了该行数据。&lt;/p&gt;
&lt;h4 id=&quot;不可重复读-Non-repeatable-read&quot;&gt;&lt;a href=&quot;#不可重复读-Non-repeatable-read&quot; class=&quot;headerlink&quot; title=&quot;不可重复读(Non-repeatable read):&quot;&gt;&lt;/a&gt;不可重复读(Non-repeatable read):&lt;/h4&gt;&lt;p&gt;事务T1读取了一行数据。 事务T2接着修改或者删除了改行数据，当T1再次读取同一行数据的时候，读到的数据时修改之后的或者发现已经被删除。&lt;/p&gt;
&lt;h4 id=&quot;幻读-Phantom-Read&quot;&gt;&lt;a href=&quot;#幻读-Phantom-Read&quot; class=&quot;headerlink&quot; title=&quot;幻读(Phantom Read):&quot;&gt;&lt;/a&gt;幻读(Phantom Read):&lt;/h4&gt;&lt;p&gt;事务T1读取了满足某条件的一个数据集，事务T2插入了一行或者多行数据满足了T1的选择条件，导致事务T1再次使用同样的选择条件读取的时候，得到了比第一次读取更多的数据集。&lt;/p&gt;
&lt;p&gt;MySQL/INNODB支持ANSI SQL STANDARD规定的四种隔离级别（READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE).本篇文章重点关注一下MySQL REPEATABLE READ隔离级别与其他数据实现方式上的不同之处。&lt;/p&gt;
&lt;p&gt;下面看一下MySQL在REPEATABLE READ 隔离级别下的工作方式：&lt;/p&gt;
&lt;p&gt;开启两个session。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB01.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来看一下另外一个开源数据库PostgreSQL在REPEATABLE READ 隔离级别下的工作方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB02.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;同样测试了SQL SERVER，得到的结果与PostgreSQL是一致的。&lt;/p&gt;
&lt;p&gt;从上面的执行情况我们可以看到MySQL与PostgreSQL两者工作方式上有所不同。MySQL在执行UPDATE语句的时候对于session2的INSERT语句是可以看到的，也就是说发生了幻读。那么MySQL在隔离级别为REPEATABLE READ的情况下，表现出来的幻读现象是否属于一个BUG呢？曾经有人在2013年给官方提过一个关于该现象的BUG，请参考&lt;a href=&quot;https://bugs.mysql.com/bug.php?id=63870&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://bugs.mysql.com/bug.php?id=63870&lt;/a&gt; 。 从BUG页面的注释可以了解到，该现象是与MySQL对REPATABLE READ隔离级别的实现方式有关。而这种幻读现象对于REPATABLE READ隔离级别也是正确的方式。请看wikipedia上对于REPEATABLE READ的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Repeatable reads&lt;br&gt;In this isolation level, a lock-based concurrency control DBMS implementation keeps read and&lt;br&gt;write locks (acquired on selected data) until the end of the transaction. However, range-locks are not managed, so phantom reads can occur.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外我们接着看一下ANSI SQL STANDARD对于各种隔离级别发生幻读的规定：&lt;br&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB03.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;我们从wikipedia以及ANSI SQL STANDARD可以看到对于REPEATABLE READ隔离级别下是允许出现幻读现象的。&lt;/p&gt;
&lt;p&gt;接下来我们从源码的角度分析一下Innodb对于REPEATABLE READ隔离级别的执行过程(代码只覆盖重要执行部分）。 以上面的例子为依据进行剖析： 对于第一条SELECT语句，InnoDB将调用row_search_for_mysql函数来返回扫描行。函数row_search_for_mysql调用相关代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UNIV_INTERN
dberr_t
row_search_for_mysql(
/*=================*/
  byte*   buf,    /* 用来存放记录的空间地址 */
  ulint   mode,   /* InnoDB页扫描顺序 */
  row_prebuilt_t* prebuilt, /* InnoDB扫描需要的所有信息都包含在这个结构体，比如表以及Index等信息 */
  ulint   match_mode, /* 对于Index的匹配模式，是精确匹配还是前缀索引匹配 */
  ulint   direction)  /* 指定扫描顺序，正序还是倒叙扫描 */
{
    ...
    /* 从这里我们看出开始一个新事务，并非是从执行BEGIN语句位置开始，而是从其后开始执行的第一条语句开始分配事务ID */
    trx_start_if_not_started(trx, ((trx-&amp;gt;mysql_thd
          &amp;amp;&amp;amp; thd_is_select(trx-&amp;gt;mysql_thd)
          ) || srv_read_only_mode) ? FALSE : TRUE); 

    ...
    // 如果是SQL语句第一次开始执行，需要考虑对TABLE增加意向所

     if (!prebuilt-&amp;gt;sql_stat_start) {
     // 这里标记SQL语句已经开始执行，处理一条SQL语句循环扫描记录的过程
    /* No need to set an intention lock or assign a read view */

    if (UNIV_UNLIKELY
        (trx-&amp;gt;read_view == NULL 
         &amp;amp;&amp;amp; prebuilt-&amp;gt;select_lock_type == LOCK_NONE)) {
      fputs(&amp;quot;InnoDB: Error: MySQL is trying to&amp;quot;            &amp;quot; perform a consistent read\n&amp;quot;            &amp;quot;InnoDB: but the read view is not assigned!\n&amp;quot;,            stderr);
      trx_print(stderr, trx, 600);
      fputc(&amp;apos;\n&amp;apos;, stderr);
      ut_error;
        }
  } else if (prebuilt-&amp;gt;select_lock_type == LOCK_NONE) {
    /* This is a consistent read */
    /* Assign a read view for the query */
    // 如果是第一次执行SELECT语句，构建READ_VIEW. 该READ_VIEW 用来判断记录的可见性
    trx_assign_read_view(trx);
    prebuilt-&amp;gt;sql_stat_start = FALSE;
  } else {
    ...
  }

    ...

     /* We are ready to look at a possible new index entry in the result
  set: the cursor is now placed on a user record */
    /* 从这里我们看一下InnoDB如何获取一条新纪录。由于上面例子中SESSION1的第一条语句是SELECT语句，InnoDB在REPEATABLE READ 隔离级别下，不对SELECT 语句加锁，所以这里执行SELECT语句的时候prebuilt-&amp;gt;select_lock_type为LOCK_NONE。下面我们直接看一下prebuilt-&amp;gt;select_lock_type为LOCK_NONE的情况下，InnoDB如何扫描行？ */
  if (prebuilt-&amp;gt;select_lock_type != LOCK_NONE) {
    ... //稍后会对prebuilt-&amp;gt;select_lock_type != LOCK_NONE的情况进行分析
    }
  else
    {
        /* This is a non-locking consistent read: if necessary, fetch
    a previous version of the record */

    if (trx-&amp;gt;isolation_level == TRX_ISO_READ_UNCOMMITTED) {

      /* 对于READ UNCOMMITTED隔离级别，我们什么都不需要，只要让他读取最新的记录版本即可 */

    } else if (index == clust_index) {

      /* Fetch a previous version of the row if the current
      one is not visible in the snapshot; if we have a very
      high force recovery level set, we try to avoid crashes
 by skipping this lookup */
      // 如果是全表扫描或主键扫描，这里需要看看当前记录是否对当前事务可见
      if (UNIV_LIKELY(srv_force_recovery &amp;lt; 5)
          &amp;amp;&amp;amp; !lock_clust_rec_cons_read_sees(
            rec, index, offsets, trx-&amp;gt;read_view)) {
        // 如果不可见，这里需要查找历史版本
        rec_t*  old_vers;
        /* The following call returns &amp;apos;offsets&amp;apos;
        associated with &amp;apos;old_vers&amp;apos; */
        err = row_sel_build_prev_vers_for_mysql(
          trx-&amp;gt;read_view, clust_index,
          prebuilt, rec, &amp;amp;offsets, &amp;amp;heap,
          &amp;amp;old_vers, &amp;amp;mtr);
                if (err != DB_SUCCESS) {

          goto lock_wait_or_error;
        }

        if (old_vers == NULL) {
          /* The row did not exist yet in
          the read view */
          // 如果当前记录对当前事务不可见，也没有历史版本，直接查找下一条记录
          goto next_rec;
        }

        rec = old_vers;
           } else {
      /* We are looking into a non-clustered index,
      and to get the right version of the record we
      have to look also into the clustered index: this
      is necessary, because we can only get the undo
      information via the clustered index record. */

      ut_ad(!dict_index_is_clust(index));
      // 这里处理是Secondary index扫描的情况
      if (!lock_sec_rec_cons_read_sees(
            rec, trx-&amp;gt;read_view)) {
        /* We should look at the clustered index.
                However, as this is a non-locking read,
        we can skip the clustered index lookup if
        the condition does not match the secondary
        index entry. */
        // 这里InnoDB做了一下优化，如果当前记录不满足ICP，直接查找下一条记录；如果满足ICP则需要继续根据聚集索引寻找历史版本
        switch (row_search_idx_cond_check(
            buf, prebuilt, rec, offsets)) {
        case ICP_NO_MATCH:
          goto next_rec;
        case ICP_OUT_OF_RANGE:
          err = DB_RECORD_NOT_FOUND;
          goto idx_cond_failed;
        case ICP_MATCH:
          goto requires_clust_rec;
        }
        ut_error;
      }
    }
  }
...
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来我们看一下UPDATE的执行过程。对于UPDATE操作执行流程的简单描述如下：&lt;/p&gt;
&lt;p&gt;根据WHERE条件扫描一条记录（row_search_for_mysql）&lt;/p&gt;
&lt;p&gt;更新当前获取的记录(ha_innobase::update_row)&lt;/p&gt;
&lt;p&gt;重新将更新后的记录写入InnoDB存储引擎(row_upd_step)&lt;/p&gt;
&lt;p&gt;那么我们按照上面的这个流程看一下源码方面的执行过程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UNIV_INTERN
dberr_t
row_search_for_mysql(
/*=================*/
  byte*   buf,    /* 用来存放记录的空间地址 */
  ulint   mode,   /* InnoDB页扫描顺序 */
  row_prebuilt_t* prebuilt, /* InnoDB扫描需要的所有信息都包含在这个结构体，比如表以及Index等信息 */
  ulint   match_mode, /* 对于Index的匹配模式，是精确匹配还是前缀索引匹配 */
  ulint   direction)  /* 指定扫描顺序，正序还是倒叙扫描 */
{
    ...
    /* 从这里我们看出开始一个新事务，并非是从执行BEGIN语句位置开始，而是从其后开始执行的第一条语句开始分配事务ID */
    trx_start_if_not_started(trx, ((trx-&amp;gt;mysql_thd
          &amp;amp;&amp;amp; thd_is_select(trx-&amp;gt;mysql_thd)
          ) || srv_read_only_mode) ? FALSE : TRUE); 

    ...
    // 如果是SQL语句第一次开始执行，需要考虑对TABLE增加意向所

     if (!prebuilt-&amp;gt;sql_stat_start) {
     // 这里标记SQL语句已经开始执行，处理一条SQL语句循环扫描记录的过程
    /* No need to set an intention lock or assign a read view */

    if (UNIV_UNLIKELY
        (trx-&amp;gt;read_view == NULL 
         &amp;amp;&amp;amp; prebuilt-&amp;gt;select_lock_type == LOCK_NONE)) {
      ...
        }
  } else if (prebuilt-&amp;gt;select_lock_type == LOCK_NONE) {
    ...
  } else {
    // 这里开始非INSERT的DML操作，因为DML会对记录增加记录排他锁。具体需要增加什么类型的锁，可以参考https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html
 wait_table_again:
    // 这里要对TABLE加意向锁
    err = lock_table(0, index-&amp;gt;table,
         prebuilt-&amp;gt;select_lock_type == LOCK_S
         ? LOCK_IS : LOCK_IX, thr);

    if (err != DB_SUCCESS) {

      table_lock_waited = TRUE;
      goto lock_table_wait;
    }    
    prebuilt-&amp;gt;sql_stat_start = FALSE;
  }

    ...
  if (prebuilt-&amp;gt;select_lock_type != LOCK_NONE) {
     ulint lock_type;

    if (!set_also_gap_locks
        || srv_locks_unsafe_for_binlog
        || trx-&amp;gt;isolation_level &amp;lt;= TRX_ISO_READ_COMMITTED
        || (unique_search &amp;amp;&amp;amp; !rec_get_deleted_flag(rec, comp))) {
      // 这里对于READ_UNCOMMITTED以及READ_COMMITTED,或者唯一键扫描不需要使用gap锁
      goto no_gap_lock;
    } else {
      lock_type = LOCK_ORDINARY;
    }

    /* If we are doing a &amp;apos;greater or equal than a primary key
    value&amp;apos; search from a clustered index, and we find a record
    that has that exact primary key value, then there is no need
    to lock the gap before the record, because no insert in the
    gap can be in our search range. That is, no phantom row can
    appear that way.

    An example: if col1 is the primary key, the search is WHERE
    col1 &amp;gt;= 100, and we find a record where col1 = 100, then no
    need to lock the gap before that record. */

    if (index == clust_index
        &amp;amp;&amp;amp; mode == PAGE_CUR_GE
        &amp;amp;&amp;amp; direction == 0
        &amp;amp;&amp;amp; dtuple_get_n_fields_cmp(search_tuple)
        == dict_index_get_n_unique(index)
        &amp;amp;&amp;amp; 0 == cmp_dtuple_rec(search_tuple, rec, offsets)) {
no_gap_lock:
      lock_type = LOCK_REC_NOT_GAP;
    }

        err = sel_set_rec_lock(btr_pcur_get_block(pcur),
               rec, index, offsets,
               prebuilt-&amp;gt;select_lock_type,
               lock_type, thr);

    switch (err) {
      const rec_t*  old_vers;
    case DB_SUCCESS_LOCKED_REC:
      if (srv_locks_unsafe_for_binlog
          || trx-&amp;gt;isolation_level
          &amp;lt;= TRX_ISO_READ_COMMITTED) {
        /* Note that a record of
        prebuilt-&amp;gt;index was locked. */
        prebuilt-&amp;gt;new_rec_locks = 1;
      }
      err = DB_SUCCESS;
    case DB_SUCCESS:
     // 加锁成功后就认为记录可见了，并未像SELECT语句一样根据事务开始的READ_VIEW进行可见性判断。所以对于DML来说，所有提交的事务都是可见的。
      break;
    case DB_LOCK_WAIT:
          /* Never unlock rows that were part of a conflict. */
      // 如果存在锁冲突，也就是其他事务正在更新同一行
      prebuilt-&amp;gt;new_rec_locks = 0;

      if (UNIV_LIKELY(prebuilt-&amp;gt;row_read_type
          != ROW_READ_TRY_SEMI_CONSISTENT)
          || unique_search
          || index != clust_index) {

        goto lock_wait_or_error;
      }

      /* The following call returns &amp;apos;offsets&amp;apos;
      associated with &amp;apos;old_vers&amp;apos; */
      // 这里需要查看是否有别的事务提交了，以便获取最新版本的记录
      row_sel_build_committed_vers_for_mysql(
        clust_index, prebuilt, rec,
        &amp;amp;offsets, &amp;amp;heap, &amp;amp;old_vers, &amp;amp;mtr);

      /* Check whether it was a deadlock or not, if not
      a deadlock and the transaction had to wait then
      release the lock it is waiting on. */
            err = lock_trx_handle_wait(trx);

      switch (err) {
      case DB_SUCCESS:
        /* The lock was granted while we were
        searching for the last committed version.
        Do a normal locking read. */

        offsets = rec_get_offsets(
          rec, index, offsets, ULINT_UNDEFINED,
          &amp;amp;heap);
        goto locks_ok;
      case DB_DEADLOCK:
        goto lock_wait_or_error;
      case DB_LOCK_WAIT:
        err = DB_SUCCESS;
        break;
      default:
        ut_error;
      }
            if (old_vers == NULL) {
        /* The row was not yet committed */

        goto next_rec;
      }
      did_semi_consistent_read = TRUE;
      rec = old_vers;
      break;
    default:

      goto lock_wait_or_error;
    }

    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面的代码我们可以看到，对于UPDATE操作更新的记录包含幻读读取到的已提交事务的最新记录。那么接下来看为什么UPDATE之后的SELECT语句对于UPDATE之后的所有语句都可见了？ 原因是前面的UPDATE语句执行之后，会将当前记录上存储的事务信息更新为当前的事务，而当前事务所做的任何更新，对本事务所有SELECT查询都变的可见，因此最后输出的结果是UPDATE执行后更新的所有记录。&lt;/p&gt;
&lt;p&gt;当前各种数据库对于隔离级别的支持不尽相同，比如ORACLE，它只实现了READ COMMITTED和SERIALIZABLE两种ANSI SQL STANDARD规定的隔离级别（这里ORACLE还实现了一种自定义的READ ONLY隔离级别，具体请参考&lt;a href=&quot;https://docs.oracle.com/cd/B28359_01/server.111/b28318/consist.htm#CNCPT621&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.oracle.com/cd/B28359_01/server.111/b28318/consist.htm#CNCPT621&lt;/a&gt; ） ， 而没有实现REPEATABLE READ。对于相同的隔离级别，不同的数据库有着自己不同的实现方式。所以我们在理解隔离级别的时候需要针对具体的数据库。综上所述，我们看到了MySQL InnoDB引擎对于REPEATABLE READ隔离级别有着不同于其他数据库的实现方式。而该实现方式符合ANSI SQL STANDARD，并非属于实现上的BUG。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;开始介绍之前，先让我们了解一些基本概念。ANSI SQL STANDARD定义了递增4类隔离级别（READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE)，包括了一些具体规则，用来限定事务内外
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="事务" scheme="http://idber.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB Buffer Pool Flush策略漫谈</title>
    <link href="http://idber.github.io/2018/08/14-InnoDB%20buffer%20pool%20flush%E7%AD%96%E7%95%A5%E6%BC%AB%E8%B0%88.html"/>
    <id>http://idber.github.io/2018/08/14-InnoDB buffer pool flush策略漫谈.html</id>
    <published>2018-08-14T02:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.927Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;我们知道InnoDB使用buffer pool来缓存从磁盘读取到内存的数据页。buffer pool通常由数个内存块加上一组控制结构体对象组成。内存块的个数取决于buffer pool instance的个数，不过在5.7版本中开始默认以128M（可配置）的chunk单位分配内存块，这样做的目的是为了支持buffer pool的在线动态调整大小。&lt;/p&gt;
&lt;p&gt;Buffer pool的每个内存块通过mmap的方式分配内存，因此你会发现，在实例启动时虚存很高，而物理内存很低。这些大片的内存块又按照16KB划分为多个frame，用于存储数据页。&lt;/p&gt;
&lt;p&gt;虽然大多数情况下buffer pool是以16KB来存储数据页，但有一种例外：使用压缩表时，需要在内存中同时存储压缩页和解压页，对于压缩页，使用Binary buddy allocator算法来分配内存空间。例如我们读入一个8KB的压缩页，就从buffer pool中取一个16KB的block，取其中8KB，剩下的8KB放到空闲链表上；如果紧跟着另外一个4KB的压缩页读入内存，就可以从这8KB中分裂4KB，同时将剩下的4KB放到空闲链表上。&lt;/p&gt;
&lt;p&gt;为了管理buffer pool，每个buffer pool instance 使用如下几个链表来管理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LRU链表包含所有读入内存的数据页；&lt;/li&gt;
&lt;li&gt;Flush_list包含被修改过的脏页；&lt;/li&gt;
&lt;li&gt;unzip_LRU包含所有解压页；&lt;/li&gt;
&lt;li&gt;Free list上存放当前空闲的block。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外为了避免查询数据页时扫描LRU，还为每个buffer pool instance维护了一个page hash，通过space id 和page no可以直接找到对应的page。&lt;/p&gt;
&lt;p&gt;一般情况下，当我们需要读入一个Page时，首先根据space id 和page no找到对应的buffer pool instance。然后查询page hash，如果page hash中没有，则表示需要从磁盘读取。在读盘前首先我们需要为即将读入内存的数据页分配一个空闲的block。当free list上存在空闲的block时，可以直接从free list上摘取；如果没有，就需要从unzip_lru 或者 lru上驱逐page。&lt;/p&gt;
&lt;p&gt;这里需要遵循一定的原则（参考函数buf_LRU_scan_and_free_block , 5.7.5）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先尝试从unzip_lru上驱逐解压页；&lt;/li&gt;
&lt;li&gt;如果没有，再尝试从Lru链表上驱逐Page；&lt;/li&gt;
&lt;li&gt;如果还是无法从Lru上获取到空闲block，用户线程就会参与刷脏，尝试做一次SINGLE PAGE FLUSH，单独从Lru上刷掉一个脏页，然后再重试。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Buffer pool中的page被修改后，不是立刻写入磁盘，而是由后台线程定时写入，和大多数数据库系统一样，脏页的写盘遵循日志先行WAL原则，因此在每个block上都记录了一个最近被修改时的Lsn，写数据页时需要确保当前写入日志文件的redo不低于这个Lsn。&lt;/p&gt;
&lt;p&gt;然而基于WAL原则的刷脏策略可能带来一个问题：当数据库的写入负载过高时，产生redo log的速度极快，redo log可能很快到达同步checkpoint点。这时候需要进行刷脏来推进Lsn。由于这种行为是由用户线程在检查到redo log空间不够时触发，大量用户线程将可能陷入到这段低效的逻辑中，产生一个明显的性能拐点。&lt;/p&gt;
&lt;h2 id=&quot;Page-Cleaner线程&quot;&gt;&lt;a href=&quot;#Page-Cleaner线程&quot; class=&quot;headerlink&quot; title=&quot;Page Cleaner线程&quot;&gt;&lt;/a&gt;Page Cleaner线程&lt;/h2&gt;&lt;p&gt;在MySQL5.6中，开启了一个独立的page cleaner线程来进行刷lru list 和flush list。默认每隔一秒运行一次，5.6版本里提供了一大堆的参数来控制page cleaner的flush行为，包括：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;innodb_adaptive_flushing_lwm， 
innodb_max_dirty_pages_pct_lwm
innodb_flushing_avg_loops
innodb_io_capacity_max
innodb_lru_scan_depth
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我们不一一介绍，总的来说，如果你发现redo log推进的非常快，为了避免用户线程陷入刷脏，可以通过调大innodb_io_capacity_max来解决，该参数限制了每秒刷新的脏页上限，调大该值可以增加Page cleaner线程每秒的工作量。如果你发现你的系统中free list不足，总是需要驱逐脏页来获取空闲的block时，可以适当调大innodb_lru_scan_depth 。该参数表示从每个buffer pool instance的lru上扫描的深度，调大该值有助于多释放些空闲页，避免用户线程去做single page flush。&lt;/p&gt;
&lt;p&gt;为了提升扩展性和刷脏效率，在5.7.4版本里引入了多个page cleaner线程，从而达到并行刷脏的效果。目前Page cleaner并未和buffer pool绑定，其模型为一个协调线程 + 多个工作线程，协调线程本身也是工作线程。因此如果innodb_page_cleaners设置为4，那么就是一个协调线程，加3个工作线程，工作方式为生产者-消费者。工作队列长度为buffer pool instance的个数，使用一个全局slot数组表示。&lt;/p&gt;
&lt;p&gt;协调线程在决定了需要flush的page数和lsn_limit后，会设置slot数组，将其中每个slot的状态设置为PAGE_CLEANER_STATE_REQUESTED, 并设置目标page数及lsn_limit，然后唤醒工作线程 (pc_request)&lt;/p&gt;
&lt;p&gt;工作线程被唤醒后，从slot数组中取一个未被占用的slot，修改其状态，表示已被调度，然后对该slot所对应的buffer pool instance进行操作。直到所有的slot都被消费完后，才进入下一轮。通过这种方式，多个page cleaner线程实现了并发flush buffer pool，从而提升flush dirty page/lru的效率。&lt;/p&gt;
&lt;h2 id=&quot;MySQL5-7的InnoDB-flush策略优化&quot;&gt;&lt;a href=&quot;#MySQL5-7的InnoDB-flush策略优化&quot; class=&quot;headerlink&quot; title=&quot;MySQL5.7的InnoDB flush策略优化&quot;&gt;&lt;/a&gt;MySQL5.7的InnoDB flush策略优化&lt;/h2&gt;&lt;p&gt;在之前版本中，因为可能同时有多个线程操作buffer pool刷page （在刷脏时会释放buffer pool mutex），每次刷完一个page后需要回溯到链表尾部，使得扫描bp链表的时间复杂度最差为O（N*N）。&lt;/p&gt;
&lt;p&gt;在5.6版本中针对Flush list的扫描做了一定的修复，使用一个指针来记录当前正在flush的page，待flush操作完成后，再看一下这个指针有没有被别的线程修改掉，如果被修改了，就回溯到链表尾部，否则无需回溯。但这个修复并不完整，在最差的情况下，时间复杂度依旧不理想。&lt;/p&gt;
&lt;p&gt;因此在5.7版本中对这个问题进行了彻底的修复，使用多个名为hazard pointer的指针，在需要扫描LIST时，存储下一个即将扫描的目标page，根据不同的目的分为几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flush_hp: 用作批量刷FLUSH LIST&lt;/li&gt;
&lt;li&gt;lru_hp: 用作批量刷LRU LIST&lt;/li&gt;
&lt;li&gt;lru_scan_itr: 用于从LRU链表上驱逐一个可替换的page，总是从上一次扫描结束的位置开始，而不是LRU尾部&lt;/li&gt;
&lt;li&gt;single_scan_itr: 当buffer pool中没有空闲block时，用户线程会从FLUSH LIST上单独驱逐一个可替换的page 或者 flush一个脏页，总是从上一次扫描结束的位置开始，而不是LRU尾部。&lt;br&gt;后两类的hp都是由用户线程在尝试获取空闲block时调用，只有在推进到某个buf_page_t::old被设置成true的page (大约从Lru链表尾部起至总长度的八分之三位置的page)时， 再将指针重置到Lru尾部。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些指针在初始化buffer pool时分配，每个buffer pool instance都拥有自己的hp指针。当某个线程对buffer pool中的page进行操作时，例如需要从LRU中移除Page时，如果当前的page被设置为hp，就要将hp更新为当前Page的前一个page。当完成当前page的flush操作后，直接使用hp中存储的page指针进行下一轮flush。&lt;/p&gt;
&lt;h2 id=&quot;社区优化&quot;&gt;&lt;a href=&quot;#社区优化&quot; class=&quot;headerlink&quot; title=&quot;社区优化&quot;&gt;&lt;/a&gt;社区优化&lt;/h2&gt;&lt;p&gt;一如既往的，Percona Server在5.6版本中针对buffer pool flush做了不少的优化，主要的修改包括如下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;优化刷LRU流程buf_flush_LRU_tail 该函数由page cleaner线程调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原生的逻辑：依次flush 每个buffer pool instance，每次扫描的深度通过参数innodb_lru_scan_depth来配置。而在每个instance内，又分成多个chunk来调用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;修改后的逻辑为：每次flush一个buffer pool的LRU时，只刷一个chunk，然后再下一个instance，刷完所有instnace后，再回到前面再刷一个chunk。简而言之，把集中的flush操作进行了分散，其目的是分散压力，避免对某个instance的集中操作，给予其他线程更多访问buffer pool的机会。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;允许设定刷LRU/FLUSH LIST的超时时间，防止flush操作时间过长导致别的线程（例如尝试做single page flush的用户线程）stall住；当到达超时时间时,page cleaner线程退出flush。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免用户线程参与刷buffer pool 当用户线程参与刷buffer pool时，由于线程数的不可控，将产生严重的竞争开销，例如free list不足时做single page flush，以及在redo空间不足时，做dirty page flush，都会严重影响性能。Percona Server允许选择让page cleaner线程来做这些工作，用户线程只需要等待即可。出于效率考虑，用户还可以设置page cleaner线程的cpu调度优先级。 另外在Page cleaner线程经过优化后，可以知道系统当前处于同步刷新状态，可以去做更激烈的刷脏(furious flush)，用户线程参与到其中，可能只会起到反作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;允许设置page cleaner线程，purge线程，io线程，master线程的CPU调度优先级，并优先获得InnoDB的mutex。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用新的独立后台线程来刷buffer pool的LRU链表，将这部分工作负担从page cleaner线程剥离。 实际上就是直接转移刷LRU的代码到独立线程了。从之前Percona的版本来看，都是在不断的强化后台线程，让用户线程少参与到刷脏/checkpoint这类耗时操作中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;我们知道InnoDB使用buffer pool来缓存从磁盘读取到内存的数据页。buffer pool通常由数个内存块加上一组控制结
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="性能优化" scheme="http://idber.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Percona XtraBackup 的工作原理</title>
    <link href="http://idber.github.io/2018/08/13-Percona%20XtraBackup%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.html"/>
    <id>http://idber.github.io/2018/08/13-Percona XtraBackup 的工作原理.html</id>
    <published>2018-08-13T02:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.932Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Percona XtraBackup（简称PXB）是 Percona 公司开发的一个用于 MySQL 数据库物理热备的备份工具，支持 MySQl(Oracle)、Percona Server 和 MariaDB，并且全部开源，真可谓是业界良心。阿里云的 RDS MySQL 的物理备份就是基于这个工具做的。&lt;/p&gt;
&lt;h1 id=&quot;工具集&quot;&gt;&lt;a href=&quot;#工具集&quot; class=&quot;headerlink&quot; title=&quot;工具集&quot;&gt;&lt;/a&gt;工具集&lt;/h1&gt;&lt;p&gt;软件包安装完后一共有4个可执行文件，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;usr
├── bin
│   ├── innobackupex
│   ├── xbcrypt
│   ├── xbstream
│   └── xtrabackup
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中最主要的是 innobackupex 和 xtrabackup，前者是一个 perl 脚本，后者是 C/C++ 编译的二进制。&lt;/p&gt;
&lt;p&gt;xtrabackup 是用来备份 InnoDB 表的，不能备份非 InnoDB 表，和 mysqld server 没有交互；innobackupex 脚本用来备份非 InnoDB 表，同时会调用 xtrabackup 命令来备份 InnoDB 表，还会和 mysqld server 发送命令进行交互，如加读锁（FTWRL）、获取位点（SHOW SLAVE STATUS）等。简单来说，innobackupex 在 xtrabackup 之上做了一层封装。&lt;/p&gt;
&lt;p&gt;一般情况下，我们是希望能备份 MyISAM 表的，虽然我们可能自己不用 MyISAM 表，但是 mysql 库下的系统表是 MyISAM 的，因此备份基本都通过 innobackupex 命令进行；另外一个原因是我们可能需要保存位点信息。&lt;/p&gt;
&lt;p&gt;另外2个工具相对小众些，xbcrypt 是加解密用的；xbstream 类似于tar，是 Percona 自己实现的一种支持并发写的流文件格式。两都在备份和解压时都会用到（如果备份用了加密和并发）。&lt;/p&gt;
&lt;p&gt;本文的介绍的主角是 innobackupex 和 xtrabackup。&lt;/p&gt;
&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;h2 id=&quot;通信方式&quot;&gt;&lt;a href=&quot;#通信方式&quot; class=&quot;headerlink&quot; title=&quot;通信方式&quot;&gt;&lt;/a&gt;通信方式&lt;/h2&gt;&lt;p&gt;2个工具之间的交互和协调是通过控制文件的创建和删除来实现的，主要文件有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xtrabackup_suspended_1
xtrabackup_suspended_2
xtrabackup_log_copied
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;举个栗子，我们来看备份时 xtrabackup_suspended_2 是怎么来协调2个工具进程的&lt;/p&gt;
&lt;p&gt;innobackupex 在启动 xtrabackup 进程后，会一直等 xtrabackup 备份完 InnoDB 文件，方式就是等待 xtrabackup_suspended_2 这个文件被创建出来；&lt;br&gt;xtrabackup 在备完 InnoDB 数据后，就在指定目录下创建出这个文件，然后等这个文件被 innobackupex 删除；&lt;br&gt;innobackupex 检测到文件 xtrabackup_suspended_2 被创建出来后，就继续往下走；&lt;br&gt;innobackupex 在备份完非 InnoDB 表后，删除 xtrabackup_suspended_2 这个文件，这样就通知 xtrabackup 可以继续了，然后等 xtrabackup_log_copied 被创建；&lt;br&gt;xtrabackup 检测到 xtrabackup_suspended_2 文件删除后，就可以继续往下了。&lt;br&gt;是不是感觉有点不可思议，通过文件是否存在来控制进程，这种方式非常的不靠谱，因为非常容易被外部干扰，比如文件被别人误删掉，或者2个正在跑的备份控制文件误放在同一个目录下，就等着备份乱掉吧，但是 Percona 就是这么干的。&lt;/p&gt;
&lt;p&gt;之所以这么搞，估计主要是因为 perl 和 C 二进制2个进程，没有既好用又方便的通信方式，搞个协议啥的太麻烦了。但是官方也觉得这种方式不靠谱，11年就搞了个 blueprint 要用C重写 innobackupex，终于在2.3 版本实现了，innobackupex 功能全部集成到 xtrabackup 里面，只有一个 binary，另外为了使用上的兼容考虑，innobackupex 作为 xtrabackup 的一个软链。对于二次开发来说，2.3 摆脱了之前2个进程协作的负担，架构上明显要好于之前版本。考虑到 perl + C 这种架构的长期存在，大多数读者朋友也基本用的2.3之前版本，本文的介绍也是基于老的架构（2.2版本），但是原理和2.3是一样的，只是实现上的差别。&lt;/p&gt;
&lt;h2 id=&quot;备份过程&quot;&gt;&lt;a href=&quot;#备份过程&quot; class=&quot;headerlink&quot; title=&quot;备份过程&quot;&gt;&lt;/a&gt;备份过程&lt;/h2&gt;&lt;p&gt;整个备份过程如下图：&lt;br&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/PXB-backup-procedure.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;PXB备份过程&quot;&gt;&lt;a href=&quot;#PXB备份过程&quot; class=&quot;headerlink&quot; title=&quot;PXB备份过程&quot;&gt;&lt;/a&gt;PXB备份过程&lt;/h4&gt;&lt;p&gt;innobackupex 在启动后，会先 fork 一个进程，启动 xtrabackup进程，然后就等待 xtrabackup 备份完 ibd 数据文件；&lt;br&gt;xtrabackup 在备份 InnoDB 相关数据时，是有2种线程的，1种是 redo 拷贝线程，负责拷贝 redo 文件，1种是 ibd 拷贝线程，负责拷贝 ibd 文件；redo 拷贝线程只有一个，在 ibd 拷贝线程之前启动，在 ibd 线程结束后结束。xtrabackup 进程开始执行后，先启动 redo 拷贝线程，从最新的 checkpoint 点开始顺序拷贝 redo 日志；然后再启动 ibd 数据拷贝线程，在 xtrabackup 拷贝 ibd 过程中，innobackupex 进程一直处于等待状态（等待文件被创建）。&lt;br&gt;xtrabackup 拷贝完成idb后，通知 innobackupex（通过创建文件），同时自己进入等待（redo 线程仍然继续拷贝）;&lt;br&gt;innobackupex 收到 xtrabackup 通知后，执行FLUSH TABLES WITH READ LOCK (FTWRL)，取得一致性位点，然后开始备份非 InnoDB 文件（包括 frm、MYD、MYI、CSV、opt、par等）。拷贝非 InnoDB 文件过程中，因为数据库处于全局只读状态，如果在业务的主库备份的话，要特别小心，非 InnoDB 表（主要是MyISAM）比较多的话整库只读时间就会比较长，这个影响一定要评估到。&lt;br&gt;当 innobackupex 拷贝完所有非 InnoDB 表文件后，通知 xtrabackup（通过删文件） ，同时自己进入等待（等待另一个文件被创建）；&lt;br&gt;xtrabackup 收到 innobackupex 备份完非 InnoDB 通知后，就停止 redo 拷贝线程，然后通知 innobackupex redo log 拷贝完成（通过创建文件）；&lt;br&gt;innobackupex 收到 redo 备份完成通知后，就开始解锁，执行 UNLOCK TABLES；&lt;br&gt;最后 innobackupex 和 xtrabackup 进程各自完成收尾工作，如资源的释放、写备份元数据信息等，innobackupex 等待 xtrabackup 子进程结束后退出。&lt;br&gt;在上面描述的文件拷贝，都是备份进程直接通过操作系统读取数据文件的，只在执行 SQL 命令时和数据库有交互，基本不影响数据库的运行，在备份非 InnoDB 时会有一段时间只读（如果没有MyISAM表的话，只读时间在几秒左右），在备份 InnoDB 数据文件时，对数据库完全没有影响，是真正的热备。&lt;/p&gt;
&lt;p&gt;InnoDB 和非 InnoDB 文件的备份都是通过拷贝文件来做的，但是实现的方式不同，前者是以page为粒度做的(xtrabackup)，后者是 cp 或者 tar 命令(innobackupex)，xtrabackup 在读取每个page时会校验 checksum 值，保证数据块是一致的，而 innobackupex 在 cp MyISAM 文件时已经做了flush（FTWRL），磁盘上的文件也是完整的，所以最终备份集里的数据文件都是写入完整的。&lt;/p&gt;
&lt;h4 id=&quot;增量备份&quot;&gt;&lt;a href=&quot;#增量备份&quot; class=&quot;headerlink&quot; title=&quot;增量备份&quot;&gt;&lt;/a&gt;增量备份&lt;/h4&gt;&lt;p&gt;PXB 是支持增量备份的，但是只能对 InnoDB 做增量，InnoDB 每个 page 有个 LSN 号，LSN 是全局递增的，page 被更改时会记录当前的 LSN 号，page中的 LSN 越大，说明当前page越新（最近被更新）。每次备份会记录当前备份到的LSN（xtrabackup_checkpoints 文件中），增量备份就是只拷贝LSN大于上次备份的page，比上次备份小的跳过，每个 ibd 文件最终备份出来的是增量 delta 文件。&lt;/p&gt;
&lt;p&gt;MyISAM 是没有增量的机制的，每次增量备份都是全部拷贝的。&lt;/p&gt;
&lt;p&gt;增量备份过程和全量备份一样，只是在 ibd 文件拷贝上有不同。&lt;/p&gt;
&lt;h3 id=&quot;恢复过程&quot;&gt;&lt;a href=&quot;#恢复过程&quot; class=&quot;headerlink&quot; title=&quot;恢复过程&quot;&gt;&lt;/a&gt;恢复过程&lt;/h3&gt;&lt;p&gt;如果看恢复备份集的日志，会发现和 mysqld 启动时非常相似，其实备份集的恢复就是类似 mysqld crash后，做一次 crash recover。&lt;/p&gt;
&lt;p&gt;恢复的目的是把备份集中的数据恢复到一个一致性位点，所谓一致就是指原数据库某一时间点各引擎数据的状态，比如 MyISAM 中的数据对应的是 15:00 时间点的，InnoDB 中的数据对应的是 15:20 的，这种状态的数据就是不一致的。PXB 备份集对应的一致点，就是备份时FTWRL的时间点，恢复出来的数据，就对应原数据库FTWRL时的状态。&lt;/p&gt;
&lt;p&gt;因为备份时 FTWRL 后，数据库是处于只读的，非 InnoDB 数据是在持有全局读锁情况下拷贝的，所以非 InnoDB 数据本身就对应 FTWRL 时间点；InnoDB 的 ibd 文件拷贝是在 FTWRL 前做的，拷贝出来的不同 ibd 文件最后更新时间点是不一样的，这种状态的 ibd 文件是不能直接用的，但是 redo log 是从备份开始一直持续拷贝的，最后的 redo 日志点是在持有 FTWRL 后取得的，所以最终通过 redo 应用后的 ibd 数据时间点也是和 FTWRL 一致的。&lt;/p&gt;
&lt;p&gt;所以恢复过程只涉及 InnoDB 文件的恢复，非 InnoDB 数据是不动的。备份恢复完成后，就可以把数据文件拷贝到对应的目录，然后通过mysqld来启动了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Percona XtraBackup（简称PXB）是 Percona 公司开发的一个用于 MySQL 数据库物理热备的备份工具，支
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="备份" scheme="http://idber.github.io/tags/%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>MySQL主从同步延迟优化大全</title>
    <link href="http://idber.github.io/2018/08/12-MySQL%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E8%BF%9F%E4%BC%98%E5%8C%96%E5%A4%A7%E5%85%A8.html"/>
    <id>http://idber.github.io/2018/08/12-MySQL主从同步延迟优化大全.html</id>
    <published>2018-08-12T03:21:56.000Z</published>
    <updated>2019-04-22T01:41:16.930Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;MySQL主从延迟主要有以下几种原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只读实例规格配置过小导致延迟&lt;/li&gt;
&lt;li&gt;主库的TPS过高导致只读节点延迟&lt;/li&gt;
&lt;li&gt;主库的DDL(alter、drop、repair、create)导致只读节点延迟&lt;/li&gt;
&lt;li&gt;主库执行大事务导致延迟&lt;/li&gt;
&lt;li&gt;无主键的表进行DML操作导致延迟&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建实验数据库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; create database fafa;
Query OK, 1 row affected (0.01 sec)

mysql&amp;gt; use fafa
Database changed

mysql&amp;gt; create table test(jj int,kk varchar(10));
Query OK, 0 rows affected (0.02 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来我们在主库循环插入数据实验，然后看看进程状态，和同步情况&lt;br&gt;创建procedure&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delimiter //
create procedure fafa()
begin
declare num int;
set num=1;
while num &amp;lt; 8000000 do
insert into test(jj,kk) values(num,&amp;apos;fafa&amp;apos;);
set num=num+1;
end while;
end
//
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后我们要调用这个procedure，才会插入数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;call fafa();  //
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于我没有将delimiter’改回来，所以输入‘；’后并没有执行，还需要//&lt;/p&gt;
&lt;p&gt;注意这里有一个现象，出现了主从很大的延时，这里我们进行逐个排查。总结排查方法&lt;/p&gt;
&lt;h1 id=&quot;只读实例规格配置过小导致延迟&quot;&gt;&lt;a href=&quot;#只读实例规格配置过小导致延迟&quot; class=&quot;headerlink&quot; title=&quot;只读实例规格配置过小导致延迟&quot;&gt;&lt;/a&gt;只读实例规格配置过小导致延迟&lt;/h1&gt;&lt;p&gt;这类延迟场景的出现往往是主节点拥有较大规格的配置，而只读节点却购买了一个最小规格的配置（例如2G内存/200 IOPS）。&lt;br&gt;     原理解析：只读节点的数据为了和主节点保持同步，采用了MySQL binlog复制技术，由一个IO线程和一个SQL线程来完成，IO线程负责将主库的binlog拉取到只读节点，SQL线程负责消费这些binlog日志，这两个线程会消耗掉只读节点的IO资源，所以当只读节点IOPS配置不够的时候，则会导致只读节点的数据出现延迟&lt;/p&gt;
&lt;p&gt;解决办法：&lt;br&gt;      升级只读实例的规格（可以参考主库此时的IOPS的消耗情况），防止由于只读实例的规格较小导致了数据延迟。&lt;br&gt;具体只需只读实例节点的配置大于或者等于主节点的配置即可。&lt;/p&gt;
&lt;h1 id=&quot;主库的TPS过高导致只读节点延迟&quot;&gt;&lt;a href=&quot;#主库的TPS过高导致只读节点延迟&quot; class=&quot;headerlink&quot; title=&quot;主库的TPS过高导致只读节点延迟&quot;&gt;&lt;/a&gt;主库的TPS过高导致只读节点延迟&lt;/h1&gt;&lt;p&gt;原理解析：由于只读节点与主库的同步采用的是单线程同步，而主库的压力是并发多线程写入，这样势必会导致只读节点的数据延迟&lt;br&gt;解决办法：&lt;br&gt;开启只读节点的并行复制是解决这一问题的根本方法，想彻底解决还得排查业务写入压力是否正常，适当对业务进行优化或者拆分，保证主库的TPS不会导致slave出现延迟。&lt;/p&gt;
&lt;p&gt;拓展：&lt;br&gt;在MySQL5.6中，引入了并发复制，这个并发复制是数据库级别的，这意味着一个SQL线程可以处理一个数据库的连续事务，而不用等待其它数据库完成。这个版本的并发复制，可以理解成一个数据库一个SQL线程。其与并发有关的参数如下：&lt;br&gt;slave_parallel_workers           // worker 线程个数&lt;br&gt;slave-checkpoint-group           // 隔多少个事务做一次 checkpoint&lt;br&gt;slave-checkpoint-period          // 隔多长时间做一次 checkpoint&lt;br&gt;slave-pending-jobs-size-max      // 分发给worker的、处于等待状态的event的大小上限&lt;/p&gt;
&lt;p&gt;MySQL5.6基于DATABASE级别的并发复制可以解决业务表放在不同的database下同步延迟的问题，但是在实际生产中大部分表还是放在同一个库中的，这种情况即使设置slave_parallel_workers大于0，也无法进行并发。在高并发的情况下，依然会造成主从复制延迟，所以说MySQL 5.7版本才真正支持“真正”的并行复制功能&lt;/p&gt;
&lt;p&gt;在MySQL5.7中，引入了新的并发复制方法，基于LOGICAL_CLOCK的并发复制，可以支持在一个database中，并发执行relaylog中的事务。&lt;br&gt;相同的二进制日志组在master上提交并行应用到slave节点上，没有跨数据库的限制，并且不需要把数据分割到多个数据库。&lt;br&gt;要实现这个功能，需要在master节点标记binlog中提交的事务哪些是可以并发执行，虽然的MySQL5.6中已经引入binarylog group commit,但是没有将可并发的事务标记出来。&lt;br&gt;可以通过此命令来查看：mysqlbinlog-vvv mysql-bin.000106 | grep -i last_commit&lt;br&gt;在MySQL5.7中，已经解决了主从复制延迟的问题，具体配置参数如下：&lt;br&gt;slave-parallel-type=LOGICAL_CLOCK&lt;br&gt;slave-parallel-workers=16&lt;br&gt;master_info_repository=TABLE&lt;br&gt;relay_log_info_repository=TABLE&lt;br&gt;relay_log_recovery=ON&lt;/p&gt;
&lt;h1 id=&quot;主库的DDL-alter、drop、repair、create-导致只读节点延迟&quot;&gt;&lt;a href=&quot;#主库的DDL-alter、drop、repair、create-导致只读节点延迟&quot; class=&quot;headerlink&quot; title=&quot;主库的DDL(alter、drop、repair、create)导致只读节点延迟&quot;&gt;&lt;/a&gt;主库的DDL(alter、drop、repair、create)导致只读节点延迟&lt;/h1&gt;&lt;p&gt;可能1：只读节点与主库的DDL同步是串行进行的，如果DDL操作在主库执行时间很长，那么同样在备库也会消耗同样的时间，比如在主库对一张500W的表添加一个字段耗费了10分钟，那么在只读节点上也同样会耗费10分钟，所以只读节点会延迟600S，其他常见操作比如：&lt;br&gt;mysql&amp;gt; alter table test add column nn varchar(10);&lt;br&gt;mysql&amp;gt; alter table test add index(jj);&lt;br&gt;    可能2：只读节点上有一个执行时间非常长的的查询正在执行，那么这个查询会堵塞来自主库的DDL，读节点表被锁，直到查询结束为止，进而导致了只读节点的数据延迟。在只读节点上可以通过执行show processlist命令查看连接的状态处于: Waiting for table metadata lock&lt;/p&gt;
&lt;p&gt;解决办法：&lt;br&gt;对于可能1，只能说执行操作之前对可能带来的影响要有考量，对于情况2，可以kill掉只读节点上的大查询进行，就可以恢复只读节点与主节点的数据同步&lt;/p&gt;
&lt;h1 id=&quot;主库执行大事务导致延迟&quot;&gt;&lt;a href=&quot;#主库执行大事务导致延迟&quot; class=&quot;headerlink&quot; title=&quot;主库执行大事务导致延迟&quot;&gt;&lt;/a&gt;主库执行大事务导致延迟&lt;/h1&gt;&lt;p&gt; 主库执行了一条insert … select非常大的插入操作，该操作产生了近几百G的binlog文件传输到只读节点，进而导致了只读节点出现应用binlog延迟。&lt;br&gt;解决办法：&lt;br&gt;     将大事务拆分成为小事务进行排量提交，这样只读节点就可以迅速的完成事务的执行，不会造成数据的延迟。&lt;/p&gt;
&lt;h1 id=&quot;无主键的表进行DML操作导致延迟&quot;&gt;&lt;a href=&quot;#无主键的表进行DML操作导致延迟&quot; class=&quot;headerlink&quot; title=&quot;无主键的表进行DML操作导致延迟&quot;&gt;&lt;/a&gt;无主键的表进行DML操作导致延迟&lt;/h1&gt;&lt;p&gt;mysql&amp;gt; update test set kk=’fafa01’;&lt;br&gt;由于表中没有主键，所以导致了每一个事务条目的更新都是全表扫描，如果表中很很多的数据，则备库执行该更新的事务条目的时候，就会出现很多的全表扫描更新；进一步说明就是，由于表中没有主键，在ROW模式下，每删一条数据都会做全表扫，也就是说一条delete，如果删了10条，会做10次全表扫，所以slave会一直卡住；&lt;br&gt;拓展：&lt;br&gt;       主键对于innodb来说，是非常重要的，每张表的设计的时候，都应该把主键默认的加上，不管你需不需要他，而且主键的设计最好选择自增型的主键，这里也可以略提一下自增主键的好处：&lt;br&gt;a.自增型主键以利于插入性能的提高；&lt;br&gt;b.自增型主键设计(int,bigint)可以降低二级索引的空间，提升二级索引的内存命中率；&lt;br&gt;c.自增型的主键可以减小page的碎片，提升空间和内存的使用。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;MySQL主从延迟主要有以下几种原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只读实例规格配置过小导致延迟&lt;/li&gt;
&lt;li&gt;主库的TPS过高导致只读节点延迟&lt;/li&gt;
&lt;li&gt;主库的DDL(alter、drop、repair、create)导致只读节点延迟&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="主从" scheme="http://idber.github.io/tags/%E4%B8%BB%E4%BB%8E/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Online DDL原理</title>
    <link href="http://idber.github.io/2018/08/12-MySQL%20online%20DDL%E5%8E%9F%E7%90%86.html"/>
    <id>http://idber.github.io/2018/08/12-MySQL online DDL原理.html</id>
    <published>2018-08-12T02:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.929Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;dba的日常工作肯定有一项是ddl变更，ddl变更会锁表，这个可以说是dba心中永远的痛，特别是执行ddl变更，导致库上大量线程处于“Waiting for meta data lock”状态的时候。因此mysql 5.6的online ddl特性是dba们最期待的新特性，这个特性解决了执行ddl锁表的问题，保证了在进行表变更时，不会堵塞线上业务读写，保障在变更时，库依然能正常对外提供访问。网上关于online ddl的文章很多，但涉及原理的很少，都是介绍语法之类的，本文将详细介绍online ddl的原理，知其然，更要知其所以然。&lt;/p&gt;
&lt;h4 id=&quot;ddl实现方式&quot;&gt;&lt;a href=&quot;#ddl实现方式&quot; class=&quot;headerlink&quot; title=&quot;ddl实现方式&quot;&gt;&lt;/a&gt;ddl实现方式&lt;/h4&gt;&lt;p&gt;5.6 online ddl推出以前，执行ddl主要有两种方式copy方式和inplace方式，inplace方式又称为(fast index creation)。相对于copy方式，inplace方式不拷贝数据，因此较快。但是这种方式仅支持添加、删除索引两种方式，而且与copy方式一样需要全程锁表，实用性不是很强。下面以加索引为例，简单介绍这两种方式的实现流程。&lt;/p&gt;
&lt;p&gt;   copy方式&lt;/p&gt;
&lt;p&gt;   (1).新建带索引的临时表&lt;br&gt;   (2).锁原表，禁止DML，允许查询&lt;/p&gt;
&lt;p&gt;   (3).将原表数据拷贝到临时表(无排序，一行一行拷贝)&lt;/p&gt;
&lt;p&gt;   (4).进行rename，升级字典锁，禁止读写&lt;/p&gt;
&lt;p&gt;   (5).完成创建索引操作&lt;/p&gt;
&lt;p&gt;   inplace方式&lt;/p&gt;
&lt;p&gt;   (1).新建索引的数据字典&lt;/p&gt;
&lt;p&gt;   (2).锁表，禁止DML，允许查询&lt;/p&gt;
&lt;p&gt;   (3).读取聚集索引，构造新的索引项，排序并插入新索引&lt;/p&gt;
&lt;p&gt;   (4).等待打开当前表的所有只读事务提交&lt;/p&gt;
&lt;p&gt;   (5).创建索引结束&lt;/p&gt;
&lt;p&gt;online ddl实现&lt;/p&gt;
&lt;p&gt;online方式实质也包含了copy和inplace方式，对于不支持online的ddl操作采用copy方式，比如修改列类型，删除主键，修改字符集等，这些操作都会导致记录格式发生变化，无法通过简单的全量+增量的方式实现online；对于inplace方式，mysql内部以“是否修改记录格式”为基准也分为两类，一类需要重建表(重新组织记录)，比如optimize table、添加索引、添加/删除列、修改列NULL/NOT NULL属性等；另外一类是只需要修改表的元数据，比如删除索引、修改列名、修改列默认值、修改列自增值等。Mysql将这两类方式分别称为rebuild方式和no-rebuild方式。更多关于哪些DDL是否可以inplace的内容可以参考官方文档：&lt;br&gt;    &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.6/en/innodb-create-index-overview.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dev.mysql.com/doc/refman/5.6/en/innodb-create-index-overview.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;online ddl主要包括3个阶段，prepare阶段，ddl执行阶段，commit阶段，rebuild方式比no-rebuild方式实质多了一个ddl执行阶段，prepare阶段和commit阶段类似。下面将主要介绍ddl执行过程中三个阶段的流程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Prepare阶段：

创建新的临时frm文件
持有EXCLUSIVE-MDL锁，禁止读写
根据alter类型，确定执行方式(copy,online-rebuild,online-norebuild)
更新数据字典的内存对象
分配row_log对象记录增量
生成新的临时ibd文件
ddl执行阶段：

降级EXCLUSIVE-MDL锁，允许读写
扫描old_table的聚集索引每一条记录rec
遍历新表的聚集索引和二级索引，逐一处理
根据rec构造对应的索引项
将构造索引项插入sort_buffer块
将sort_buffer块插入新的索引
处理ddl执行过程中产生的增量(仅rebuild类型需要)
commit阶段

升级到EXCLUSIVE-MDL锁，禁止读写
重做最后row_log中最后一部分增量
更新innodb的数据字典表
提交事务(刷事务的redo日志)
修改统计信息
rename临时idb文件，frm文件
变更完成  
关键函数堆栈
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;拷贝数据&lt;/p&gt;
&lt;p&gt;row_merge_build_indexes&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;row_merge_read_clustered_index //拷贝全量                                   

   {

       遍历老表的聚集索引                                            

       row_build //创建一个row

       row_merge_buf_add //将row加入到sort_buffer
       row_merge_insert_index_tuples //插入到新表(聚集索引+二级索引)
   }             

row_log_table_apply  //对于rebuild类型，处理增量                              

{

   row_log_table_apply_insert   //以insert为例

   row_log_table_apply_convert_mrec //将buf项转为tuple

    {

       插入聚集索引 // row_ins_clust_index_entry_low

       插入二级索引 // row_ins_sec_index_entry_low          

    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于添加索引的操作，由于不需要修改聚集索引，因此处理增量调用的是另外一套接口&lt;/p&gt;
&lt;p&gt;row_log_apply-&amp;gt;row_log_apply_ops-&amp;gt;row_log_apply_op-&amp;gt;row_log_apply_op_low-&amp;gt;&lt;/p&gt;
&lt;p&gt;修改表数据字典&lt;/p&gt;
&lt;p&gt;commit_try_norebuild，commit_try_rebuild&lt;/p&gt;
&lt;p&gt; 常见的ddl操作&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;并发DML&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;算法&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;添加/删除索引&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Yes&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Online(no-rebuild)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;全文索引不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;修改default值修改列名修改自增列值添加/删除外键约束&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Yes&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Nothing&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;仅需要修改元数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;添加/删除列交换列顺序修改NULL/NOT NULL修改ROW-FORMAT添加/修改PK Optimize table&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Yes&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Online(rebuild)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;由于记录格式改变，需要重建表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;修改列类型删除PK转换字符集添加全文索引&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;No&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Copy&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;需要锁表，不支持online&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; 若干问题&lt;/p&gt;
&lt;p&gt;1.如何实现数据完整性&lt;br&gt;使用online ddl后，用户心中一定有一个疑问，一边做ddl，一边做dml，表中的数据不会乱吗？这里面关键部件是row_log。row_log记录了ddl变更过程中新产生的dml操作，并在ddl执行的最后将其应用到新的表中，保证数据完整性。&lt;/p&gt;
&lt;p&gt;2.online与数据一致性如何兼得&lt;/p&gt;
&lt;p&gt;实际上，online ddl并非整个过程都是online，在prepare阶段和commit阶段都会持有MDL-Exclusive锁，禁止读写；而在整个ddl执行阶段，允许读写。由于prepare和commit阶段相对于ddl执行阶段时间特别短，因此基本可以认为是全程online的。Prepare阶段和commit阶段的禁止读写，主要是为了保证数据一致性。Prepare阶段需要生成row_log对象和修改内存的字典；Commit阶段，禁止读写后，重做最后一部分增量，然后提交，保证数据一致。&lt;/p&gt;
&lt;p&gt;3.如何实现server层和innodb层一致性&lt;/p&gt;
&lt;p&gt;在prepare阶段，server层会生成一个临时的frm文件，里面包含了新表的格式；innodb层生成了临时的ibd文件(rebuild方式)；在ddl执行阶段，将数据从原表拷贝到临时ibd文件，并且将row_log增量应用到临时ibd文件；在commit阶段，innodb层修改表的数据字典，然后提交；最后innodb层和mysql层面分别重命名frm和idb文件。&lt;/p&gt;
&lt;p&gt; 4.对innodb表做ddl过程中异常了，为啥再次做ddl报#sql-xxx already exists&lt;/p&gt;
&lt;p&gt;这个错误是什么鬼？这个表#sql-xxx实质是做ddl产生的临时表，ddl异常退出后(比如进程被kill，或者机器异常掉电等)，临时文件没有清理。再次执行时，会创建同名的#sql-xxx临时文件，从而导致报错。这里的xxx与table-id强相关，如果是这样，我们把这个讨厌的#sql-xxx临时文件删掉如何呢？再次重做ddl发现还是报同样的错误。这主要原因是，这个临时表信息在innodb的数据字典有残留，通过查询数据字典视图information_schema.innodb_sys_tables，可以发现存在一条#sql-xxx的表记录。&lt;br&gt;深层次原因：ddl整个过程不是原子的，prepare过程中会新建frm文件，ibd文件，并更新数据字典；然后再进行拷贝全量+重放增量操作；最后再rename frm文件，idb文件，并修改数据字典。由于整个过程涉及到server层和innodb层，并不是一个大事务(每次改数据字典都是单独一个事务)，所以执行过程中如果异常终止，就会导致临时表数据字典残留在系统表内。&lt;/p&gt;
&lt;p&gt;影响：虽然临时表信息残留在数据字典内，但不影响用户后续操作。&lt;/p&gt;
&lt;p&gt;解决方法：由于临时表与table-id强相关，如何改变table-id是我们需要做的，但表又不能被修改，table-id改变不了。这就成了一个悖论，要做ddl，需要改变table-id；要改变table-id，又需要通过ddl操作。查看源码后发现，对于online ddl，临时表名依赖于变更表的table-id(比如#sql-ib79，79就是变更表的table-id)，而对于copy类型(非online)的ddl，临时表名则不依赖于table-id(由mysqld进程号+连接会话号产生，比如sql-604d_2，604d是mysqld进程号，2是会话号)。因此，我们通过copy类型的ddl，就可以产生表名不一样的临时表了，也就可以完成ddl任务了。比如：alter table test_log add column c88 int, ALGORITHM=copy;&lt;/p&gt;
&lt;p&gt;其它：ddl异常结束，会导致重做ddl失败。如果做ddl过程中，kill query，这个时候ddl也会退出，但退出前会做好善后工作，清理数据字典，因此再次做ddl不会存在问题。&lt;/p&gt;
&lt;p&gt;参考文档&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://hedengcheng.com/?p=405&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://hedengcheng.com/?p=405&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://hedengcheng.com/?p=421&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://hedengcheng.com/?p=421&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://hedengcheng.com/?p=148&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://hedengcheng.com/?p=148&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;dba的日常工作肯定有一项是ddl变更，ddl变更会锁表，这个可以说是dba心中永远的痛，特别是执行ddl变更，导致库上大量线程处
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="锁" scheme="http://idber.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>数据同步利器-Otter的搭建及使用说明</title>
    <link href="http://idber.github.io/2018/08/11-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%88%A9%E5%99%A8-otter%E7%9A%84%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.html"/>
    <id>http://idber.github.io/2018/08/11-数据同步利器-otter的搭建及使用说明.html</id>
    <published>2018-08-11T02:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.935Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;&lt;/p&gt;&lt;h1&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;li&gt;Otter为阿里云商业化版本 &lt;a href=&quot;https://www.aliyun.com/product/dts?spm=a2c4g.11186623.cloudEssentials.80.srdwr7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数据传输服务DTS&lt;/a&gt;开源版本。&lt;/li&gt;&lt;/p&gt;
&lt;p&gt;Otter目前支持了什么&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 单向同步， mysql/oracle互相同步

2. 双向同步，无冲突变更

3. 文件同步，本地/aranda文件

4. 双A同步，冲突检测&amp;amp;冲突补救

5. 数据迁移，中间表/行记录同步
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;导历史表还需要程序代码实现吗？ 还在用mysql的主从复制吗？ Otter都能为你解决。&lt;/p&gt;
&lt;p&gt;典型的场景是账户信息表和账户交易明细表，更新账户余额后需要登记一条账户明细，并且保证在一个事务里，用户可以通过交易明细表查看交易记录，但是交易明细表的数据量是逐步递增的，用户量多的系统，几个月下来的数据超过千万了，表数据量一多就导致查询和插入变慢，而一开始就对账户明细做分表处理就难于保证强一致性事务，通过otter可以将记录同步导历史表，并且进行分表处理，用户往年的交易记录就可以查询历史表了，而原交易明细表就可以删除一个月甚至几天前的数据；&lt;/p&gt;
&lt;p&gt;实际测试中，otter的同步速度相比于mysql的复制，约有5倍左右的性能提升，这取决于其同步算法的实现. 抛弃了强一致性，得到了性能提升。 &lt;/p&gt;
&lt;p&gt;官方安装文档&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://github.com/alibaba/otter/wiki/Manager_Quickstart

https://github.com/alibaba/otter/wiki/Node_Quickstart

演示视频：http://video.tudou.com/v/XMTc4NjU1MjM4NA==.html
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;环境搭建 &amp;amp; 打包&lt;/h1&gt;&lt;br&gt;&lt;strong&gt;环境搭建：&lt;/strong&gt;&lt;p&gt;&lt;/p&gt;
&lt;ol&gt;&lt;br&gt;&lt;li&gt;进入$otter_home目录&lt;/li&gt;&lt;br&gt;&lt;li&gt;执行：mvn clean install&lt;/li&gt;&lt;br&gt;&lt;li&gt;导入maven项目。如果eclipse下报”Missing artifact com.oracle:ojdbc14:jar:10.2.0.3.0”，修改$otter_home/pom.xml中”${user.dir}/lib/ojdbc14-10.2.0.3.0.jar”为绝对路径，比如”d:/lib/ojdbc14-10.2.0.3.0.jar” &lt;/li&gt;&lt;br&gt;&lt;/ol&gt;&lt;br&gt;&lt;strong&gt;打包：&lt;/strong&gt;&lt;br&gt;&lt;ol&gt;&lt;br&gt;&lt;li&gt;进入$otter_home目录&lt;/li&gt;&lt;br&gt;&lt;li&gt;执行：mvn clean install -Dmaven.test.skip -Denv=release&lt;/li&gt;&lt;br&gt;&lt;li&gt;发布包位置：$otter_home/target&lt;/li&gt;&lt;br&gt;&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;br&gt;&lt;a name=&quot;%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF&quot; class=&quot;anchor&quot; href=&quot;#%E9%A1%B9%E7%9B%AE%E8%83%8C%E6%99%AF&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;项目背景&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;   &amp;nbsp;&amp;nbsp;&amp;nbsp;阿里巴巴B2B公司，因为业务的特性，卖家主要集中在国内，买家主要集中在国外，所以衍生出了杭州和美国异地机房的需求，同时为了提升用户体验，整个机房的架构为双A，两边均可写，由此诞生了otter这样一个产品。 &lt;/p&gt;&lt;br&gt;&lt;p&gt;&lt;br&gt;   &amp;nbsp;&amp;nbsp;&amp;nbsp;otter第一版本可追溯到04~05年，此次外部开源的版本为第4版，开发时间从2011年7月份一直持续到现在，目前阿里巴巴B2B内部的本地/异地机房的同步需求基本全上了otte4。&lt;br&gt;&lt;/p&gt;&lt;br&gt;&lt;strong&gt;目前同步规模：&lt;/strong&gt;&lt;br&gt;&lt;ol&gt;&lt;br&gt;&lt;li&gt;同步数据量6亿&lt;/li&gt;&lt;br&gt;&lt;li&gt;文件同步1.5TB(2000w张图片)&lt;/li&gt;&lt;br&gt;&lt;li&gt;涉及200+个数据库实例之间的同步&lt;/li&gt;&lt;br&gt;&lt;li&gt;80+台机器的集群规模&lt;/li&gt;&lt;br&gt;&lt;/ol&gt;&lt;br&gt;&lt;h1&gt;&lt;br&gt;&lt;a name=&quot;%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D&quot; class=&quot;anchor&quot; href=&quot;#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;项目介绍&lt;/h1&gt;&lt;br&gt;&lt;p&gt;名称：otter [‘ɒtə(r)]&lt;/p&gt;&lt;br&gt;&lt;p&gt;译意： 水獭，数据搬运工&lt;/p&gt;&lt;br&gt;&lt;p&gt;语言： 纯java开发&lt;/p&gt;&lt;br&gt;&lt;p&gt;定位： 基于数据库增量日志解析，准实时同步到本机房或异地机房的mysql/oracle数据库. 一个分布式数据库同步系统&lt;/p&gt;&lt;br&gt;&lt;p&gt; &lt;/p&gt;&lt;br&gt;&lt;h1&gt;&lt;br&gt;&lt;a name=&quot;%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86&quot; class=&quot;anchor&quot; href=&quot;#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;工作原理&lt;/h1&gt;&lt;br&gt;&lt;p&gt;&lt;img width=&quot;848&quot; src=&quot;https://camo.githubusercontent.com/2988fbbc7ddfe94ed027cd71720b1ffa5912a635/687474703a2f2f646c322e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038382f313138392f64343230636131342d326438302d336435352d383038312d6239303833363036613830312e6a7067&quot; height=&quot;303&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;原理描述：&lt;/p&gt;&lt;br&gt;&lt;p&gt;1.   基于Canal开源产品，获取数据库增量日志数据。 什么是Canal,  请&lt;a href=&quot;https://github.com/alibaba/canal&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;2.   典型管理系统架构，manager(web管理)+node(工作节点)&lt;/p&gt;&lt;br&gt;&lt;p&gt;       &amp;nbsp;&amp;nbsp;&amp;nbsp; a.  manager运行时推送同步配置到node节点&lt;/p&gt;&lt;br&gt;&lt;p&gt;       &amp;nbsp;&amp;nbsp;&amp;nbsp; b.  node节点将同步状态反馈到manager上&lt;/p&gt;&lt;br&gt;&lt;p&gt;3.  基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作. &lt;/p&gt;&lt;br&gt;&lt;h3&gt;&lt;br&gt;&lt;a name=&quot;%E4%BB%80%E4%B9%88%E6%98%AFcanal-&quot; class=&quot;anchor&quot; href=&quot;#%E4%BB%80%E4%B9%88%E6%98%AFcanal-&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;什么是canal? &lt;/h3&gt;&lt;br&gt;otter之前开源的一个子项目，开源链接地址：&lt;a href=&quot;http://github.com/alibaba/canal&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://github.com/alibaba/canal&lt;/a&gt;&lt;br&gt;&lt;p&gt; &lt;/p&gt;&lt;br&gt;&lt;h1&gt;&lt;br&gt;&lt;a name=&quot;introduction&quot; class=&quot;anchor&quot; href=&quot;#introduction&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;br&gt;&lt;p&gt;See the page for introduction: &lt;a class=&quot;internal present&quot; href=&quot;https://github.com/alibaba/otter/wiki/Introduction&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introduction&lt;/a&gt;.&lt;/p&gt;&lt;br&gt;&lt;h1&gt;&lt;br&gt;&lt;a name=&quot;quickstart&quot; class=&quot;anchor&quot; href=&quot;#quickstart&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;QuickStart&lt;/h1&gt;&lt;br&gt;&lt;p&gt;See the page for quick start: &lt;a class=&quot;internal present&quot; href=&quot;https://github.com/alibaba/otter/wiki/QuickStart&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QuickStart&lt;/a&gt;.&lt;/p&gt;&lt;br&gt;&lt;p&gt; &lt;/p&gt;&lt;br&gt;&lt;h1&gt;&lt;br&gt;&lt;a name=&quot;adminguide&quot; class=&quot;anchor&quot; href=&quot;#adminguide&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;AdminGuide&lt;/h1&gt;&lt;br&gt;&lt;p&gt;See the page for admin deploy guide : &lt;a class=&quot;internal present&quot; href=&quot;https://github.com/alibaba/otter/wiki/Adminguide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AdminGuide&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt; &lt;/p&gt;&lt;br&gt;&lt;h1&gt;&lt;br&gt;&lt;a name=&quot;%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3&quot; class=&quot;anchor&quot; href=&quot;#%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;相关文档&lt;/h1&gt;&lt;br&gt;&lt;p&gt;See the page for 文档: &lt;a class=&quot;internal present&quot; href=&quot;https://github.com/alibaba/otter/wiki/%E7%9B%B8%E5%85%B3ppt%26pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;相关PPT&amp;amp;PDF&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt; &lt;/p&gt;&lt;br&gt;&lt;h1&gt;&lt;br&gt;&lt;a name=&quot;%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98&quot; class=&quot;anchor&quot; href=&quot;#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;常见问题&lt;/h1&gt;&lt;br&gt;&lt;p&gt;See the page for FAQ: &lt;a class=&quot;internal present&quot; href=&quot;https://github.com/alibaba/otter/wiki/Faq&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FAQ&lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt; &lt;/p&gt;

&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;br&gt;&lt;a name=&quot;%E7%89%88%E6%9C%AC%E7%9B%B8%E5%85%B3-&quot; class=&quot;anchor&quot; href=&quot;#%E7%89%88%E6%9C%AC%E7%9B%B8%E5%85%B3-&quot;&gt;&lt;span class=&quot;octicon octicon-link&quot;&gt;&lt;/span&gt;&lt;/a&gt;版本相关: &lt;/h1&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;1. 建议版本：4.2.15  (otter开源版本从内部演变而来，所以初始版本直接从4.x开始) &lt;/p&gt;&lt;br&gt;&lt;p&gt;2. 下载发布包：&lt;a href=&quot;https://github.com/alibaba/otter/releases&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;download &lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;3. maven依赖 ： 暂无 &lt;/p&gt;

&lt;p&gt;&lt;/p&gt;&lt;h1&gt;相关开源&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;
&lt;ol&gt;&lt;br&gt;&lt;li&gt;阿里巴巴mysql数据库binlog的增量订阅&amp;amp;消费组件：&lt;a href=&quot;http://github.com/alibaba/canal&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://github.com/alibaba/canal&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;li&gt;阿里巴巴去Oracle数据迁移同步工具(目标支持MySQL/DRDS)：&lt;a href=&quot;http://github.com/alibaba/yugong&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://github.com/alibaba/yugong&lt;/a&gt;&lt;/li&gt;&lt;br&gt;&lt;/ol&gt;

&lt;p&gt; &lt;/p&gt;

</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;/p&gt;&lt;h1&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;li&gt;Otter为阿里云商业化版本 &lt;a href=&quot;https://www.aliyun.com/product/dts?spm=a2c4g.11186623.cloudEssentials.80.srdwr
    
    </summary>
    
      <category term="ETL" scheme="http://idber.github.io/categories/ETL/"/>
    
    
      <category term="ETL" scheme="http://idber.github.io/tags/ETL/"/>
    
      <category term="数据仓库" scheme="http://idber.github.io/tags/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Insert锁机制</title>
    <link href="http://idber.github.io/2018/08/03-MySQL%20Insert%E9%94%81%E6%9C%BA%E5%88%B6.html"/>
    <id>http://idber.github.io/2018/08/03-MySQL Insert锁机制.html</id>
    <published>2018-08-03T02:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.929Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;上周遇到一个因insert而引发的死锁问题，其成因比较令人费解。&lt;br&gt;于是想要了解一下insert加锁机制，但是发现网上介绍的文章比较少且零散，挖掘过程比较忙乱。&lt;/p&gt;
&lt;p&gt;本以为只需要系统学习一个较完全的逻辑，但是实际牵扯很多innodb锁相关知识及加锁方式。我好像并没有那么大的能耐，把各种场景的加锁过程一一列举并加之分析；亦没有太多的精力验证网上的言论的准确性。&lt;/p&gt;
&lt;p&gt;只好根据现在了解的内容，参考官方文档，说说自己当前的理解。&lt;br&gt;本文仅供参考，如有误导，概不负责。&lt;/p&gt;
&lt;h2 id=&quot;二、现场状态&quot;&gt;&lt;a href=&quot;#二、现场状态&quot; class=&quot;headerlink&quot; title=&quot;二、现场状态&quot;&gt;&lt;/a&gt;二、现场状态&lt;/h2&gt;&lt;p&gt;不同的MySQL版本，不同的参数设置，都可能对加锁过程有影响。&lt;br&gt;分析加锁机制还是应当尽可能多地列举一下关键参数，例如：当前mysql版本、事务隔离级别等。&lt;br&gt;如下，仅仅只列出个别比较重要的参数。&lt;/p&gt;
&lt;h3 id=&quot;1-数据库版本&quot;&gt;&lt;a href=&quot;#1-数据库版本&quot; class=&quot;headerlink&quot; title=&quot;1.数据库版本&quot;&gt;&lt;/a&gt;1.数据库版本&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select version();
+------------+
| version()  |
+------------+
| 5.6.26-log |
+------------+
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-数据库引擎&quot;&gt;&lt;a href=&quot;#2-数据库引擎&quot; class=&quot;headerlink&quot; title=&quot;2. 数据库引擎&quot;&gt;&lt;/a&gt;2. 数据库引擎&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like &amp;apos;%engine%&amp;apos;;
+----------------------------+--------+
| Variable_name              | Value  |
+----------------------------+--------+
| default_storage_engine     | InnoDB |
| default_tmp_storage_engine | InnoDB |
| storage_engine             | InnoDB |
+----------------------------+--------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注：InnoDB支持事务，Myisam不支持事务；InnoDB支持行锁和表锁；Myisam不支持行锁。&lt;/p&gt;
&lt;h3 id=&quot;3-事务隔离级别&quot;&gt;&lt;a href=&quot;#3-事务隔离级别&quot; class=&quot;headerlink&quot; title=&quot;3. 事务隔离级别&quot;&gt;&lt;/a&gt;3. 事务隔离级别&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select @@global.tx_isolation, @@session.tx_isolation, @@tx_isolation;
+-----------------------+------------------------+-----------------+
| @@global.tx_isolation | @@session.tx_isolation | @@tx_isolation  |
+-----------------------+------------------------+-----------------+
| REPEATABLE-READ       | REPEATABLE-READ        | REPEATABLE-READ |
+-----------------------+------------------------+-----------------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注：几种事务隔离级别：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;4-查看gap锁开启状态&quot;&gt;&lt;a href=&quot;#4-查看gap锁开启状态&quot; class=&quot;headerlink&quot; title=&quot;4. 查看gap锁开启状态&quot;&gt;&lt;/a&gt;4. 查看gap锁开启状态&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like &amp;apos;innodb_locks_unsafe_for_binlog&amp;apos;;
+--------------------------------+-------+
| Variable_name                  | Value |
+--------------------------------+-------+
| innodb_locks_unsafe_for_binlog | OFF   |
+--------------------------------+-------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;innodb_locks_unsafe_for_binlog：默认值为0，即启用gap lock。&lt;br&gt;最主要的作用就是控制innodb是否对gap加锁。&lt;br&gt;但是，这一设置变更并不影响外键和唯一索引（含主键）对gap进行加锁的需要。&lt;br&gt;开启innodb_locks_unsafe_for_binlog的REPEATABLE-READ事务隔离级别，很大程度上已经蜕变成了READ-COMMITTED。&lt;/p&gt;
&lt;p&gt;参见官方文档[^1]：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By default, the value of innodb_locks_unsafe_for_binlog is 0 (disabled), which means that gap locking is enabled: InnoDB uses next-key locks for searches and index scans. To enable the variable, set it to 1. This causes gap locking to be disabled: InnoDB uses only index-record locks for searches and index scans.&lt;br&gt;Enabling innodb_locks_unsafe_for_binlog does not disable the use of gap locking for foreign-key constraint checking or duplicate-key checking.&lt;br&gt;The effect of enabling innodb_locks_unsafe_for_binlog is similar to but not identical to setting the transaction isolation level to READ COMMITTED.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;5-查看自增锁模式&quot;&gt;&lt;a href=&quot;#5-查看自增锁模式&quot; class=&quot;headerlink&quot; title=&quot;5. 查看自增锁模式&quot;&gt;&lt;/a&gt;5. 查看自增锁模式&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like &amp;apos;innodb_autoinc_lock_mode&amp;apos;;
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| innodb_autoinc_lock_mode | 1     |
+--------------------------+-------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;innodb_autoinc_lock_mode有3种配置模式：0、1、2，分别对应”传统模式”, “连续模式”, “交错模式”。[^8]&lt;br&gt;传统模式：涉及auto-increment列的插入语句加的表级AUTO-INC锁，只有插入执行结束后才会释放锁。这是一种兼容MySQL 5.1之前版本的策略。&lt;br&gt;连续模式：可以事先确定插入行数的语句(包括单行和多行插入)，分配连续的确定的auto-increment值；对于插入行数不确定的插入语句，仍加表锁。这种模式下，事务回滚，auto-increment值不会回滚，换句话说，自增列内容会不连续。&lt;br&gt;交错模式：同一时刻多条SQL语句产生交错的auto-increment值。&lt;/p&gt;
&lt;p&gt;由于insert语句常常涉及自增列的加锁过程，会涉及到AUTO-INC Locks加锁过程。&lt;br&gt;为了分步了解insert加锁过程，本文暂不讨论任何涉及自增列的加锁逻辑。&lt;br&gt;这一参数设置相关内容可能会出现在我的下一篇文章里。&lt;/p&gt;
&lt;p&gt;相关的参数配置越详情越好。&lt;/p&gt;
&lt;h2 id=&quot;三、InnoDB锁类型-2&quot;&gt;&lt;a href=&quot;#三、InnoDB锁类型-2&quot; class=&quot;headerlink&quot; title=&quot;三、InnoDB锁类型[^2]&quot;&gt;&lt;/a&gt;三、InnoDB锁类型[^2]&lt;/h2&gt;&lt;h4 id=&quot;1-基本锁&quot;&gt;&lt;a href=&quot;#1-基本锁&quot; class=&quot;headerlink&quot; title=&quot;1. 基本锁&quot;&gt;&lt;/a&gt;1. 基本锁&lt;/h4&gt;&lt;p&gt;基本锁：共享锁(Shared Locks：S锁)与排他锁(Exclusive Locks：X锁)&lt;/p&gt;
&lt;p&gt;mysql允许拿到S锁的事务读一行，允许拿到X锁的事务更新或删除一行。&lt;br&gt;加了S锁的记录，允许其他事务再加S锁，不允许其他事务再加X锁；&lt;br&gt;加了X锁的记录，不允许其他事务再加S锁或者X锁。&lt;/p&gt;
&lt;p&gt;mysql对外提供加这两种锁的语法如下：&lt;br&gt;加S锁：select…lock in share mode&lt;br&gt;加X锁：select…for update&lt;/p&gt;
&lt;h4 id=&quot;2-意向锁-Intention-Locks&quot;&gt;&lt;a href=&quot;#2-意向锁-Intention-Locks&quot; class=&quot;headerlink&quot; title=&quot;2. 意向锁(Intention Locks)&quot;&gt;&lt;/a&gt;2. 意向锁(Intention Locks)&lt;/h4&gt;&lt;p&gt;InnoDB为了支持多粒度(表锁与行锁)的锁并存，引入意向锁。&lt;br&gt;意向锁是表级锁，可分为意向共享锁(IS锁)和意向排他锁(IX锁)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;InnoDB supports multiple granularity locking which permits coexistence of row-level locks and locks on entire tables. To make locking at multiple granularity levels practical, additional types of locks called intention locks are used. Intention locks are table-level locks in InnoDB that indicate which type of lock (shared or exclusive) a transaction will require later for a row in that table. There are two types of intention locks used in InnoDB (assume that transaction T has requested a lock of the indicated type on table t):&lt;br&gt;Intention shared (IS): Transaction T intends to set S locks on individual rows in table t.&lt;br&gt;Intention exclusive (IX): Transaction T intends to set X locks on those rows.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事务在请求S锁和X锁前，需要先获得对应的IS、IX锁。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Before a transaction can acquire an S lock on a row in table t, it must first acquire an IS or stronger lock on t. Before a transaction can acquire an X lock on a row, it must first acquire an IX lock on t.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意向锁产生的主要目的是为了处理行锁和表锁之间的冲突，用于表明“某个事务正在某一行上持有了锁，或者准备去持有锁”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The main purpose of IX and IS locks is to show that someone is locking a row, or going to lock a row in the table.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;共享锁、排他锁与意向锁的兼容矩阵如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;X&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;IX&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;S&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;IS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;X&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;冲突&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;冲突&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;冲突&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;冲突&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;IX&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;冲突&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;冲突&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;S&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;冲突&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;冲突&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;IS&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;冲突&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;思考&lt;/p&gt;
&lt;p&gt;从官方文档字面意思上看意向锁是表级锁，但是大牛不认为“Intention lock 是表级锁”[^5]?&lt;br&gt;另外，由于意向锁主要用于解决行锁与表锁间冲突问题，鉴于平时表级操作特别少，在分析加锁过程是否可以不用过多考虑意向锁的问题?&lt;/p&gt;
&lt;h4 id=&quot;3-行锁&quot;&gt;&lt;a href=&quot;#3-行锁&quot; class=&quot;headerlink&quot; title=&quot;3. 行锁&quot;&gt;&lt;/a&gt;3. 行锁&lt;/h4&gt;&lt;p&gt;记录锁(Record Locks)&lt;/p&gt;
&lt;p&gt;记录锁, 仅仅锁住索引记录的一行。&lt;br&gt;单条索引记录上加锁，record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加X锁，这个类似于表锁，但原理上和表锁应该是完全不同的。&lt;/p&gt;
&lt;p&gt;参见官方文档[^3]：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the table has no PRIMARY KEY or suitable UNIQUE index, InnoDB internally generates a hidden clustered index on a synthetic column containing row ID values. The rows are ordered by the ID that InnoDB assigns to the rows in such a table. The row ID is a 6-byte field that increases monotonically as new rows are inserted. Thus, the rows ordered by the row ID are physically in insertion order.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;间隙锁(Gap Locks)&lt;/p&gt;
&lt;p&gt;区间锁, 仅仅锁住一个索引区间(开区间)。&lt;br&gt;在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。&lt;/p&gt;
&lt;p&gt;next-key锁(Next-Key Locks)&lt;/p&gt;
&lt;p&gt;record lock + gap lock, 左开右闭区间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record.&lt;br&gt;By default, InnoDB operates in REPEATABLE READ transaction isolation level and with the innodb_locks_unsafe_for_binlog system variable disabled. In this case, InnoDB uses next-key locks for searches and index scans, which prevents phantom rows。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;默认情况下，innodb使用next-key locks来锁定记录。&lt;br&gt;但当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。&lt;/p&gt;
&lt;p&gt;插入意向锁(Insert Intention Locks)&lt;/p&gt;
&lt;p&gt;Gap Lock中存在一种插入意向锁（Insert Intention Lock），在insert操作时产生。在多事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待。&lt;br&gt;假设有一个记录索引包含键值4和7，不同的事务分别插入5和6，每个事务都会产生一个加在4-7之间的插入意向锁，获取在插入行上的排它锁，但是不会被互相锁住，因为数据行并不冲突。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An insert intention lock is a type of gap lock set by INSERT operations prior to row insertion. This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to insert values of 5 and 6, respectively, each lock the gap between 4 and 7 with insert intention locks prior to obtaining the exclusive lock on the inserted row, but do not block each other because the rows are nonconflicting.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注：插入意向锁并非意向锁，而是一种特殊的间隙锁。&lt;/p&gt;
&lt;h4 id=&quot;4-行锁的兼容矩阵&quot;&gt;&lt;a href=&quot;#4-行锁的兼容矩阵&quot; class=&quot;headerlink&quot; title=&quot;4. 行锁的兼容矩阵&quot;&gt;&lt;/a&gt;4. 行锁的兼容矩阵&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Gap&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Insert Intention&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Record&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Next-Key&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Gap&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Insert Intention&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;冲突&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;冲突&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Record&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;冲突&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;冲突&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Next-Key&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;兼容&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;冲突&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;冲突&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;表注：横向是已经持有的锁，纵向是正在请求的锁。&lt;/p&gt;
&lt;p&gt;由于S锁和S锁是完全兼容的，因此在判别兼容性时只考虑持有的锁与请求的锁是这三种组合情形：X、S和S、X和X、X。&lt;br&gt;另外，需要提醒注意的是进行兼容判断也只是针对于加锁涉及的行有交集的情形。&lt;/p&gt;
&lt;p&gt;分析兼容矩阵可以得出如下几个结论：&lt;/p&gt;
&lt;p&gt;INSERT操作之间不会有冲突。&lt;br&gt;GAP,Next-Key会阻止Insert。&lt;br&gt;GAP和Record,Next-Key不会冲突&lt;br&gt;Record和Record、Next-Key之间相互冲突。&lt;br&gt;已有的Insert锁不阻止任何准备加的锁。&lt;/p&gt;
&lt;h4 id=&quot;5-自增锁-AUTO-INC-Locks&quot;&gt;&lt;a href=&quot;#5-自增锁-AUTO-INC-Locks&quot; class=&quot;headerlink&quot; title=&quot;5. 自增锁(AUTO-INC Locks)&quot;&gt;&lt;/a&gt;5. 自增锁(AUTO-INC Locks)&lt;/h4&gt;&lt;p&gt;AUTO-INC锁是一种特殊的表级锁，发生涉及AUTO_INCREMENT列的事务性插入操作时产生。&lt;/p&gt;
&lt;p&gt;官方解释如下[^3]：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An AUTO-INC lock is a special table-level lock taken by transactions inserting into tables with AUTO_INCREMENT columns. In the simplest case, if one transaction is inserting values into the table, any other transactions must wait to do their own inserts into that table, so that rows inserted by the first transaction receive consecutive primary key values.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;四、insert加锁过程&quot;&gt;&lt;a href=&quot;#四、insert加锁过程&quot; class=&quot;headerlink&quot; title=&quot;四、insert加锁过程&quot;&gt;&lt;/a&gt;四、insert加锁过程&lt;/h2&gt;&lt;p&gt;官方文档[^6]对于insert加锁的描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;INSERT sets an exclusive lock on the inserted row. This lock is an index-record lock, not a next-key lock (that is, there is no gap lock) and does not prevent other sessions from inserting into the gap before the inserted row.&lt;br&gt;Prior to inserting the row, a type of gap lock called an insert intention gap lock is set. This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to insert values of 5 and 6 each lock the gap between 4 and 7 with insert intention locks prior to obtaining the exclusive lock on the inserted row, but do not block each other because the rows are nonconflicting.&lt;br&gt;If a duplicate-key error occurs, a shared lock on the duplicate index record is set. This use of a shared lock can result in deadlock should there be multiple sessions trying to insert the same row if another session already has an exclusive lock.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的insert会在insert的行对应的索引记录上加一个排它锁，这是一个record lock，并没有gap，所以并不会阻塞其他session在gap间隙里插入记录。&lt;/p&gt;
&lt;p&gt;不过在insert操作之前，还会加一种锁，官方文档称它为insertion intention gap lock，也就是意向的gap锁。这个意向gap锁的作用就是预示着当多事务并发插入相同的gap空隙时，只要插入的记录不是gap间隙中的相同位置，则无需等待其他session就可完成，这样就使得insert操作无须加真正的gap lock。&lt;br&gt;假设有一个记录索引包含键值4和7，不同的事务分别插入5和6，每个事务都会产生一个加在4-7之间的插入意向锁，获取在插入行上的排它锁，但是不会被互相锁住，因为数据行并不冲突。&lt;/p&gt;
&lt;p&gt;假设发生了一个唯一键冲突错误，那么将会在重复的索引记录上加读锁。当有多个session同时插入相同的行记录时，如果另外一个session已经获得该行的排它锁，那么将会导致死锁。&lt;/p&gt;
&lt;p&gt;思考：Insert Intention Locks作用&lt;/p&gt;
&lt;p&gt;Insert Intention Locks的引入，我理解是为了提高数据插入的并发能力。&lt;br&gt;如果没有Insert Intention Locks的话，可能就需要使用Gap Locks来代替。&lt;/p&gt;
&lt;h2 id=&quot;五、insert死锁场景分析&quot;&gt;&lt;a href=&quot;#五、insert死锁场景分析&quot; class=&quot;headerlink&quot; title=&quot;五、insert死锁场景分析&quot;&gt;&lt;/a&gt;五、insert死锁场景分析&lt;/h2&gt;&lt;p&gt;接下来，带大家看几个与insert相关的死锁场景。&lt;/p&gt;
&lt;h4 id=&quot;1-duplicate-key-error引发的死锁&quot;&gt;&lt;a href=&quot;#1-duplicate-key-error引发的死锁&quot; class=&quot;headerlink&quot; title=&quot;1. duplicate key error引发的死锁&quot;&gt;&lt;/a&gt;1. duplicate key error引发的死锁&lt;/h4&gt;&lt;p&gt;这个场景主要发生在两个以上的事务同时进行唯一键值相同的记录插入操作。&lt;/p&gt;
&lt;p&gt;表结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE `aa` (
  `id` int(10) unsigned NOT NULL COMMENT &amp;apos;主键&amp;apos;,
  `name` varchar(20) NOT NULL DEFAULT &amp;apos;&amp;apos; COMMENT &amp;apos;姓名&amp;apos;,
  `age` int(11) NOT NULL DEFAULT &amp;apos;0&amp;apos; COMMENT &amp;apos;年龄&amp;apos;,
  `stage` int(11) NOT NULL DEFAULT &amp;apos;0&amp;apos; COMMENT &amp;apos;关卡数&amp;apos;,
  PRIMARY KEY (`id`),
  UNIQUE KEY `udx_name` (`name`),
  KEY `idx_stage` (`stage`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;表数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from aa;
+----+------+-----+-------+
| id | name | age | stage |
+----+------+-----+-------+
|  1 | yst  |  11 |     8 |
|  2 | dxj  |   7 |     4 |
|  3 | lb   |  13 |     7 |
|  4 | zsq  |   5 |     7 |
|  5 | lxr  |  13 |     4 |
+----+------+-----+-------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事务执行时序表&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;T1(36727)&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;T2(36728)&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;T3(36729)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;begin;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;begin;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;begin;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;insert into aa values(6, ‘test’, 12, 3);&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;insert into aa values(6, ‘test’, 12, 3);&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;insert into aa values(6, ‘test’, 12, 3);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;rollback;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Query OK, 1 row affected (13.10 sec)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果T1未rollback，而是commit的话，T2和T3会报唯一键冲突：ERROR 1062 (23000): Duplicate entry ‘6’ for key ‘PRIMARY’&lt;/p&gt;
&lt;p&gt;事务锁占用情况&lt;/p&gt;
&lt;p&gt;T1 rollback前，各事务锁占用情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from information_schema.innodb_locks;
+--------------+-------------+-----------+-----------+-------------+------------+------------+-----------+----------+-----------+
| lock_id      | lock_trx_id | lock_mode | lock_type | lock_table  | lock_index | lock_space | lock_page | lock_rec | lock_data |
+--------------+-------------+-----------+-----------+-------------+------------+------------+-----------+----------+-----------+
| 36729:24:3:7 | 36729       | S         | RECORD    | `test`.`aa` | PRIMARY    |         24 |         3 |        7 | 6         |
| 36727:24:3:7 | 36727       | X         | RECORD    | `test`.`aa` | PRIMARY    |         24 |         3 |        7 | 6         |
| 36728:24:3:7 | 36728       | S         | RECORD    | `test`.`aa` | PRIMARY    |         24 |         3 |        7 | 6         |
+--------------+-------------+-----------+-----------+-------------+------------+------------+-----------+----------+-----------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注：mysql有自己的一套规则来决定T2与T3哪个进行回滚，本文不做讨论。&lt;/p&gt;
&lt;p&gt;死锁日志&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;------------------------
LATEST DETECTED DEADLOCK
------------------------
2016-07-21 19:34:23 700000a3f000
*** (1) TRANSACTION:
TRANSACTION 36728, ACTIVE 199 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 4 lock struct(s), heap size 1184, 2 row lock(s)
MySQL thread id 13, OS thread handle 0x700000b0b000, query id 590 localhost root update
insert into aa values(6, &amp;apos;test&amp;apos;, 12, 3)
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 24 page no 3 n bits 80 index `PRIMARY` of table `test`.`aa` trx id 36728 lock_mode X insert intention waiting
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;
*** (2) TRANSACTION:
TRANSACTION 36729, ACTIVE 196 sec inserting
mysql tables in use 1, locked 1
4 lock struct(s), heap size 1184, 2 row lock(s)
MySQL thread id 14, OS thread handle 0x700000a3f000, query id 591 localhost root update
insert into aa values(6, &amp;apos;test&amp;apos;, 12, 3)
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 24 page no 3 n bits 80 index `PRIMARY` of table `test`.`aa` trx id 36729 lock mode S
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;
*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 24 page no 3 n bits 80 index `PRIMARY` of table `test`.`aa` trx id 36729 lock_mode X insert intention waiting
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;
*** WE ROLL BACK TRANSACTION (2)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;死锁成因&lt;/p&gt;
&lt;p&gt;事务T1成功插入记录，并获得索引id=6上的排他记录锁(LOCK_X | LOCK_REC_NOT_GAP)。&lt;br&gt;紧接着事务T2、T3也开始插入记录，请求排他插入意向锁(LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION)；但由于发生重复唯一键冲突，各自请求的排他记录锁(LOCK_X | LOCK_REC_NOT_GAP)转成共享记录锁(LOCK_S | LOCK_REC_NOT_GAP)。&lt;/p&gt;
&lt;p&gt;T1回滚释放索引id=6上的排他记录锁(LOCK_X | LOCK_REC_NOT_GAP)，T2和T3都要请求索引id=6上的排他记录锁(LOCK_X | LOCK_REC_NOT_GAP)。&lt;br&gt;由于X锁与S锁互斥，T2和T3都等待对方释放S锁。&lt;br&gt;于是，死锁便产生了。&lt;/p&gt;
&lt;p&gt;如果此场景下，只有两个事务T1与T2或者T1与T3，则不会引发如上死锁情况产生。&lt;/p&gt;
&lt;p&gt;思考&lt;/p&gt;
&lt;p&gt;为什么发现重复主键冲突的时候，要将事务请求的X锁转成S锁？&lt;br&gt;(比较牵强的)个人理解，跟插入意向锁类型，也是为了提高插入的并发效率。&lt;/p&gt;
&lt;p&gt;插入前请求插入意向锁的作用？&lt;br&gt;个人认为，通过兼容矩阵来分析，Insert Intention Locks是为了减少插入时的锁冲突。&lt;/p&gt;
&lt;h4 id=&quot;2-GAP与Insert-Intention冲突引发的死锁&quot;&gt;&lt;a href=&quot;#2-GAP与Insert-Intention冲突引发的死锁&quot; class=&quot;headerlink&quot; title=&quot;2. GAP与Insert Intention冲突引发的死锁&quot;&gt;&lt;/a&gt;2. GAP与Insert Intention冲突引发的死锁&lt;/h4&gt;&lt;p&gt;表结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE `t` (
  `a` int(11) NOT NULL,
  `b` int(11) DEFAULT NULL,
  PRIMARY KEY (`a`),
  KEY `idx_b` (`b`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;表数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from t;
+----+------+
| a  | b    |
+----+------+
|  1 |    2 |
|  2 |    3 |
|  3 |    4 |
| 11 |   22 |
+----+------+
事务执行时序表

T1(36831)                T2(36832)
begin;                    begin;
select * from t where b = 6 for update;
                         select * from t where b = 8 for update;
insert into t values (4,5);     
                         insert into t values (4,5);
                         ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
Query OK, 1 row affected (5.45 sec)     
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事务锁占用情况&lt;/p&gt;
&lt;p&gt;T2 insert前，各事务锁占用情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from information_schema.innodb_locks;
+--------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+
| lock_id      | lock_trx_id | lock_mode | lock_type | lock_table | lock_index | lock_space | lock_page | lock_rec | lock_data |
+--------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+
| 36831:25:4:5 | 36831       | X,GAP     | RECORD    | `test`.`t` | idx_b      |         25 |         4 |        5 | 22, 11    |
| 36832:25:4:5 | 36832       | X,GAP     | RECORD    | `test`.`t` | idx_b      |         25 |         4 |        5 | 22, 11    |
+--------------+-------------+-----------+-----------+------------+------------+------------+-----------+----------+-----------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;死锁日志&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;------------------------
LATEST DETECTED DEADLOCK
------------------------
2016-07-28 12:28:34 700000a3f000
*** (1) TRANSACTION:
TRANSACTION 36831, ACTIVE 17 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 4 lock struct(s), heap size 1184, 3 row lock(s), undo log entries 1
MySQL thread id 38, OS thread handle 0x700000b0b000, query id 953 localhost root update
insert into t values (4,5)
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 25 page no 4 n bits 72 index `idx_b` of table `test`.`t` trx id 36831 lock_mode X locks gap before rec insert intention waiting
Record lock, heap no 5 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 4; hex 80000016; asc     ;;
 1: len 4; hex 8000000b; asc     ;;
*** (2) TRANSACTION:
TRANSACTION 36832, ACTIVE 13 sec inserting
mysql tables in use 1, locked 1
3 lock struct(s), heap size 360, 2 row lock(s)
MySQL thread id 39, OS thread handle 0x700000a3f000, query id 954 localhost root update
insert into t values (4,5)
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 25 page no 4 n bits 72 index `idx_b` of table `test`.`t` trx id 36832 lock_mode X locks gap before rec
Record lock, heap no 5 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 4; hex 80000016; asc     ;;
 1: len 4; hex 8000000b; asc     ;;
*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 25 page no 3 n bits 72 index `PRIMARY` of table `test`.`t` trx id 36832 lock mode S locks rec but not gap waiting
Record lock, heap no 5 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 4; hex 80000004; asc     ;;
 1: len 6; hex 000000008fdf; asc       ;;
 2: len 7; hex 8d000001d00110; asc        ;;
 3: len 4; hex 80000005; asc     ;;
*** WE ROLL BACK TRANSACTION (2)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;死锁成因&lt;/p&gt;
&lt;p&gt;事务T1执行查询语句，在索引b=6上加排他Next-key锁(LOCK_X | LOCK_ORDINARY)，会锁住idx_b索引范围(4, 22)。&lt;br&gt;事务T2执行查询语句，在索引b=8上加排他Next-key锁(LOCK_X | LOCK_ORDINARY)，会锁住idx_b索引范围(4, 22)。由于请求的GAP与已持有的GAP是兼容的，因此，事务T2在idx_b索引范围(4, 22)也能加锁成功。&lt;/p&gt;
&lt;p&gt;事务T1执行插入语句，会先加排他Insert Intention锁。由于请求的Insert Intention锁与已有的GAP锁不兼容，则事务T1等待T2释放GAP锁。&lt;br&gt;事务T2执行插入语句，也会等待T1释放GAP锁。&lt;br&gt;于是，死锁便产生了。&lt;/p&gt;
&lt;p&gt;注：LOCK_ORDINARY拥有LOCK_GAP一部分特性。&lt;/p&gt;
&lt;p&gt;思考：Insert Intention锁在加哪级索引上？&lt;/p&gt;
&lt;p&gt;这个排他锁加在PK上，还是二级索引上？&lt;/p&gt;
&lt;h2 id=&quot;六、课后思考&quot;&gt;&lt;a href=&quot;#六、课后思考&quot; class=&quot;headerlink&quot; title=&quot;六、课后思考&quot;&gt;&lt;/a&gt;六、课后思考&lt;/h2&gt;&lt;p&gt;无主键的加锁过程&lt;br&gt;无PK时，会创建一个隐式聚簇索引。加锁在这个隐式聚簇索引会有什么不同？&lt;/p&gt;
&lt;p&gt;复合索引加锁过程&lt;/p&gt;
&lt;p&gt;多条件(where condition)加锁过程&lt;br&gt;隐式锁与显式锁，隐式锁什么情况下会转换成显式锁&lt;/p&gt;
&lt;p&gt;如果插入意向锁不阻止任何锁，这个锁还有必要存在吗？&lt;br&gt;目前看到的作用是，通过加锁的方式来唤醒等待线程。&lt;br&gt;但这并不意味着，被唤醒后可以直接做插入操作了。需要再次判断是否有锁冲突。&lt;/p&gt;
&lt;h2 id=&quot;七、补充知识&quot;&gt;&lt;a href=&quot;#七、补充知识&quot; class=&quot;headerlink&quot; title=&quot;七、补充知识&quot;&gt;&lt;/a&gt;七、补充知识&lt;/h2&gt;&lt;h4 id=&quot;1-查看事务隔离级别&quot;&gt;&lt;a href=&quot;#1-查看事务隔离级别&quot; class=&quot;headerlink&quot; title=&quot;1. 查看事务隔离级别&quot;&gt;&lt;/a&gt;1. 查看事务隔离级别&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;SELECT @@global.tx_isolation;
SELECT @@session.tx_isolation;
SELECT @@tx_isolation;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;2-设置隔离级别&quot;&gt;&lt;a href=&quot;#2-设置隔离级别&quot; class=&quot;headerlink&quot; title=&quot;2. 设置隔离级别&quot;&gt;&lt;/a&gt;2. 设置隔离级别&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如：set session transaction isolation level read uncommitted;&lt;/p&gt;
&lt;h4 id=&quot;3-查看auto-increment机制模式&quot;&gt;&lt;a href=&quot;#3-查看auto-increment机制模式&quot; class=&quot;headerlink&quot; title=&quot;3. 查看auto_increment机制模式&quot;&gt;&lt;/a&gt;3. 查看auto_increment机制模式&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;show variables like ‘innodb_autoinc_lock_mode’;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;4-查看表状态&quot;&gt;&lt;a href=&quot;#4-查看表状态&quot; class=&quot;headerlink&quot; title=&quot;4. 查看表状态&quot;&gt;&lt;/a&gt;4. 查看表状态&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;show table status like ‘plan_branch’\G;
show table status from test like ‘plan_branch’\G;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;5-查看SQL性能&quot;&gt;&lt;a href=&quot;#5-查看SQL性能&quot; class=&quot;headerlink&quot; title=&quot;5. 查看SQL性能&quot;&gt;&lt;/a&gt;5. 查看SQL性能&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;show profiles
show profile for query 1;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;6-查看当前最新事务ID&quot;&gt;&lt;a href=&quot;#6-查看当前最新事务ID&quot; class=&quot;headerlink&quot; title=&quot;6. 查看当前最新事务ID&quot;&gt;&lt;/a&gt;6. 查看当前最新事务ID&lt;/h4&gt;&lt;p&gt;每开启一个新事务，记录当前最新事务的id，可用于后续死锁分析。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show engine innodb status\G;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;7-查看事务锁等待状态情况&quot;&gt;&lt;a href=&quot;#7-查看事务锁等待状态情况&quot; class=&quot;headerlink&quot; title=&quot;7. 查看事务锁等待状态情况&quot;&gt;&lt;/a&gt;7. 查看事务锁等待状态情况&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;select from information_schema.innodb_locks;
select from information_schema.innodb_lock_waits;
select * from information_schema.innodb_trx;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;8-查看innodb状态-包含最近的死锁日志&quot;&gt;&lt;a href=&quot;#8-查看innodb状态-包含最近的死锁日志&quot; class=&quot;headerlink&quot; title=&quot;8. 查看innodb状态(包含最近的死锁日志)&quot;&gt;&lt;/a&gt;8. 查看innodb状态(包含最近的死锁日志)&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;show engine innodb status;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;八、参考文档&quot;&gt;&lt;a href=&quot;#八、参考文档&quot; class=&quot;headerlink&quot; title=&quot;八、参考文档&quot;&gt;&lt;/a&gt;八、参考文档&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;[^1]: InnoDB Startup Options and System Variables
[^2]: InnoDB Locking
[^3]: Clustered and Secondary Indexes
[^4]: [MySQL] gap lock/next-key lock浅析
[^5]: Intention Lock是否表级锁
[^6]: Locks Set by Different SQL Statements in InnoDB
[^8]: AUTO_INCREMENT lock Handing in InnoDB
[^9]: 深入理解innodb的锁(record,gap,Next-Key lock)
[^11]: The INFORMATION_SCHEMA INNODB_LOCKS Table
[^12]: The INFORMATION_SCHEMA INNODB_TRX Table
[^13]: mysql innodb插入意向锁    
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;上周遇到一个因insert而引发的死锁问题，其成因比较令人费解。&lt;br&gt;于是想要了解一下insert加锁机制，但是
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="锁" scheme="http://idber.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>关于BINARY的使用</title>
    <link href="http://idber.github.io/2017/11/20-%E5%85%B3%E4%BA%8EBINARY%E7%9A%84%E4%BD%BF%E7%94%A8.html"/>
    <id>http://idber.github.io/2017/11/20-关于BINARY的使用.html</id>
    <published>2017-11-20T02:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.935Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;数据库版本:&lt;br&gt;MySQL 5.6.26&lt;/p&gt;
&lt;p&gt;线上某业务表为了区分大小写，使用BINARY关键字，正常来说使用这个关键字是走索引的，测试过程如下：&lt;/p&gt;
&lt;p&gt;创建测试表，插入数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop table  if EXISTS student;

CREATE TABLE `student` (
  `id` int(11) PRIMARY key auto_increment,
  `name` varchar(20) DEFAULT NULL,
key `idx_name`(`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ; 

insert into `student` ( `id`, `name`) values ( &amp;apos;1&amp;apos;, &amp;apos;michael&amp;apos;);
insert into `student` ( `id`, `name`) values ( &amp;apos;2&amp;apos;, &amp;apos;lucy&amp;apos;);
insert into `student` ( `id`, `name`) values ( &amp;apos;3&amp;apos;, &amp;apos;nacy&amp;apos;);
insert into `student` ( `id`, `name`) values ( &amp;apos;4&amp;apos;, &amp;apos;mike&amp;apos;);
insert into `student` ( `id`, `name`) values ( null, &amp;apos;guo&amp;apos;);
insert into `student` ( `id`, `name`) values ( &amp;apos;6&amp;apos;, &amp;apos;Guo&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不加BINARY关键字可以走索引：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; desc select * from student where name = &amp;apos;guo&amp;apos;;
+----+-------------+---------+------+---------------+----------+---------+-------+------+--------------------------+
| id | select_type | table   | type | possible_keys | key      | key_len | ref   | rows | Extra                    |
+----+-------------+---------+------+---------------+----------+---------+-------+------+--------------------------+
| 1  | SIMPLE      | student | ref  | idx_name      | idx_name | 63      | const | 2    | Using where; Using index |
+----+-------------+---------+------+---------------+----------+---------+-------+------+--------------------------+
1 rows in set (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;正常来说BINARY关键字是可以走索引的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; desc select * from student where BINARY name = &amp;apos;guo&amp;apos;;
+----+-------------+---------+-------+---------------+----------+---------+------+------+--------------------------+
| id | select_type | table   | type  | possible_keys | key      | key_len | ref  | rows | Extra                    |
+----+-------------+---------+-------+---------------+----------+---------+------+------+--------------------------+
| 1  | SIMPLE      | student | index | NULL          | idx_name | 63      | NULL | 6    | Using where; Using index |
+----+-------------+---------+-------+---------------+----------+---------+------+------+--------------------------+
1 rows in set (0.04 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不使用BINARY关键字默认不会区分大小写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from student where name = &amp;apos;guo&amp;apos;;
+----+------+
| id | name |
+----+------+
| 5  | guo  |
| 6  | Guo  |
+----+------+
2 rows in set (0.03 sec)

mysql&amp;gt; select * from student where name = &amp;apos;Guo&amp;apos;;
+----+------+
| id | name |
+----+------+
| 5  | guo  |
| 6  | Guo  |
+----+------+
2 rows in set (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用BINARY关键字可以区分大小写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt;  select * from student where BINARY name = &amp;apos;guo&amp;apos;;
+----+------+
| id | name |
+----+------+
| 5  | guo  |
+----+------+
1 rows in set (0.04 sec)

mysql&amp;gt;  select * from student where BINARY name = &amp;apos;Guo&amp;apos;;
+----+------+
| id | name |
+----+------+
| 6  | Guo  |
+----+------+
1 rows in set (0.03 sec)

mysql&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到这里以上都没问题，但关键在于，业务的表结构大于索引的最大长度即字串长度超过255。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE `student` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(2000) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_name` (`name`(255))
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8

mysql&amp;gt; desc select * from student where name = &amp;apos;guo&amp;apos;;
+----+-------------+---------+------+---------------+----------+---------+-------+------+-------------+
| id | select_type | table   | type | possible_keys | key      | key_len | ref   | rows | Extra       |
+----+-------------+---------+------+---------------+----------+---------+-------+------+-------------+
| 1  | SIMPLE      | student | ref  | idx_name      | idx_name | 768     | const | 2    | Using where |
+----+-------------+---------+------+---------------+----------+---------+-------+------+-------------+
1 rows in set (0.04 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;加上BINARY关键字不再走索引：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; desc select * from student where BINARY name = &amp;apos;guo&amp;apos;;
+----+-------------+---------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+---------+------+---------------+------+---------+------+------+-------------+
| 1  | SIMPLE      | student | ALL  | NULL          | NULL | NULL    | NULL | 6    | Using where |
+----+-------------+---------+------+---------------+------+---------+------+------+-------------+
1 rows in set (0.05 sec)

mysql&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时需要在表结构里加上BINARY&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt;ALTER TABLE student MODIFY COLUMN name VARCHAR(20) BINARY;
Query OK, 6 rows affected (0.06 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数据库会自动转换成COLLATE utf8_bin&lt;br&gt;collate关键字为校对集，主要是对字符集之间的比较和排序，可以通过 show collation查看所有的校对集&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show create table student\G
*************************** 1. row ***************************
Table       : student
Create Table: CREATE TABLE `student` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_name` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8
1 rows in set (0.39 sec)

mysql&amp;gt; 


mysql&amp;gt; desc select * from student where name = &amp;apos;guo&amp;apos;;
+----+-------------+---------+------+---------------+----------+---------+-------+------+--------------------------+
| id | select_type | table   | type | possible_keys | key      | key_len | ref   | rows | Extra                    |
+----+-------------+---------+------+---------------+----------+---------+-------+------+--------------------------+
| 1  | SIMPLE      | student | ref  | idx_name      | idx_name | 63      | const | 1    | Using where; Using index |
+----+-------------+---------+------+---------------+----------+---------+-------+------+--------------------------+
1 rows in set (0.07 sec)

mysql&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即可区分大小写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from student where name = &amp;apos;guo&amp;apos;;
+----+------+
| id | name |
+----+------+
| 5  | guo  |
+----+------+
1 rows in set (0.07 sec)

mysql&amp;gt; select * from student where name = &amp;apos;Guo&amp;apos;;
+----+------+
| id | name |
+----+------+
| 6  | Guo  |
+----+------+
1 rows in set (0.06 sec)

mysql&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;数据库版本:&lt;br&gt;MySQL 5.6.26&lt;/p&gt;
&lt;p&gt;线上某业务表为了区分大小写，使用BINARY关键字，正常来说使用这个关键字是走索引的，测试过程如下：&lt;/p&gt;
&lt;p&gt;创建测试表，插入数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop table  if EX
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="SQL" scheme="http://idber.github.io/tags/SQL/"/>
    
      <category term="BINARY" scheme="http://idber.github.io/tags/BINARY/"/>
    
  </entry>
  
  <entry>
    <title>子查询不存在字段</title>
    <link href="http://idber.github.io/2017/11/17-%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%AD%97%E6%AE%B5.html"/>
    <id>http://idber.github.io/2017/11/17-子查询不存在字段.html</id>
    <published>2017-11-17T06:49:56.000Z</published>
    <updated>2019-04-22T01:41:16.935Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;数据库版本&lt;br&gt;MySQL 5.6.26&lt;/p&gt;
&lt;p&gt;1、先看两个表的数据&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;TABLE IF EXISTS `course`;&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CREATE TABLE `course` (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `student_id` int(11),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `course` varchar(20)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) ENGINE=MyISAM DEFAULT CHARSET=utf8;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INSERT INTO `course` VALUES (&amp;apos;1&amp;apos;, &amp;apos;标题&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INSERT INTO `course` VALUES (&amp;apos;2&amp;apos;, &amp;apos;标题&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INSERT INTO `course` VALUES (&amp;apos;3&amp;apos;, &amp;apos;标题&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DROP TABLE IF EXISTS `student`;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CREATE TABLE `student` (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `id` int(11),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `name` varchar(20)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) ENGINE=MyISAM DEFAULT CHARSET=utf8;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INSERT INTO `student` VALUES (&amp;apos;1&amp;apos;, &amp;apos;lily&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INSERT INTO `student` VALUES (&amp;apos;2&amp;apos;, &amp;apos;lucy&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INSERT INTO `student` VALUES (&amp;apos;3&amp;apos;, &amp;apos;nacy&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INSERT INTO `student` VALUES (&amp;apos;4&amp;apos;, &amp;apos;hanmeimei&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2、奇怪的sql查询结果&lt;/p&gt;
&lt;p&gt;3、为什么course中不存在id或者name字段，子查询不报错；&lt;/p&gt;
&lt;p&gt;4、实际上是不是这样的&lt;/p&gt;
&lt;p&gt;5、整条语句中子查询返回的是什么？&lt;/p&gt;
&lt;p&gt;Mysql 子查询的实现并不是我们想象的那样。&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; student &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; student_id &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; course);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于上面的sql，我们一般会认为是这样执行:&lt;br&gt;猜想1:&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; student_id &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; course;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;result: 1,2,3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; student &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;事实上不是这样，Mysql会把外层表压入到子查询中，具体的执行计划可以使用&lt;/p&gt;
&lt;p&gt;explain extended查看：&lt;/p&gt;
&lt;figure class=&quot;highlight n1ql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;EXPLAIN&lt;/span&gt; EXTENDED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; student &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; id &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; student_id &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; course);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SHOW WARNINGS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;`test`&lt;/span&gt;.&lt;span class=&quot;symbol&quot;&gt;`student`&lt;/span&gt;.&lt;span class=&quot;symbol&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;`id`&lt;/span&gt;,&lt;span class=&quot;symbol&quot;&gt;`test`&lt;/span&gt;.&lt;span class=&quot;symbol&quot;&gt;`student`&lt;/span&gt;.&lt;span class=&quot;symbol&quot;&gt;`name`&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;`name`&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;`test`&lt;/span&gt;.&lt;span class=&quot;symbol&quot;&gt;`student`&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &amp;lt;in_optimizer&amp;gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;`test`&lt;/span&gt;.&lt;span class=&quot;symbol&quot;&gt;`student`&lt;/span&gt;.&lt;span class=&quot;symbol&quot;&gt;`id`&lt;/span&gt;,&amp;lt;&lt;span class=&quot;keyword&quot;&gt;exists&lt;/span&gt;&amp;gt;(&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;`test`&lt;/span&gt;.&lt;span class=&quot;symbol&quot;&gt;`course`&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; (&amp;lt;cache&amp;gt;(&lt;span class=&quot;symbol&quot;&gt;`test`&lt;/span&gt;.&lt;span class=&quot;symbol&quot;&gt;`student`&lt;/span&gt;.&lt;span class=&quot;symbol&quot;&gt;`id`&lt;/span&gt;) = &lt;span class=&quot;symbol&quot;&gt;`test`&lt;/span&gt;.&lt;span class=&quot;symbol&quot;&gt;`course`&lt;/span&gt;.&lt;span class=&quot;symbol&quot;&gt;`student_id`&lt;/span&gt;)));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Mysql处理后等价于：&lt;/p&gt;
&lt;figure class=&quot;highlight n1ql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; student &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;exists&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; course &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; course.student_id = student.id);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;查看执行计划，可以看到mysql对于student表全表扫描，然后按照id逐条执行子查询。这和我们的猜想1完全相反。&lt;/p&gt;
&lt;p&gt;到现在并没有解释LZ的问题，我们可以猜想下。&lt;br&gt;猜想2:既然是先全表扫描然后逐条子查询，是不是子查询的变量都是来自全表扫描时的局部变量？我们再看一下执行计划：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;EXTENDED&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select * from student where id in (select id from course);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;show WARNINGS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select `test`.`student`.`id` AS `id`,`test`.`student`.`name` AS `name` from `test`.`student` where &amp;lt;in_optimizer&amp;gt;(`test`.`student`.`id`,&amp;lt;exists&amp;gt;(select 1 from `test`.`course` where (&amp;lt;cache&amp;gt;(`test`.`student`.`id`) = `test`.`student`.`id`)));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过查询计划可以清晰的看到，真正执行的时候，子查询的变量都是全表扫描时的局部变量&lt;cache&gt;student.id，这也就解释了“为什么course中不存在id或者name字段，子查询不报错”，是因为查询的优化，导致根本不是使用的course的id或者name字段。&lt;/cache&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;数据库版本&lt;br&gt;MySQL 5.6.26&lt;/p&gt;
&lt;p&gt;1、先看两个表的数据&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;TABLE IF EXISTS `course`;&lt;/span&gt;&lt;/figc
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="SQL" scheme="http://idber.github.io/tags/SQL/"/>
    
      <category term="子查询" scheme="http://idber.github.io/tags/%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
    
  </entry>
  
</feed>
