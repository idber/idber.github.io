<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>似水年华--沉浮</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://idber.github.io/"/>
  <updated>2019-05-30T09:06:29.217Z</updated>
  <id>http://idber.github.io/</id>
  
  <author>
    <name>Michael Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MongoDB自定义权限实现MongoDB集合即表权限管理</title>
    <link href="http://idber.github.io/2019/05/30-MongoDB%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9D%83%E9%99%90%E5%AE%9E%E7%8E%B0MongoDB%E9%9B%86%E5%90%88%E5%8D%B3%E8%A1%A8%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86.html"/>
    <id>http://idber.github.io/2019/05/30-MongoDB自定义权限实现MongoDB集合即表权限管理.html</id>
    <published>2019-05-30T02:01:56.000Z</published>
    <updated>2019-05-30T09:06:29.217Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;业务上做迁移需要对原有数据进行锁定防止新数据写入，锁定的是db里的一个集合，MongoDB没有MySQL的权限细化管理到表，翻遍MongoDB文档，只能自建角色。&lt;/p&gt;
&lt;h1 id=&quot;官方文档&quot;&gt;&lt;a href=&quot;#官方文档&quot; class=&quot;headerlink&quot; title=&quot;官方文档&quot;&gt;&lt;/a&gt;官方文档&lt;/h1&gt;&lt;h2 id=&quot;用户自定义角色&quot;&gt;&lt;a href=&quot;#用户自定义角色&quot; class=&quot;headerlink&quot; title=&quot;用户自定义角色&quot;&gt;&lt;/a&gt;用户自定义角色&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/core/security-user-defined-roles/#user-defined-roles&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.mongodb.com/manual/core/security-user-defined-roles/#user-defined-roles&lt;/a&gt; &lt;/p&gt;
&lt;h2 id=&quot;创建角色语法&quot;&gt;&lt;a href=&quot;#创建角色语法&quot; class=&quot;headerlink&quot; title=&quot;创建角色语法&quot;&gt;&lt;/a&gt;创建角色语法&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/method/db.createRole/#db.createRole&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.mongodb.com/manual/reference/method/db.createRole/#db.createRole&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;创建自定义角色&quot;&gt;&lt;a href=&quot;#创建自定义角色&quot; class=&quot;headerlink&quot; title=&quot;创建自定义角色&quot;&gt;&lt;/a&gt;创建自定义角色&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;use db_name // db_name这里是你业务数据库的名称
db.createRole(
   {
     role: &amp;quot;my_define_role&amp;quot;, // 角色名称
     privileges: [
       { resource: { cluster: true }, actions: [ &amp;quot;addShard&amp;quot; ] }, // 分片集群MongoDB需要填写此项，副本集不用
       { resource: { db: &amp;quot;config&amp;quot;, collection: &amp;quot;&amp;quot; }, actions: [ &amp;quot;find&amp;quot;, &amp;quot;update&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;remove&amp;quot; ] }, // 定义库权限，可以到集合权限。
       { resource: { db: &amp;quot;users&amp;quot;, collection: &amp;quot;usersCollection&amp;quot; }, actions: [ &amp;quot;update&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;remove&amp;quot; ] },  // // 多个集合可以分别指定
       { resource: { db: &amp;quot;&amp;quot;, collection: &amp;quot;&amp;quot; }, actions: [ &amp;quot;find&amp;quot; ] }
     ], // 也可以指定不同的库，&amp;quot;&amp;quot;表示所有库、集合
     roles: [
       { role: &amp;quot;read&amp;quot;, db: &amp;quot;db_name&amp;quot; }  // db_name这里是你业务数据库的名称
     ]
   },
   { w: &amp;quot;majority&amp;quot; , wtimeout: 5000 } // 副本集默认的写入方式是majority
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相关文档&lt;br&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/write-concern/#writeconcern.%22majority%22&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.mongodb.com/manual/reference/write-concern/#writeconcern.%22majority%22&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;更新业务库角色权限&quot;&gt;&lt;a href=&quot;#更新业务库角色权限&quot; class=&quot;headerlink&quot; title=&quot;更新业务库角色权限&quot;&gt;&lt;/a&gt;更新业务库角色权限&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;db.getSiblingDB(&amp;quot;db_name&amp;quot;).updateUser( // db_name为业务库名
    &amp;quot;db_name&amp;quot;,
    {
        customData: {},

        roles: [
        { &amp;quot;role&amp;quot;: &amp;quot;my_define_role&amp;quot;, &amp;quot;db&amp;quot;: &amp;quot;db_name&amp;quot; ,},// my_define_role为自定义角色名
        ],
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;)&lt;/p&gt;
&lt;p&gt;完&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;业务上做迁移需要对原有数据进行锁定防止新数据写入，锁定的是db里的一个集合，MongoDB没有MySQL的权限细化管理到表，翻遍M
    
    </summary>
    
      <category term="MongoDB" scheme="http://idber.github.io/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://idber.github.io/tags/MongoDB/"/>
    
      <category term="权限" scheme="http://idber.github.io/tags/%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>Raft协议</title>
    <link href="http://idber.github.io/2019/05/21-Raft%E5%8D%8F%E8%AE%AE.html"/>
    <id>http://idber.github.io/2019/05/21-Raft协议.html</id>
    <published>2019-05-21T02:01:56.000Z</published>
    <updated>2019-05-23T04:00:19.319Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h1 id=&quot;概念与术语&quot;&gt;&lt;a href=&quot;#概念与术语&quot; class=&quot;headerlink&quot; title=&quot;概念与术语&quot;&gt;&lt;/a&gt;概念与术语&lt;/h1&gt;&lt;p&gt;Leader：领导者，为客户端提供服务(生成写日志)的节点，任何时候Raft系统中只能有一个Leader。&lt;br&gt;Follower：跟随者，被动接受请求的节点，不会发送任何请求，只会响应来自Leader或者Candidate的请求。如果接受到客户请求，会转发给Leader。&lt;br&gt;Candidate：候选人，选举过程中产生，Follower在超时时间内没有收到Leader的心跳或者日志，则切换到Candidate状态，进入选举流程。&lt;br&gt;TermId：任期号，时间被划分成一个个任期，每次选举后都会产生一个新的TermId，一个任期内只有一个Leader。TermId相当于Paxos的ProposalId。&lt;br&gt;currentTerm：更新的Term。&lt;br&gt;RequestVote：请求投票，Candidate在选举过程中发起，收到Quorum(多数派）响应后，成为Leader。&lt;br&gt;AppendEntries：附加日志，Leader发送日志和心跳的机制&lt;br&gt;Election Timeout：选举超时，如果Follower在一段时间内(超时时间为150ms-300ms内随机数)没有收到任何消息(追加日志或者心跳)，就是选举超时。&lt;br&gt;Leader Election：领导选举，选举超时即开始领导选举。&lt;br&gt;Raft协议主要包括三部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Leader选举&lt;/li&gt;
&lt;li&gt;日志复制&lt;/li&gt;
&lt;li&gt;成员变更&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个节点的状态只有如下三种形式的一种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Follower 状态&lt;/li&gt;
&lt;li&gt;Candidate 状态&lt;/li&gt;
&lt;li&gt;Leader 状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Leader选举&quot;&gt;&lt;a href=&quot;#Leader选举&quot; class=&quot;headerlink&quot; title=&quot;Leader选举&quot;&gt;&lt;/a&gt;Leader选举&lt;/h1&gt;&lt;h2 id=&quot;Leader流程&quot;&gt;&lt;a href=&quot;#Leader流程&quot; class=&quot;headerlink&quot; title=&quot;Leader流程&quot;&gt;&lt;/a&gt;Leader流程&lt;/h2&gt;&lt;p&gt;服务器启动时初始状态都是Follower，如果在超时时间内没有收到Leader发送的心跳包，则进入Candidate状态进行选举，服务器启动时和Leader挂掉时处理一样。为了避免选票瓜分的情况，比如5个节点ABCDE，Leader A 挂掉后，还剩4个节点，raft协议约定，每个服务器在一个任期只能投一张票，假设B，D分别有最新的日志，且同时发起选举投票，则可能出现B和D分别得到2张票的情况，如果这样都得不到大多数确认，无法选出leader。为了避免这种情况发生，raft利用随机超时机制避免选票瓜分情况。选举超时时间从一个固定的区间随机选择，由于&lt;font color=&quot;red&quot;&gt;每个服务器的超时时间不同&lt;/font&gt;，则leader挂掉后，超时时间最短且拥有最多日志的follower最先开始选主，并成为leader。一旦candidate成为leader，就会向其他服务器发送心跳包阻止新一轮的选举开始。&lt;br&gt;发送日志信息:(term,candidateId,lastLogTerm,lastLogIndex)&lt;/p&gt;
&lt;h2 id=&quot;Candidate流程&quot;&gt;&lt;a href=&quot;#Candidate流程&quot; class=&quot;headerlink&quot; title=&quot;Candidate流程&quot;&gt;&lt;/a&gt;Candidate流程&lt;/h2&gt;&lt;p&gt;1.在超时时间内没有收到leader的日志(包括心跳)&lt;br&gt;2.将状态切换为candidate,自增currentTerm,设置超时时间&lt;br&gt;3.向所有节点广播选举请求，等待响应，可能会有以下三种情况：&lt;br&gt;(1).如果收到多数派回应，则成为leader&lt;br&gt;(2).如果收到leader的心跳，且leader的term&amp;gt;=currentTerm，则自己切换为follower状态，&lt;br&gt;否则，保持Candidate身份&lt;br&gt;(3).如果在超时时间内没有达成多数派，也没有收到leader心跳，则很可能选票被瓜分，则会自增currentTerm,进行新一轮的选举&lt;/p&gt;
&lt;h2 id=&quot;Follower流程&quot;&gt;&lt;a href=&quot;#Follower流程&quot; class=&quot;headerlink&quot; title=&quot;Follower流程&quot;&gt;&lt;/a&gt;Follower流程&lt;/h2&gt;&lt;p&gt;1.如果term &amp;lt; currentTerm，说明有更新的term，返回给candidate。&lt;br&gt;2.如果还没有投票，或者candidateId的日志(lastLogTerm,lastLogIndex)和本地日志一样或更新，则投票给它。&lt;br&gt;注意：一个term周期内，每个节点最多只能投一张票，按照先来先到原则&lt;/p&gt;
&lt;p&gt;关键词：随机超时，FIFO&lt;/p&gt;
&lt;h1 id=&quot;日志复制流程&quot;&gt;&lt;a href=&quot;#日志复制流程&quot; class=&quot;headerlink&quot; title=&quot;日志复制流程&quot;&gt;&lt;/a&gt;日志复制流程&lt;/h1&gt;&lt;p&gt;leader向follower发送日志时，会顺带邻近的前一条日志，follwer接收日志时，会在相同任期号和索引位置找前一条日志，如果存在且匹配，则接收日志；否则拒绝，leader会减少日志索引位置并进行重试，直到某个位置与follower达成一致。然后follower删除索引后的所有日志，并追加leader发送的日志，一旦日志追加成功，则follower和leader的所有日志就保持一致。只有在多数派的follower都响应接受到日志后，表示事务可以提交，才能返回客户端提交成功。&lt;br&gt;发送日志信息:(term,leaderId,prevLogIndex,prevLogTerm,leaderCommitIndex)&lt;/p&gt;
&lt;h2 id=&quot;leader流程&quot;&gt;&lt;a href=&quot;#leader流程&quot; class=&quot;headerlink&quot; title=&quot;leader流程&quot;&gt;&lt;/a&gt;leader流程&lt;/h2&gt;&lt;p&gt;1.接收到client请求，本地持久化日志&lt;br&gt;2.将日志发往各个节点&lt;br&gt;3.如果达成多数派，再commit，返回给client。&lt;br&gt;备注：&lt;br&gt;(1).如果传递给follower的lastLogIndex&amp;gt;=nextIndex,则从nextIndex继续传递&lt;br&gt;.如果返回成功，则更新follower对应的nextIndex和matchIndex&lt;br&gt;.如果失败，则表示follower还差更多的日志，则递减nextIndex，重试&lt;br&gt;(2).如果存在N&amp;gt;commitIndex，且多数派matchIndex[i]&amp;gt;=N, 且log[N].term == currentTerm,&lt;br&gt;设置commitIndex=N。&lt;/p&gt;
&lt;h2 id=&quot;follower处理流程&quot;&gt;&lt;a href=&quot;#follower处理流程&quot; class=&quot;headerlink&quot; title=&quot;follower处理流程&quot;&gt;&lt;/a&gt;follower处理流程&lt;/h2&gt;&lt;p&gt;1.比较term号和自身的currentTerm，如果term&amp;lt;currentTerm，则返回false&lt;br&gt;2.如果(prevLogIndex,prevLogTerm)不存在，说明还差日志，返回false&lt;br&gt;3.如果(prevLogIndex,prevLogTerm)与已有的日志冲突，则以leader为准，删除自身的日志&lt;br&gt;4.将leader传过来的日志追加到末尾&lt;br&gt;5.如果leaderCommitIndex&amp;gt;commitIndex,说明是新的提交位点，回放日志，设置commitIndex =&lt;br&gt;min(leaderCommitIndex, index of last new entry)&lt;/p&gt;
&lt;p&gt;备注：默认情况下，如果日志不匹配，会按logIndex逐条往前推进，直到找到match的位置，有一个简单的思路是，每次往前推进一个term，这样可以减少了网络交互，尽快早点match的位置，代价是可能传递了一些多余的日志。&lt;/p&gt;
&lt;p&gt;关键词：日志连续一致性，多数派，leader日志不变更&lt;/p&gt;
&lt;h1 id=&quot;快照流程&quot;&gt;&lt;a href=&quot;#快照流程&quot; class=&quot;headerlink&quot; title=&quot;快照流程&quot;&gt;&lt;/a&gt;快照流程&lt;/h1&gt;&lt;p&gt;避免日志占满磁盘空间，需要定期对日志进行清理，在清理前需要做快照，这样新加入的节点可以通过快照+日志恢复。&lt;br&gt;快照属性：&lt;br&gt;1.最后一个已经提交的日志（termId，logIndex）&lt;br&gt;2.新的快照生成后，可以删除之前的日志和以前的快照。&lt;br&gt;删日志不能太快，否则，crash后的机器，本来可以通过日志恢复，如果日志不存在，需要通过快照恢复，比较慢。&lt;/p&gt;
&lt;h2 id=&quot;leader发送快照流程&quot;&gt;&lt;a href=&quot;#leader发送快照流程&quot; class=&quot;headerlink&quot; title=&quot;leader发送快照流程&quot;&gt;&lt;/a&gt;leader发送快照流程&lt;/h2&gt;&lt;p&gt;传递参数(leaderTermId, lastIndex, lastTerm, offset, data[], done_flag)&lt;br&gt;1.如果发现日志落后太远(超过阀值)，则触发发送快照流程&lt;br&gt;备注：快照不能太频繁，否则会导致磁盘IO压力较大；但也需要定期做，清理非必要的日志，缓解日志的空间压力，另外可以提高follower追赶的速度。&lt;/p&gt;
&lt;h2 id=&quot;follower接收快照流程&quot;&gt;&lt;a href=&quot;#follower接收快照流程&quot; class=&quot;headerlink&quot; title=&quot;follower接收快照流程&quot;&gt;&lt;/a&gt;follower接收快照流程&lt;/h2&gt;&lt;p&gt;1.如果leaderTermId&amp;lt;currentTerm, 则返回&lt;br&gt;2.如果是第一个块，创建快照&lt;br&gt;3.在指定的偏移，将数据写入快照&lt;br&gt;4.如果不是最后一块，等待更多的块&lt;br&gt;5.接收完毕后，丢掉以前旧的快照&lt;br&gt;6.删除掉不需要的日志&lt;/p&gt;
&lt;h1 id=&quot;集群配置变更&quot;&gt;&lt;a href=&quot;#集群配置变更&quot; class=&quot;headerlink&quot; title=&quot;集群配置变更&quot;&gt;&lt;/a&gt;集群配置变更&lt;/h1&gt;&lt;p&gt;C(old): 旧配置&lt;br&gt;C(new): 新配置&lt;br&gt;C(old-new): 过渡配置，需要同时在old和new中达成多数派才行&lt;br&gt;原则：配置变更过程中，不会导致出现两个leader&lt;br&gt;二阶段方案：引入过渡阶段C(old-new)&lt;br&gt;约定：任何一个follower在收到新的配置后，就采用新的配置确定多数派。&lt;/p&gt;
&lt;h2 id=&quot;变更流程&quot;&gt;&lt;a href=&quot;#变更流程&quot; class=&quot;headerlink&quot; title=&quot;变更流程&quot;&gt;&lt;/a&gt;变更流程&lt;/h2&gt;&lt;p&gt;1.leader收到从C(old)切换到C(new)配置的请求&lt;br&gt;2.创建配置日志C(old-new),这条日志需要在C(old)和C(new)中同时达成多数派&lt;br&gt;3.任何一个follower收到配置后，采用的C(old-new)来确定日志是否达成多数派(即使C(old-new)这条日志还没达成多数派)&lt;br&gt;备注：1，2，3阶段只有可能C(old)节点成为leader，因为C(old-new)没有可能成为多数派。&lt;br&gt;4.C(old-new)日志commit(达成多数派)，则无论是C(old)还是C(new)都无法单独达成多数派，即不会存在两个leader&lt;br&gt;5.创建配置配置日志C(new),广播到所有节点&lt;br&gt;6.同样的，任何一个follower收到配置后，采用的C(new)来确定日志是否达成多数派&lt;br&gt;备注：在4，5，6阶段，只有可能含有C(old-new)配置的节点成为leader。&lt;br&gt;7.C(new)配置日志commit后，则C(old-new)无法再达成多数派&lt;br&gt;8.对于不在C(new)配置的节点，就可以退出了，变更完成。&lt;br&gt;备注：在7，8阶段，只有可能含有C(new)配置成为leader。&lt;br&gt;所以整个过程中永远只会有一个leader。对于leader不在C(new)配置的情况，需要在C(new)日志提交后，自动关闭。&lt;/p&gt;
&lt;p&gt;相关阅读&lt;br&gt;&lt;a href=&quot;http://thesecretlivesofdata.com/raft/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://thesecretlivesofdata.com/raft/&lt;/a&gt;  （强烈推荐阅读，动画的形式化繁为简地讲解raft）&lt;br&gt;&lt;a href=&quot;https://raft.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://raft.github.io/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://raft.github.io/raft.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://raft.github.io/raft.pdf&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://medium.com/@techgeek628/raft-understandable-distributed-consensus-987b3783d48a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://medium.com/@techgeek628/raft-understandable-distributed-consensus-987b3783d48a&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;概念与术语&quot;&gt;&lt;a href=&quot;#概念与术语&quot; class=&quot;headerlink&quot; title=&quot;概念与术语&quot;&gt;&lt;/a&gt;概念与术语&lt;/h1&gt;&lt;p&gt;Leader：领导者，为客户端提供服务(生成写日志)的节点，任何时候Raft系统中只能有一个Leader。
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="分布式" scheme="http://idber.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Quorum协议</title>
    <link href="http://idber.github.io/2019/05/16-Quorum%E5%8D%8F%E8%AE%AE.html"/>
    <id>http://idber.github.io/2019/05/16-Quorum协议.html</id>
    <published>2019-05-16T02:01:56.000Z</published>
    <updated>2019-05-17T01:41:02.968Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;Amazon Aurora 存储层的复制基于Quorum协议，那么什么是Quorum协议呢？&lt;/p&gt;
&lt;p&gt;Quorum 协议，是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法，其主要数学思想来源于鸽巢原理。&lt;/p&gt;
&lt;p&gt;什么又是鸽巢原理？&lt;/p&gt;
&lt;p&gt;鸽巢原理，又名狄利克雷抽屉原理、鸽笼原理。&lt;/p&gt;
&lt;p&gt;其中一种简单的表述法为：&lt;/p&gt;
&lt;p&gt;若有n个笼子和n + 1只鸽子，所有的鸽子都被关在鸽笼里，那么至少有一个笼子有至少2只鸽子。&lt;/p&gt;
&lt;p&gt;另一种为：&lt;/p&gt;
&lt;p&gt;若有n个笼子和kn+1只鸽子，所有的鸽子都被关在鸽笼里，那么至少有一个笼子有至少k+1只鸽子。&lt;br&gt;随机取3组数据&lt;/p&gt;
&lt;p&gt;n = 1, k = 1&lt;br&gt;1个笼子&lt;br&gt;kn + 1 = 2 共2只鸽子&lt;br&gt;k + 1 = 2 至少有一个笼子有至少2只鸽子&lt;/p&gt;
&lt;p&gt;n = 2, k = 2&lt;br&gt;2个笼子&lt;br&gt;kn + 1 = 5 共5只鸽子&lt;br&gt;k + 1 = 3 至少有一个笼子有至少3只鸽子&lt;/p&gt;
&lt;p&gt;n = 10, k = 2&lt;br&gt;10个笼子&lt;br&gt;kn + 1 = 21 共21只鸽子&lt;br&gt;k + 1 = 3 至少有一个笼子有至少3只鸽子&lt;/p&gt;
&lt;p&gt;集合论的表述如下：&lt;/p&gt;
&lt;p&gt;若A是n+1元集，B是n元集，则不存在从A到B的单射。&lt;br&gt;拉姆齐定理是此原理的推广。&lt;/p&gt;
&lt;p&gt;基于Quorum投票的冗余控制算法&lt;br&gt;在有冗余数据的分布式存储系统当中，冗余数据对象会在不同的机器之间存放多份拷贝。但是同一时刻一个数据对象的多份拷贝只能用于读或者用于写。&lt;/p&gt;
&lt;p&gt;该算法可以保证同一份数据对象的多份拷贝不会被超过两个访问对象读写。&lt;/p&gt;
&lt;p&gt;算法来源于[Gifford, 1979]。 分布式系统中的每一份数据拷贝对象都被赋予一票。每一个读操作获得的票数必须大于最小读票数（read quorum）（Vr），每个写操作获得的票数必须大于最小写票数（write quorum）(Vw）才能读或者写。如果系统有V票（意味着一个数据对象有V份冗余拷贝），那么最小读写票数(quorum)应满足如下限制：&lt;/p&gt;
&lt;p&gt;Vr + Vw &amp;gt; V&lt;br&gt;Vw &amp;gt; V/2&lt;br&gt;第一条规则保证了一个数据不会被同时读写。当一个写操作请求过来的时候，它必须要获得Vw个冗余拷贝的许可。而剩下的数量是V-Vw 不够Vr，因此不能再有读请求过来了。同理，当读请求已经获得了Vr个冗余拷贝的许可时，写请求就无法获得许可了。&lt;/p&gt;
&lt;p&gt;第二条规则保证了数据的串行化修改。一份数据的冗余拷贝不可能同时被两个写请求修改。&lt;/p&gt;
&lt;p&gt;算法的好处&lt;br&gt;在分布式系统中，冗余数据是保证可靠性的手段，因此冗余数据的一致性维护就非常重要。一般而言，一个写操作必须要对所有的冗余数据都更新完成了，才能称为成功结束。比如一份数据在5台设备上有冗余，因为不知道读数据会落在哪一台设备上，那么一次写操作，必须5台设备都更新完成，写操作才能返回。&lt;/p&gt;
&lt;p&gt;对于写操作比较频繁的系统，这个操作的瓶颈非常大。Quorum算法可以让写操作只要写完3台就返回。剩下的由系统内部缓慢同步完成。而读操作，则需要也至少读3台，才能保证至少可以读到一个最新的数据。&lt;/p&gt;
&lt;p&gt;Quorum的读写最小票数可以用来做为系统在读、写性能方面的一个可调节参数。写票数Vw越大，则读票数Vr越小，这时候系统读的开销就小。反之则写的开销就小。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;Amazon Aurora 存储层的复制基于Quorum协议，那么什么是Quorum协议呢？&lt;/p&gt;
&lt;p&gt;Quorum 协议，是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法，其主要数学思想来源于鸽巢原理。&lt;/p&gt;
&lt;p&gt;什么又是鸽巢原理？&lt;/p
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="分布式" scheme="http://idber.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL字符集一个隐藏参数</title>
    <link href="http://idber.github.io/2019/05/14-MySQL%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%80%E4%B8%AA%E9%9A%90%E8%97%8F%E5%8F%82%E6%95%B0.html"/>
    <id>http://idber.github.io/2019/05/14-MySQL字符集一个隐藏参数.html</id>
    <published>2019-05-14T02:01:56.000Z</published>
    <updated>2019-05-14T03:54:52.963Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;最近在研究字符集相关的问题，无意中看到了MySQL字符集一个隐藏的参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--character-set-client-handshake
Do not ignore character set information sent by the client. To ignore client information and use the default server character set, use --skip-character-set-client-handshake; this makes MySQL behave like MySQL 4.0.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了兼容 mysql 4.0 的习惯增加的这个参数，character-set-client-handshake默认为1，读取default_character_set里设置的值。如果忽略客户端字符集设置，mysqld启动时加上 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--skip-character-set-client-handshake 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;验证：&lt;br&gt;my.cnf参数设置&lt;br&gt;default_character_set = latin1&lt;br&gt;character_set_server = utf8mb4&lt;/p&gt;
&lt;p&gt;启动不读取default_character_set的值设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;character-set-client-handshake=0
or
skip-character-set-client-handshake=1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重启mysql让配置生效，查看结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show variables like &amp;apos;character%&amp;apos;;
+--------------------------+-----------------------------------+
| Variable_name            | Value                             |
+--------------------------+-----------------------------------+
| character_set_client     | utf8mb4                           |
| character_set_connection | utf8mb4                           |
| character_set_database   | gbk                               |
| character_set_filesystem | binary                            |
| character_set_results    | utf8mb4                           |
| character_set_server     | utf8mb4                           |
| character_set_system     | utf8                              |
| character_sets_dir       | /home/mysql/mysql/share/charsets/ |
+--------------------------+-----------------------------------+
8 rows in set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到character_set_client，character_set_connection，character_set_results读取的是character_set_server的值utf8mb4&lt;/p&gt;
&lt;p&gt;如果启动读取default_character_set的值设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;character-set-client-handshake=1
or
skip-character-set-client-handshake=0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重启mysql让配置生效，查看结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show variables like &amp;apos;character%&amp;apos;;
+--------------------------+-----------------------------------+
| Variable_name            | Value                             |
+--------------------------+-----------------------------------+
| character_set_client     | latin1                            |
| character_set_connection | latin1                            |
| character_set_database   | gbk                               |
| character_set_filesystem | binary                            |
| character_set_results    | latin1                            |
| character_set_server     | utf8mb4                           |
| character_set_system     | utf8                              |
| character_sets_dir       | /home/mysql/mysql/share/charsets/ |
+--------------------------+-----------------------------------+
8 rows in set (0.13 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到character_set_client，character_set_connection，character_set_results读取的是default_character_set的值latin1&lt;/p&gt;
&lt;p&gt;这时需要手工设置&lt;br&gt;set names xxx;&lt;br&gt;才会将client、connection、results的字符集改过来。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set names utf8;

Query OK, 0 rows affected (0.02 sec)

show variables like &amp;apos;character%&amp;apos;;
+--------------------------+-----------------------------------+
| Variable_name            | Value                             |
+--------------------------+-----------------------------------+
| character_set_client     | utf8                              |
| character_set_connection | utf8                              |
| character_set_database   | gbk                               |
| character_set_filesystem | binary                            |
| character_set_results    | utf8                              |
| character_set_server     | utf8mb4                           |
| character_set_system     | utf8                              |
| character_sets_dir       | /home/mysql/mysql/share/charsets/ |
+--------------------------+-----------------------------------+
8 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其实这个参数也是有好处的。比如启用 skip-character-set-client-handshake 选项后，就可以避免客户端程序误操作，使用其他字符集连接进来并写入数据，从而引发乱码问题。&lt;/p&gt;
&lt;p&gt;相关阅读：&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/cchust/p/4327019.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/cchust/p/4327019.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://idber.github.io/2019/05/10-MySQL的伪utf8字符集.html&quot;&gt;http://idber.github.io/2019/05/10-MySQL的伪utf8字符集.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;最近在研究字符集相关的问题，无意中看到了MySQL字符集一个隐藏的参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--character-set-client-handshake
Do not ignore character set information sent by 
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="字符集" scheme="http://idber.github.io/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>MySQL字符集的内部转换</title>
    <link href="http://idber.github.io/2019/05/13-MySQL%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9A%84%E5%86%85%E9%83%A8%E8%BD%AC%E6%8D%A2.html"/>
    <id>http://idber.github.io/2019/05/13-MySQL字符集的内部转换.html</id>
    <published>2019-05-13T02:01:56.000Z</published>
    <updated>2019-05-15T07:36:46.494Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;我们知道set names utf8;改变的character_set_client、character_set_connection、character_set_result三个值，MySQL字符集的内部转换到底是哪个阶段呢，下面通过控制变量法来验证。&lt;/p&gt;
&lt;h1 id=&quot;表准备&quot;&gt;&lt;a href=&quot;#表准备&quot; class=&quot;headerlink&quot; title=&quot;表准备&quot;&gt;&lt;/a&gt;表准备&lt;/h1&gt;&lt;p&gt;建立gbk字符集的表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show create table t\G
*************************** 1. row ***************************
       Table: t
Create Table: CREATE TABLE `t` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `data` varchar(100) DEFAULT NULL,
  `comment` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_data` (`data`)
) ENGINE=InnoDB  DEFAULT CHARSET=gbk
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;character_set_client、character_set_connection、character_set_result为gbk，SecureCRT为utf-8&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show variables like &amp;apos;character%&amp;apos;;
+--------------------------+-----------------------------------+
| Variable_name            | Value                             |
+--------------------------+-----------------------------------+
| character_set_client     | gbk                               |
| character_set_connection | gbk                               |
| character_set_database   | gbk                               |
| character_set_filesystem | binary                            |
| character_set_results    | gbk                               |
| character_set_server     | utf8mb4                           |
| character_set_system     | utf8                              |
| character_sets_dir       | /home/mysql/mysql/share/charsets/ |
+--------------------------+-----------------------------------+
8 rows in set (0.00 sec)

insert into T values(null,&amp;apos;小明&amp;apos;,&amp;apos;3 gbk&amp;apos;);

SELECT LENGTH(data), CHAR_LENGTH(data),data,hex(data),hex(&amp;apos;小明&amp;apos;),comment  from t;
+--------------+-------------------+--------+--------------+---------------+---------+
| LENGTH(data) | CHAR_LENGTH(data) | data   | hex(data)    | hex(&amp;apos;小明&amp;apos;) | comment |
+--------------+-------------------+--------+--------------+---------------+---------+
|            6 |                 3 | 小明   | E5B08FE6988E | E5B08FE6988E  | 3 gbk   |
+--------------+-------------------+--------+--------------+---------------+---------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里在SecureCRT明文输入hex(‘小明’)&lt;br&gt;可以看到查询出的二进制流为E5B08FE6988E&lt;br&gt;由于character_set_client、character_set_connection、character_set_result和表字符集均为GBK，不涉及MySQL内部编码转换。因此，表字符集虽然为GBK，但“小明”的编码并非为GBK编码的二进制流，而是UTF8的二进制流，两个汉字占用了6个字节，而读取是一个逆向的过程，不涉及到编码转换，查询依然能正确返回“小明”。&lt;/p&gt;
&lt;h1 id=&quot;只更改character-set-client为utf8&quot;&gt;&lt;a href=&quot;#只更改character-set-client为utf8&quot; class=&quot;headerlink&quot; title=&quot;只更改character_set_client为utf8&quot;&gt;&lt;/a&gt;只更改character_set_client为utf8&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;set character_set_client=utf8;

Query OK, 0 rows affected (0.00 sec)

show variables like &amp;apos;character%&amp;apos;;
+--------------------------+-----------------------------------+
| Variable_name            | Value                             |
+--------------------------+-----------------------------------+
| character_set_client     | utf8                              |
| character_set_connection | gbk                               |
| character_set_database   | gbk                               |
| character_set_filesystem | binary                            |
| character_set_results    | gbk                               |
| character_set_server     | utf8mb4                           |
| character_set_system     | utf8                              |
| character_sets_dir       | /home/mysql/mysql/share/charsets/ |
+--------------------------+-----------------------------------+
8 rows in set (0.00 sec)

insert into T values(null,&amp;apos;小明&amp;apos;,&amp;apos;character_set_client utf8&amp;apos;);  

Query OK, 1 row affected (0.01 sec)

SELECT id,LENGTH(data), CHAR_LENGTH(data),data,hex(data),hex(&amp;apos;小明&amp;apos;),comment  from t order by id ;
+----+--------------+-------------------+--------+--------------+-------------+---------------------------+
| id | LENGTH(data) | CHAR_LENGTH(data) | data   | hex(data)    | hex(&amp;apos;С) | comment                   |
+----+--------------+-------------------+--------+--------------+-------------+---------------------------+
|  1 |            6 |                 3 | 小明    | E5B08FE6988E | D0A1C3F7    | 3 gbk                     |
|  2 |            4 |                 2 | С      | D0A1C3F7     | D0A1C3F7    | character_set_client utf8 |
+----+--------------+-------------------+--------+--------------+-------------+---------------------------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，数据库里存储的字符为utf8的二进制流E5B08FE6988E&lt;br&gt;MySQL把SecureCRT明文输入的“小明”转换成了gbk的二进制流D0A1C3F7&lt;br&gt;把SecureCRT字符集设置成gbk用unhex反向查看确认D0A1C3F7是不是gbk的二进制流&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select unhex(&amp;apos;D0A1C3F7&amp;apos;);
+-------------------+
| unhex(&amp;apos;D0A1C3F7&amp;apos;) |
+-------------------+
| 小明              |
+-------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以D0A1C3F7为小明gbk的二进制流&lt;br&gt;而E5B08FE6988E呢&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select unhex(&amp;apos;E5B08FE6988E&amp;apos;);
+-----------------------+
| unhex(&amp;apos;E5B08FE6988E&amp;apos;) |
+-----------------------+
| 灏忔槑                |
+-----------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于SecureCRT是gbk字符集，把utf-8二进制流E5B08FE6988E按gbk解码成了gbk对应的汉字“灏忔槑”，就是日常所说的乱码。把SecureCRT设置成utf-8后，即恢复正常&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select unhex(&amp;apos;E5B08FE6988E&amp;apos;);
+-----------------------+
| unhex(&amp;apos;E5B08FE6988E&amp;apos;) |
+-----------------------+
| 小明                |
+-----------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以E5B08FE6988E为小明utf8的二进制流&lt;/p&gt;
&lt;p&gt;SecureCRT(utf8 E5B08FE6988E)–&amp;gt; character_set_client(utf8 E5B08FE6988E)–&amp;gt;character_set_connection(gbk D0A1C3F7)–&amp;gt;database(gbk D0A1C3F7)–&amp;gt;character_set_results(gbk D0A1C3F7)–&amp;gt;SecureCRT(utf8 D0A1C3F7)&lt;/p&gt;
&lt;p&gt;client(utf8)–&amp;gt;connection(gbk)作了转化&lt;/p&gt;
&lt;p&gt;connection把utf8的二进制流转换为gbk的二进制流，由于gbk不包含utf8，需要先用原utf8解码再转码为gbk，用Python演示过程为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a = u&amp;quot;小明&amp;quot;
a_utf_8 = a.encode(&amp;apos;utf-8&amp;apos;)
print(a_utf_8)
a_unicode = a_utf_8.decode(&amp;apos;utf-8&amp;apos;)
assert (a_unicode == a)
a_gb2312 = a_unicode.encode(&amp;apos;gb2312&amp;apos;)
print(a_gb2312)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;b&amp;apos;\xe5\xb0\x8f\xe6\x98\x8e&amp;apos;
b&amp;apos;\xd0\xa1\xc3\xf7&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;只设置character-set-connection为utf8&quot;&gt;&lt;a href=&quot;#只设置character-set-connection为utf8&quot; class=&quot;headerlink&quot; title=&quot;只设置character_set_connection为utf8&quot;&gt;&lt;/a&gt;只设置character_set_connection为utf8&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;set names gbk;
Query OK, 0 rows affected (0.00 sec)

set character_set_connection=utf8;
Query OK, 0 rows affected (0.00 sec)

show variables like &amp;apos;character%&amp;apos;;
+--------------------------+-----------------------------------+
| Variable_name            | Value                             |
+--------------------------+-----------------------------------+
| character_set_client     | gbk                               |
| character_set_connection | utf8                              |
| character_set_database   | gbk                               |
| character_set_filesystem | binary                            |
| character_set_results    | gbk                               |
| character_set_server     | utf8mb4                           |
| character_set_system     | utf8                              |
| character_sets_dir       | /home/mysql/mysql/share/charsets/ |
+--------------------------+-----------------------------------+
8 rows in set (0.00 sec)

 insert into T values(null,&amp;apos;小明&amp;apos;,&amp;apos;character_set_connection utf8&amp;apos;);
Query OK, 1 row affected (0.01 sec)

guo@ha 12:25:58&amp;gt;SELECT id,LENGTH(data), CHAR_LENGTH(data),data,hex(data),hex(&amp;apos;小明&amp;apos;),comment  from t order by id ;
+----+--------------+-------------------+--------+--------------+--------------------+-------------------------------+
| id | LENGTH(data) | CHAR_LENGTH(data) | data   | hex(data)    | hex(&amp;apos;小明&amp;apos;)      | comment                       |
+----+--------------+-------------------+--------+--------------+--------------------+-------------------------------+
|  1 |            6 |                 3 | 小明    | E5B08FE6988E | E7818FE5BF94E6A791 | 3 gbk                         |
|  2 |            4 |                 2 | С      | D0A1C3F7     | E7818FE5BF94E6A791 | character_set_client utf8     |
|  3 |            6 |                 3 | 小明    | E5B08FE6988E | E7818FE5BF94E6A791 | character_set_connection utf8 |
+----+--------------+-------------------+--------+--------------+--------------------+-------------------------------+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;SecureCRT(utf8 E5B08FE6988E)–&amp;gt; character_set_client(gbk E5B08FE6988E)–&amp;gt;character_set_connection(utf8 E5B08FE6988E)–&amp;gt;database(gbk E5B08FE6988E)–&amp;gt;character_set_results(gbk E5B08FE6988E)–&amp;gt;SecureCRT(utf8 E5B08FE6988E)&lt;/p&gt;
&lt;p&gt;数据库存储的二进制流E5B08FE6988E不变&lt;br&gt;SecureCRT输入的utf-8字符集‘小明’在这里变成了E7818FE5BF94E6A791&lt;br&gt;client(gbk)–&amp;gt;connection(utf8)未作转化&lt;/p&gt;
&lt;h1 id=&quot;只设置character-set-results为utf8&quot;&gt;&lt;a href=&quot;#只设置character-set-results为utf8&quot; class=&quot;headerlink&quot; title=&quot;只设置character_set_results为utf8&quot;&gt;&lt;/a&gt;只设置character_set_results为utf8&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;set names gbk;
Query OK, 0 rows affected (0.00 sec)

set character_set_results=utf8;
Query OK, 0 rows affected (0.00 sec)

show variables like &amp;apos;character%&amp;apos;;
+--------------------------+-----------------------------------+
| Variable_name            | Value                             |
+--------------------------+-----------------------------------+
| character_set_client     | gbk                               |
| character_set_connection | gbk                               |
| character_set_database   | gbk                               |
| character_set_filesystem | binary                            |
| character_set_results    | utf8                              |
| character_set_server     | utf8mb4                           |
| character_set_system     | utf8                              |
| character_sets_dir       | /home/mysql/mysql/share/charsets/ |
+--------------------------+-----------------------------------+
8 rows in set (0.00 sec)

insert into T values(null,&amp;apos;小明&amp;apos;,&amp;apos;character_set_results utf8&amp;apos;);          
Query OK, 1 row affected (0.00 sec)

guo@ha 12:27:06&amp;gt;SELECT id,LENGTH(data), CHAR_LENGTH(data),data,hex(data),hex(&amp;apos;小明&amp;apos;),comment  from t order by id ;
+----+--------------+-------------------+-----------+--------------+------------------+-------------------------------+
| id | LENGTH(data) | CHAR_LENGTH(data) | data      | hex(data)    | hex(&amp;apos;灏忔槑&amp;apos;) | comment                       |
+----+--------------+-------------------+-----------+--------------+------------------+-------------------------------+
|  1 |            6 |                 3 | 灏忔槑 | E5B08FE6988E | E5B08FE6988E     | 3 gbk                         |
|  2 |            4 |                 2 | 小明    | D0A1C3F7     | E5B08FE6988E     | character_set_client utf8     |
|  3 |            6 |                 3 | 灏忔槑 | E5B08FE6988E | E5B08FE6988E     | character_set_connection utf8 |
|  4 |            6 |                 3 | 灏忔槑 | E5B08FE6988E | E5B08FE6988E     | character_set_results utf8    |
+----+--------------+-------------------+-----------+--------------+------------------+-------------------------------+
4 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;SecureCRT(utf8 E5B08FE6988E)–&amp;gt; character_set_client(gbk E5B08FE6988E)–&amp;gt;character_set_connection(gbk E5B08FE6988E)–&amp;gt;database(gbk E5B08FE6988E)–&amp;gt;character_set_results(utf8 E7818FE5BF94E6A791 灏忔槑)–&amp;gt;SecureCRT(utf8 E7818FE5BF94E6A791 灏忔槑)&lt;br&gt;client(gbk)–&amp;gt;connection(gbk)未作转化&lt;/p&gt;
&lt;p&gt;这里只是显示出了问题，数据库存储的二进制流E5B08FE6988E不变，gbk存储的“小明”也能正常显示&lt;br&gt;SecureCRT输入的utf-8字符集‘小明’在这里也是E5B08FE6988E，但是“小明”显示成了“灏忔槑”对应二进制流E7818FE5BF94E6A791，results并没有转换而是直接把E5B08FE6988E当作gbk的字符处理成E7818FE5BF94E6A791&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select unhex(&amp;apos;E7818FE5BF94E6A791&amp;apos;);
+-----------------------------+
| unhex(&amp;apos;E7818FE5BF94E6A791&amp;apos;) |
+-----------------------------+
| 灏忔槑                   |
+-----------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;更改三者为utf8&quot;&gt;&lt;a href=&quot;#更改三者为utf8&quot; class=&quot;headerlink&quot; title=&quot;更改三者为utf8&quot;&gt;&lt;/a&gt;更改三者为utf8&lt;/h1&gt;&lt;p&gt;   改变character_set_client、character_set_connection、character_set_results的设置为utf8，查询插入的值。    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set names utf8;
Query OK, 0 rows affected (0.00 sec)

show variables like &amp;apos;character%&amp;apos;;
+--------------------------+-----------------------------------+
| Variable_name            | Value                             |
+--------------------------+-----------------------------------+
| character_set_client     | utf8                              |
| character_set_connection | utf8                              |
| character_set_database   | gbk                               |
| character_set_filesystem | binary                            |
| character_set_results    | utf8                              |
| character_set_server     | utf8mb4                           |
| character_set_system     | utf8                              |
| character_sets_dir       | /home/mysql/mysql/share/charsets/ |
+--------------------------+-----------------------------------+
8 rows in set (0.00 sec)

 insert into T values(null,&amp;apos;小明&amp;apos;,&amp;apos;3 utf8&amp;apos;);                     
Query OK, 1 row affected (0.00 sec)

guo@ha 12:28:10&amp;gt;SELECT id,LENGTH(data), CHAR_LENGTH(data),data,hex(data),hex(&amp;apos;小明&amp;apos;),comment  from t order by id ;
+----+--------------+-------------------+-----------+--------------+---------------+-------------------------------+
| id | LENGTH(data) | CHAR_LENGTH(data) | data      | hex(data)    | hex(&amp;apos;小明&amp;apos;) | comment                       |
+----+--------------+-------------------+-----------+--------------+---------------+-------------------------------+
|  1 |            6 |                 3 | 灏忔槑 | E5B08FE6988E | E5B08FE6988E  | 3 gbk                         |
|  2 |            4 |                 2 | 小明    | D0A1C3F7     | E5B08FE6988E  | character_set_client utf8     |
|  3 |            6 |                 3 | 灏忔槑 | E5B08FE6988E | E5B08FE6988E  | character_set_connection utf8 |
|  4 |            6 |                 3 | 灏忔槑 | E5B08FE6988E | E5B08FE6988E  | character_set_results utf8    |
|  5 |            4 |                 2 | 小明    | D0A1C3F7     | E5B08FE6988E  | 3 utf8                        |
+----+--------------+-------------------+-----------+--------------+---------------+-------------------------------+
5 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;SecureCRT(utf8 E5B08FE6988E)–&amp;gt; character_set_client(utf8 E5B08FE6988E)–&amp;gt;character_set_connection(utf8 E5B08FE6988E)–&amp;gt;database(gbk D0A1C3F7)–&amp;gt;character_set_results(utf8 E5B08FE6988E)–&amp;gt;SecureCRT(utf8 E5B08FE6988E)&lt;/p&gt;
&lt;p&gt; character_set_connection(utf8)–&amp;gt;database(gbk)作了转化&lt;/p&gt;
&lt;p&gt; 综上，MySQL内部二进制流重编码转化条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只在connection和database阶段进行&lt;/li&gt;
&lt;li&gt;connection、database的前一字符集是当前字符集的超集&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置SecureCRT的字符集为GBK，看看SecureCRT字符集设置对结果影响&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set names gbk;

Query OK, 0 rows affected (0.00 sec)

show variables like &amp;apos;%char%&amp;apos;;

+--------------------------+-----------------------------------+
| Variable_name            | Value                             |
+--------------------------+-----------------------------------+
| character_set_client     | gbk                               |
| character_set_connection | gbk                               |
| character_set_database   | gbk                               |
| character_set_filesystem | binary                            |
| character_set_results    | gbk                               |
| character_set_server     | utf8mb4                           |
| character_set_system     | utf8                              |
| character_sets_dir       | /home/mysql/mysql/share/charsets/ |
+--------------------------+-----------------------------------+
8 rows in set (0.00 sec)

SELECT id,LENGTH(data), CHAR_LENGTH(data),data,hex(data),comment  from t order by id ;
+----+--------------+-------------------+--------+----------------+-------------------------------+
| id | LENGTH(data) | CHAR_LENGTH(data) | data   | hex(data)      | comment                       |
+----+--------------+-------------------+--------+----------------+-------------------------------+
|  1 |            6 |                 3 | 灏忔槑 | E5B08FE6988E    | 3 gbk                         |
|  2 |            4 |                 2 | 小明   | D0A1C3F7       | character_set_client utf8     |
|  3 |            6 |                 3 | 灏忔槑 | E5B08FE6988E   | character_set_connection utf8 |
|  4 |            6 |                 3 | 灏忔槑 | E5B08FE6988E   | character_set_results utf8    |
|  5 |            4 |                 2 | 小明   | D0A1C3F7       | 3 utf8                        |
+----+--------------+-------------------+--------+----------------+-------------------------------+
5 rows in set (0.00 sec)

set  names utf8;

Query OK, 0 rows affected (0.00 sec)

show variables like &amp;apos;%char%&amp;apos;;
+--------------------------+-----------------------------------+
| Variable_name            | Value                             |
+--------------------------+-----------------------------------+
| character_set_client     | utf8                              |
| character_set_connection | utf8                              |
| character_set_database   | gbk                               |
| character_set_filesystem | binary                            |
| character_set_results    | utf8                              |
| character_set_server     | utf8mb4                           |
| character_set_system     | utf8                              |
| character_sets_dir       | /home/mysql/mysql/share/charsets/ |
+--------------------------+-----------------------------------+
8 rows in set (0.00 sec)

SELECT id,LENGTH(data), CHAR_LENGTH(data),data,hex(data),comment  from t order by id ;
+----+--------------+-------------------+-----------+--------------+-------------------------------+
| id | LENGTH(data) | CHAR_LENGTH(data) | data      | hex(data)    | comment                       |
+----+--------------+-------------------+-----------+--------------+-------------------------------+
|  1 |            6 |                 3 | 鐏忓繑妲    B08FE6988E    | 3 gbk                         |
|  2 |            4 |                 2 | 灏忔槑     |D0A1C3F7     | character_set_client utf8     |
|  3 |            6 |                 3 | 鐏忓繑妲    B08FE6988E    | character_set_connection utf8 |
|  4 |            6 |                 3 | 鐏忓繑妲    B08FE6988E    | character_set_results utf8    |
|  5 |            4 |                 2 | 灏忔槑     | D0A1C3F7     | 3 utf8                        |
+----+--------------+-------------------+-----------+--------------+-------------------------------+
5 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相关阅读&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/cchust/p/4327019.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/cchust/p/4327019.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;我们知道set names utf8;改变的character_set_client、character_set_connection、character_set_result三个值，MySQL字符集的内部转换到底是哪个阶段呢，下面通过控制变量法来验证。&lt;/p&gt;

    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="字符集" scheme="http://idber.github.io/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机原理之编码</title>
    <link href="http://idber.github.io/2019/05/11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BC%96%E7%A0%81.html"/>
    <id>http://idber.github.io/2019/05/11-计算机原理之编码.html</id>
    <published>2019-05-11T02:01:56.000Z</published>
    <updated>2019-05-11T09:19:52.154Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h1 id=&quot;编码与加密&quot;&gt;&lt;a href=&quot;#编码与加密&quot; class=&quot;headerlink&quot; title=&quot;编码与加密&quot;&gt;&lt;/a&gt;编码与加密&lt;/h1&gt;&lt;h2 id=&quot;加密&quot;&gt;&lt;a href=&quot;#加密&quot; class=&quot;headerlink&quot; title=&quot;加密&quot;&gt;&lt;/a&gt;加密&lt;/h2&gt;&lt;p&gt;什么是编码？他与加密有什么区别？&lt;br&gt;在密码学中，加密（英语：Encryption）是将明文信息改变为难以读取的密文内容，使之不可读的过程。只有拥有解密方法的对象，经由解密过程，才能将密文还原为正常可读的内容。&lt;/p&gt;
&lt;h2 id=&quot;编码&quot;&gt;&lt;a href=&quot;#编码&quot; class=&quot;headerlink&quot; title=&quot;编码&quot;&gt;&lt;/a&gt;编码&lt;/h2&gt;&lt;p&gt;那么什么是编码呢？&lt;br&gt;编码（Encoding）在认知上是解释传入的刺激的一种基本知觉的过程。技术上来说，这是一个复杂的、多阶段的转换过程，从较为客观的感觉输入（例如光、声）到主观上有意义的体验，是信息从一种形式或格式转换为另一种形式的过程。&lt;br&gt;解码，是编码的逆过程。&lt;/p&gt;
&lt;h2 id=&quot;加密与编码的关系&quot;&gt;&lt;a href=&quot;#加密与编码的关系&quot; class=&quot;headerlink&quot; title=&quot;加密与编码的关系&quot;&gt;&lt;/a&gt;加密与编码的关系&lt;/h2&gt;&lt;p&gt;从概念上可以看出，编码只是表现形式的转换，没有保密的作用，因为编码和解码的算法是公开的，只要知道是什么编码的内容，任何人都可以轻松地解码。从这个角度看加密也一种编码，只是解密算法是非公开的。&lt;/p&gt;
&lt;h1 id=&quot;字符编码&quot;&gt;&lt;a href=&quot;#字符编码&quot; class=&quot;headerlink&quot; title=&quot;字符编码&quot;&gt;&lt;/a&gt;字符编码&lt;/h1&gt;&lt;p&gt;字符编码（英语：Character encoding）、字集码是把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、8位组或者电脉冲），以便文本在计算机中存储和通过通信网络的传递。常见的例子包括将拉丁字母表编码成摩斯电码和ASCII。其中，ASCII将字母、数字和其它符号编号，并用7比特的二进制来表示这个整数。通常会额外使用一个扩充的比特，以便于以1个字节的方式存储。&lt;/p&gt;
&lt;p&gt;在计算机技术发展的早期，如ASCII（1963年）和EBCDIC（1964年）这样的字符集逐渐成为标准。但这些字符集的局限很快就变得明显，于是人们开发了许多方法来扩展它们。对于支持包括东亚CJK字符家族在内的写作系统的要求能支持更大量的字符，并且需要一种系统而不是临时的方法实现这些字符的编码。&lt;/p&gt;
&lt;p&gt;为了弄懂计算机是怎么实现编码的，就要先理解计算机如何存储数据的。&lt;/p&gt;
&lt;h1 id=&quot;数据在计算机中的存储&quot;&gt;&lt;a href=&quot;#数据在计算机中的存储&quot; class=&quot;headerlink&quot; title=&quot;数据在计算机中的存储&quot;&gt;&lt;/a&gt;数据在计算机中的存储&lt;/h1&gt;&lt;p&gt;我们知道数据在计算机中是以二进制的形式存储的，那么有没有想过01这些数据是怎么存在计算机当中的呢？&lt;/p&gt;
&lt;h2 id=&quot;第一步-如何存储0和1&quot;&gt;&lt;a href=&quot;#第一步-如何存储0和1&quot; class=&quot;headerlink&quot; title=&quot;第一步 如何存储0和1&quot;&gt;&lt;/a&gt;第一步 如何存储0和1&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/charset000%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A80%E5%92%8C1.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;不知道你们有没有听过一个东西，叫做——电容器。顾名思义，这是一种能容纳电荷的容器。与普通的电池不同的是，它的充电速度很快，并且因为不会转化为化学能所以电量流失的也很快。因此需要经常刷新。在我们的计算机中，CPU有一个参数是Hz，便是指每秒钟能充多少次电。数据在内存中以二进制的方式存储，事实上是通过对小电容器的充放电来完成的。 &lt;/p&gt;
&lt;h2 id=&quot;第二步-如何存储数字&quot;&gt;&lt;a href=&quot;#第二步-如何存储数字&quot; class=&quot;headerlink&quot; title=&quot;第二步 如何存储数字&quot;&gt;&lt;/a&gt;第二步 如何存储数字&lt;/h2&gt;&lt;p&gt;当然是把数字转化成二进制啦&lt;/p&gt;
&lt;h2 id=&quot;第三步-如何存储字符&quot;&gt;&lt;a href=&quot;#第三步-如何存储字符&quot; class=&quot;headerlink&quot; title=&quot;第三步 如何存储字符&quot;&gt;&lt;/a&gt;第三步 如何存储字符&lt;/h2&gt;&lt;p&gt;既然能够存储0和1，那存储字符也就不是什么难事了吧。我们只需要把字符和二进制一一对应起来，然后责令计算机来记住它，就万事大吉了。ASCII美国信息交换标准码就是干这件事。&lt;/p&gt;
&lt;h2 id=&quot;第四步-如何存储汉字&quot;&gt;&lt;a href=&quot;#第四步-如何存储汉字&quot; class=&quot;headerlink&quot; title=&quot;第四步 如何存储汉字&quot;&gt;&lt;/a&gt;第四步 如何存储汉字&lt;/h2&gt;&lt;p&gt;当然，早期的时候计算机并没有在中国兴起，所以中文并不能被计算机所识别，直到1980年GB2312（信息交换用汉字编码字符集）横空出世。功能与ASCII相似。当然，后来又有了GBK（国际标准扩展），我们暂且不提。 &lt;/p&gt;
&lt;h2 id=&quot;第五步-如何存储所有字符&quot;&gt;&lt;a href=&quot;#第五步-如何存储所有字符&quot; class=&quot;headerlink&quot; title=&quot;第五步 如何存储所有字符&quot;&gt;&lt;/a&gt;第五步 如何存储所有字符&lt;/h2&gt;&lt;p&gt;照葫芦画瓢，将所有的字符进行编号，所以有了Unicode字符集。但是这里有一个问题，虽然它可以存储世界上所有的字符，但是如果你的编码是000000000000001，它是不会自动给你简化成1的。由此直接导致了所有的文字存储代价都会翻倍，而这样的代价，是很多人都不愿意看见的。&lt;/p&gt;
&lt;h2 id=&quot;第六步-如何将Unicode存到计算机里&quot;&gt;&lt;a href=&quot;#第六步-如何将Unicode存到计算机里&quot; class=&quot;headerlink&quot; title=&quot;第六步 如何将Unicode存到计算机里&quot;&gt;&lt;/a&gt;第六步 如何将Unicode存到计算机里&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/charset005%E7%AC%AC%E5%85%AD%E6%AD%A5%E5%A6%82%E4%BD%95%E5%B0%86Unicode%E5%AD%98%E5%88%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8C.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里稍微解释一下最后一行，第一块的两个11是指后边有两串跟着，紧接着的10是指两串开头两个标志位是10。上边的Unicode编码中截取后两个字节放到下边utf-8中除标志位之外的地方，也就是说，除了第一块开头的1110，第二块和第三块开头的10，我们有4+6+6=16位来依次存储上边的8+8=16位字符串。&lt;br&gt;如你所见，这就是UTF-8，一种编码方式。它采用了变长存储的形式来表示Unicode字符集。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/charset003UTF8.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;编码与加密&quot;&gt;&lt;a href=&quot;#编码与加密&quot; class=&quot;headerlink&quot; title=&quot;编码与加密&quot;&gt;&lt;/a&gt;编码与加密&lt;/h1&gt;&lt;h2 id=&quot;加密&quot;&gt;&lt;a href=&quot;#加密&quot; class=&quot;headerlink&quot; title=&quot;加密&quot;&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="计算机原理" scheme="http://idber.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
      <category term="编码" scheme="http://idber.github.io/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的伪utf8字符集</title>
    <link href="http://idber.github.io/2019/05/10-MySQL%E7%9A%84%E4%BC%AAutf8%E5%AD%97%E7%AC%A6%E9%9B%86.html"/>
    <id>http://idber.github.io/2019/05/10-MySQL的伪utf8字符集.html</id>
    <published>2019-05-10T02:01:56.000Z</published>
    <updated>2019-05-13T10:05:40.032Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h1 id=&quot;标准UTF-8字符集&quot;&gt;&lt;a href=&quot;#标准UTF-8字符集&quot; class=&quot;headerlink&quot; title=&quot;标准UTF-8字符集&quot;&gt;&lt;/a&gt;标准UTF-8字符集&lt;/h1&gt;&lt;p&gt;UTF-8（8-bit Unicode Transformation Format）即8位Unicode转换格式，是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或发送文字优先采用的编码。&lt;/p&gt;
&lt;p&gt;UTF-8使用一至六个字节为每个字符编码（尽管如此，2003年11月UTF-8被RFC 3629重新规范，只能使用原来Unicode定义的区域，U+0000到U+10FFFF，也就是说最多&lt;font color=&quot;red&quot;&gt;四个字节&lt;/font&gt;）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。&lt;/li&gt;
&lt;li&gt;带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要两个字节编码（Unicode范围由U+0080至U+07FF）。&lt;/li&gt;
&lt;li&gt;其他基本多文种平面（BMP）中的字符（这包含了大部分常用字，如大部分的汉字）使用三个字节编码（Unicode范围由U+0800至U+FFFF）。&lt;/li&gt;
&lt;li&gt;其他极少使用的Unicode 辅助平面的字符使用四至六字节编码（Unicode范围由U+10000至U+1FFFFF使用四字节，Unicode范围由U+200000至U+3FFFFFF使用五字节，Unicode范围由U+4000000至U+7FFFFFFF使用六字节）。&lt;br&gt;对上述提及的第四种字符而言，UTF-8使用四至六个字节来编码似乎太耗费资源了。但UTF-8对所有常用的字符都可以用三个字节表示，而且它的另一种选择，UTF-16编码，对前述的第四种字符同样需要四个字节来编码，所以要决定UTF-8或UTF-16哪种编码比较有效率，还要视所使用的字符的分布范围而定。不过，如果使用一些传统的压缩系统，比如DEFLATE，则这些不同编码系统间的的差异就变得微不足道了。若顾及传统压缩算法在压缩较短文字上的效果不大，可以考虑使用Unicode标准压缩格式（SCSU）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。互联网邮件联盟（IMC）建议所有电子邮件软件都支持UTF-8编码。&lt;/p&gt;
&lt;h1 id=&quot;MySQL的utf8&quot;&gt;&lt;a href=&quot;#MySQL的utf8&quot; class=&quot;headerlink&quot; title=&quot;MySQL的utf8&quot;&gt;&lt;/a&gt;MySQL的utf8&lt;/h1&gt;&lt;p&gt;官方手册 &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/charset-unicode-sets.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/refman/5.6/en/charset-unicode-sets.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;utf8mb4: A UTF-8 encoding of the Unicode character set using one to four bytes per character.&lt;/p&gt;
&lt;p&gt;utf8mb3: A UTF-8 encoding of the Unicode character set using one to three bytes per character.&lt;/p&gt;
&lt;p&gt;utf8: An alias for utf8mb3.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/charset-unicode-conversion.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/refman/5.6/en/charset-unicode-conversion.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;utf8mb3 supports only characters in the Basic Multilingual Plane (BMP). utf8mb4 additionally supports supplementary characters that lie outside the BMP.&lt;/p&gt;
&lt;p&gt;utf8mb3 uses a maximum of three bytes per character. utf8mb4 uses a maximum of four bytes per character.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从手册中可以看到，utf8实际上是utf8mb3的别名，即maximum of three bytes per character最大只支持3个字节，MySQL官方并未直接修复这个问题，而是在5.5.3之后增加了utf8mb4字符编码，mb4即 maximum of four bytes。简单说 utf8mb4 是 utf8 的超集并完全兼容utf8，能够用四个字节存储更多的字符。&lt;/p&gt;
&lt;p&gt;但抛开数据库，标准的 UTF-8 字符集编码是可以用 1~4 个字节去编码21位字符，这几乎包含了是世界上所有能看见的语言了。然而在MySQL里实现的utf8最长使用3个字节，也就是上面提到的标准UTF-8中“基本多文种平面（BMP）中的字符（这包含了大部分常用字，如大部分的汉字）使用三个字节编码（Unicode范围由U+0800至U+FFFF）。”但并不是所有，最常见的就算现在手机端常用的表情字符emoji，需要四个字节（Unicode范围由U+10000至U+1FFFFF）才能编码出来。&lt;/p&gt;
&lt;p&gt;注：QQ里面的内置的表情不算，它是通过特殊映射到的一个gif图片。一般输入法自带的才是emoji。&lt;/p&gt;
&lt;p&gt;也就是当你的数据库里要求能够存入这些表情或宽字符时，可以把字段定义为 utf8mb4，同时要注意连接字符集也要设置为utf8mb4，否则在 严格模式 下会出现 Incorrect string value: \xF0\x9F\x98\x84… for column ‘content’这样的错误，非严格模式下此后的数据会被截断。&lt;/p&gt;
&lt;p&gt;关于网上流传的latin1也支持emoji，&lt;a href=&quot;https://stackoverflow.com/questions/30187853/does-mysql-latin1-also-support-emoji-character&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Does mysql latin1 also support emoji character?&lt;/a&gt;。&lt;br&gt;这里有一个问题就是，输入源要支持标准的UTF-8，操作系统的字符集为utf8（LANG=en_US.UTF-8）目前大部分系统都支持, 而client、connection、database均为latin1, 于是这一路（从终端界面执行insert到保存数据到表中）都没有编码转换，直接传输的是utf8编码后的二进制流。&lt;br&gt;latin1字符集的表，用户写入和读取汉字、emoji是否有问题？答案是只要设置合理，是没有问题的。假设SecureCRT为UTF8，character_set_client和表字符集均设置为latin1，那么用户读取和写入数据的过程中，并不涉及字符集编码转换的过程，将UTF8的汉字或emoji字符转为二进制流写入database，提取出来后，secureCRT再将对应的二进制解码为对应的汉字或emoji，所以不影响用户的使用。&lt;/p&gt;
&lt;p&gt;，&lt;br&gt;&lt;!--以下为引用 [via](http://seanlook.com/2016/10/23/mysql-utf8mb4/)
--&gt;&lt;/p&gt;
&lt;h1 id=&quot;utf8-unicode-ci和utf8-general-ci区别&quot;&gt;&lt;a href=&quot;#utf8-unicode-ci和utf8-general-ci区别&quot; class=&quot;headerlink&quot; title=&quot;utf8_unicode_ci和utf8_general_ci区别&quot;&gt;&lt;/a&gt;utf8_unicode_ci和utf8_general_ci区别&lt;/h1&gt;&lt;p&gt;字符除了需要存储，还需要排序或比较大小，涉及到与编码字符集对应的排序字符集（collation）。ut8mb4对应的排序字符集常用的有 utf8mb4_unicode_ci、utf8mb4_general_ci，到底采用哪个在 stackoverflow 上有个讨论，&lt;a href=&quot;http://stackoverflow.com/questions/766809/whats-the-difference-between-utf8-general-ci-and-utf8-unicode-ci&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What’s the difference between utf8_general_ci and utf8_unicode_ci&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在数据库系统MySQL或MariaDB中有多种字符集，其中utf8_unicode_ci和utf8_general_ci是最常用的，但是utf8_general_ci对某些语言的支持有一些小问题，如果可以接受，那最好使用utf8_general_ci，因为它速度快。否则，请使用较为精确的utf8_unicode_ci，不过速度会慢一些。&lt;/p&gt;
&lt;h1 id=&quot;怎么从utf8转换为utf8mb4&quot;&gt;&lt;a href=&quot;#怎么从utf8转换为utf8mb4&quot; class=&quot;headerlink&quot; title=&quot;怎么从utf8转换为utf8mb4&quot;&gt;&lt;/a&gt;怎么从utf8转换为utf8mb4&lt;/h1&gt;&lt;h2 id=&quot;“伪”转换&quot;&gt;&lt;a href=&quot;#“伪”转换&quot; class=&quot;headerlink&quot; title=&quot;“伪”转换&quot;&gt;&lt;/a&gt;“伪”转换&lt;/h2&gt;&lt;p&gt;如果你的表定义和连接字符集都是utf8，那么直接在你的表上执行&lt;/p&gt;
&lt;p&gt;ALTER TABLE tbl_name CONVERT TO CHARACTER SET utf8mb4;&lt;br&gt;则能够该表上所有的列的character类型变成 utf8mb4，表定义的默认字符集也会修改。连接的时候需要使用set names utf8mb4便可以插入四字节字符。（如果依然使用 utf8 连接，只要不出现四字节字符则完全没问题）。&lt;/p&gt;
&lt;p&gt;上面的 convert 有两个问题，一是它不能ONLINE，也就是执行之后全表禁止修改，有关这方面的讨论见 mysql 5.6 原生Online DDL解析；二是，它可能会自动该表字段类型定义，如 VARCHAR 被转成 MEDIUMTEXT，可以通过 MODIFY 指定类型为原类型。&lt;/p&gt;
&lt;p&gt;另外 ALTER TABLE tbl_name DEFAULT CHARACTER SET utf8mb4 这样的语句就不要随便执行了，特别是当表原本不是utf8时，除非表是空的或者你确认表里只有拉丁字符，否则正常和乱的就混在一起了。&lt;/p&gt;
&lt;p&gt;最重要的是，你连接时使用的latin1字符集写入了历史数据，表定义是latin1或utf8，不要期望通过 ALTER … CONVERT … 能够让你达到用utf8读取历史中文数据的目的，没卵用，老老实实做逻辑dump。所以我才叫它“伪”转换&lt;/p&gt;
&lt;h2 id=&quot;character-set-server&quot;&gt;&lt;a href=&quot;#character-set-server&quot; class=&quot;headerlink&quot; title=&quot;character-set-server&quot;&gt;&lt;/a&gt;character-set-server&lt;/h2&gt;&lt;p&gt;一旦你决定使用utf8mb4，强烈建议你要修改服务端 character-set-server=utf8mb4，不同的语言对它的处理方法不一样，c++, php, python可以设置character-set，但java驱动依赖于 character-set-server 选项，后面有介绍。&lt;/p&gt;
&lt;p&gt;同时还要谨慎一些特殊选项，个人不建议设置全局 init_connect。&lt;/p&gt;
&lt;h1 id=&quot;key-767-bytes-错误&quot;&gt;&lt;a href=&quot;#key-767-bytes-错误&quot; class=&quot;headerlink&quot; title=&quot;key 767 bytes 错误&quot;&gt;&lt;/a&gt;key 767 bytes 错误&lt;/h1&gt;&lt;p&gt;字符集从utf8转到utf8mb4之后，最容易引起的就是索引键超长的问题。&lt;/p&gt;
&lt;p&gt;对于表行格式是 COMPACT或 REDUNDANT，InnoDB有单个索引最大字节数 768 的限制，而字段定义的是能存储的字符数，比如 VARCHAR(200) 代表能够存200个汉字，索引定义是字符集类型最大长度算的，即 utf8 maxbytes=3, utf8mb4 maxbytes=4，算下来utf8和utf8mb4两种情况的索引长度分别为600 bytes和800bytes，后者超过了767，导致出错：Error 1071: Specified key was too long; max key length is 767 bytes。&lt;/p&gt;
&lt;p&gt;COMPRESSED和DYNAMIC格式不受限制，但也依然不建议索引太长，太浪费空间和cpu搜索资源。&lt;/p&gt;
&lt;p&gt;如果已有定义超过这个长度的，可加上前缀索引，如果暂不能加上前缀索引（像唯一索引），可把该字段的字符集改回utf8或latin1。&lt;br&gt;但是，（ 敲黑板啦，很重要 ），要防止出现 Illegal mix of collations (utf8_general_ci,IMPLICIT) and (utf8mb4_general_ci,COERCIBLE) for operation ‘=’ 错误：连接字符集使用utf8mb4，但 SELECT/UPDATE where条件有utf8类型的列，且条件右边存在不属于utf8字符，就会触发该异常。表示踩过这个坑。&lt;/p&gt;
&lt;p&gt;再多加一个友好提示：EXPLAIN 结果里面的 key_len 指的搜索索引长度，单位是bytes，而且是以字符集支持的单字符最大字节数算的，这也是为什么 INDEX_LENGTH 膨胀厉害的一个原因。&lt;/p&gt;
&lt;h1 id=&quot;C-C-内存空间分配问题&quot;&gt;&lt;a href=&quot;#C-C-内存空间分配问题&quot; class=&quot;headerlink&quot; title=&quot;C/C++ 内存空间分配问题&quot;&gt;&lt;/a&gt;C/C++ 内存空间分配问题&lt;/h1&gt;&lt;p&gt;这是我们这边的开发遇到的一个棘手的问题。C或C++连接MySQL使用的是linux系统上的 libmysqlclient 动态库，程序获取到数据之后根据自定义的一个网络协议，按照mysql字段定义的固定字节数来传输数据。从utf8转utf8mb4之后，c++里面针对character单字符内存空间分配，从3个增加到4个，引起异常。&lt;/p&gt;
&lt;p&gt;这个问题其实是想说明，使用utf8mb4之后，官方建议尽量用 varchar 代替 char，这样可以减少固定存储空间浪费（关于char与varchar的选择，可参考 这里）。但开发设计表时 varchar 的大小不能随意加大，它虽然是变长的，但客户端在定义变量来获取数据时，是以定义的为准，而非实际长度。按需分配，避免程序使用过多的内存。&lt;/p&gt;
&lt;h1 id=&quot;java驱动使用&quot;&gt;&lt;a href=&quot;#java驱动使用&quot; class=&quot;headerlink&quot; title=&quot;java驱动使用&quot;&gt;&lt;/a&gt;java驱动使用&lt;/h1&gt;&lt;p&gt;Java语言里面所实现的UTF-8编码就是支持4字节的，所以不需要配置 mb4 这样的字眼，但如果从MySQL读写emoji，MySQL驱动版本要在 5.1.13 及以上版本，数据库连接依然是 characterEncoding=UTF-8 。&lt;/p&gt;
&lt;p&gt;但还没完，遇到一个大坑。官方手册 里还有这么一段话：&lt;/p&gt;
&lt;p&gt;Connector/J did not support utf8mb4 for servers 5.5.2 and newer.&lt;/p&gt;
&lt;p&gt;Connector/J now auto-detects servers configured with character_set_server=utf8mb4 or treats the Java encoding utf-8 passed&lt;br&gt;  using characterEncoding=… as utf8mb4 in the SET NAMES= calls it makes when establishing the connection. (Bug #54175)&lt;br&gt;意思是，java驱动会自动检测服务端 character_set_server 的配置，如果为utf8mb4，驱动在建立连接的时候设置 SET NAMES utf8mb4。然而其他语言没有依赖于这样的特性。&lt;/p&gt;
&lt;h1 id=&quot;主从复制报错&quot;&gt;&lt;a href=&quot;#主从复制报错&quot; class=&quot;headerlink&quot; title=&quot;主从复制报错&quot;&gt;&lt;/a&gt;主从复制报错&lt;/h1&gt;&lt;p&gt;这个问题没有遇到，只是看官方文档有提到，曾经也看到过类似的技术文章。&lt;br&gt;大概就是从库的版本比主库的版本低，导致有些字符集不支持；或者人工修改了从库上的表或字段的字符集定义，都有可能引起异常。&lt;/p&gt;
&lt;h1 id=&quot;join-查询问题&quot;&gt;&lt;a href=&quot;#join-查询问题&quot; class=&quot;headerlink&quot; title=&quot;join 查询问题&quot;&gt;&lt;/a&gt;join 查询问题&lt;/h1&gt;&lt;p&gt;这个问题是之前在姜承尧老师公众号看到的一篇文章 MySQL表字段字符集不同导致的索引失效问题，自己也验证了一下，的确会有问题：&lt;/p&gt;
&lt;p&gt;CREATE TABLE t1 (&lt;br&gt;  f_id varchar(20) NOT NULL,&lt;br&gt;  f_action char(25) NOT NULL DEFAULT ‘’ COMMENT ‘’,&lt;br&gt;  PRIMARY KEY (&lt;code&gt;f_id&lt;/code&gt;),&lt;br&gt;) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;&lt;/p&gt;
&lt;p&gt;CREATE TABLE t1_copy_mb4 (&lt;br&gt;  f_id varchar(20) CHARACTER SET utf8mb4 NOT NULL,&lt;br&gt;  f_action char(25) NOT NULL DEFAULT ‘’ COMMENT ‘’,&lt;br&gt;  PRIMARY KEY (&lt;code&gt;f_id&lt;/code&gt;),&lt;br&gt;) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;&lt;/p&gt;
&lt;p&gt;1.&lt;br&gt;EXPLAIN extended select * from t1 INNER JOIN t1_copy_mb4 t2 on t1.f_id=t2.f_id where t1.f_id=’421036’;&lt;/p&gt;
&lt;p&gt;2.&lt;br&gt;EXPLAIN extended select * from t1 INNER JOIN t1_copy_mb4 t2 on t1.f_id=t2.f_id where t2.f_id=’421036’;&lt;br&gt;对应上面1,2 的截图：&lt;/p&gt;
&lt;p&gt;其中 2 的warnings 有convert:&lt;/p&gt;
&lt;p&gt;(convert(t1.f_id using utf8mb4) = ‘421036’)&lt;br&gt;官网能找到这一点解释的还是开头那个地址：&lt;/p&gt;
&lt;p&gt;Similarly, the following comparison in the WHERE clause works according to the collation of utf8mb4_col:&lt;/p&gt;
&lt;p&gt;  SELECT * FROM utf8_tbl, utf8mb4_tbl&lt;br&gt;  WHERE utf8_tbl.utf8_col = utf8mb4_tbl.utf8mb4_col;&lt;br&gt;只是索引失效发生在utf8mb4列 在条件左边。（关于MySQL的隐式类型转换，见这里）。&lt;/p&gt;
&lt;p&gt;参考&lt;br&gt;&lt;a href=&quot;https://my.oschina.net/zhuguowei/blog/414476&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mysql latin1也支持emoji字符的错觉分析&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/cchust/p/4327019.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mysql字符集知识总结&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/charset-unicode-conversion.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/refman/8.0/en/charset-unicode-conversion.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://forums.mysql.com/read.php?103,187048,188748#msg-188748&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://forums.mysql.com/read.php?103,187048,188748#msg-188748&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://drupal.stackexchange.com/questions/166405/why-are-we-using-utf8mb4-general-ci-and-not-utf8mb4-unicode-ci&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Why are we using utf8mb4_general_ci and not utf8mb4_unicode_ci?&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://mathiasbynens.be/notes/mysql-utf8mb4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How to support full Unicode in MySQL databases&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://cenalulu.github.io/mysql/mysql-mojibake/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;10分钟学会理解和解决MySQL乱码问题&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;标准UTF-8字符集&quot;&gt;&lt;a href=&quot;#标准UTF-8字符集&quot; class=&quot;headerlink&quot; title=&quot;标准UTF-8字符集&quot;&gt;&lt;/a&gt;标准UTF-8字符集&lt;/h1&gt;&lt;p&gt;UTF-8（8-bit Unicode Transformatio
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="字符集" scheme="http://idber.github.io/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>在Mac上使用CLion编译MySQL</title>
    <link href="http://idber.github.io/2019/05/09-%E5%9C%A8Mac%E4%B8%8A%E4%BD%BF%E7%94%A8CLion%E7%BC%96%E8%AF%91MySQL.html"/>
    <id>http://idber.github.io/2019/05/09-在Mac上使用CLion编译MySQL.html</id>
    <published>2019-05-09T02:01:56.000Z</published>
    <updated>2019-05-09T07:29:18.693Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h1 id=&quot;源码获取&quot;&gt;&lt;a href=&quot;#源码获取&quot; class=&quot;headerlink&quot; title=&quot;源码获取&quot;&gt;&lt;/a&gt;源码获取&lt;/h1&gt;&lt;p&gt;git clone &lt;a href=&quot;https://github.com/mysql/mysql-server&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/mysql/mysql-server&lt;/a&gt;&lt;br&gt;or&lt;br&gt;&lt;a href=&quot;https://dev.mysql.com/downloads/mysql/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/downloads/mysql/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解压&lt;br&gt;mysql-server 为源码目录&lt;br&gt;新建mysql、data目录&lt;br&gt;mysql为basedir&lt;br&gt;data为datadir&lt;/p&gt;
&lt;h1 id=&quot;编译安装初始化数据库&quot;&gt;&lt;a href=&quot;#编译安装初始化数据库&quot; class=&quot;headerlink&quot; title=&quot;编译安装初始化数据库&quot;&gt;&lt;/a&gt;编译安装初始化数据库&lt;/h1&gt;&lt;p&gt;cd mysql-server&lt;/p&gt;
&lt;p&gt;cmake \&lt;br&gt;-DCMAKE_INSTALL_PREFIX=/your_path/mysql \&lt;br&gt;-DMYSQL_DATADIR=/your_path/mysql/data \&lt;br&gt;-DSYSCONFDIR=/your_path/mysql \&lt;br&gt;-DMYSQL_UNIX_ADDR=/your_path/mysql/mysql.sock \&lt;br&gt;-DWITH_DEBUG=1  \&lt;br&gt;-DDOWNLOAD_BOOST=1 -DWITH_BOOST=/your_path/mysql-server/ -DDOWNLOAD_BOOST_TIMEOUT=60000&lt;/p&gt;
&lt;p&gt;make -j 4 &lt;/p&gt;
&lt;p&gt;make install -j 4&lt;/p&gt;
&lt;h1 id=&quot;初始化数据库&quot;&gt;&lt;a href=&quot;#初始化数据库&quot; class=&quot;headerlink&quot; title=&quot;初始化数据库&quot;&gt;&lt;/a&gt;初始化数据库&lt;/h1&gt;&lt;p&gt;/your_path/mysql/scripts/mysql_install_db –user=mysql –basedir=/your_path/mysql –datadir=/Users/xmzj/SourceCode/mysql/data&lt;br&gt;不同版本数据库有不同初始化方式，本文使用的是MySQL 5.6&lt;/p&gt;
&lt;p&gt;启动MySQL，测试下是否安装成功&lt;/p&gt;
&lt;p&gt;/path/mysql/bin/mysqld –defaults-file=/path/mysql/my.cnf&lt;/p&gt;
&lt;p&gt;在CLion欢迎页选择New CMake Project from Sources,选中CMakeLists.txt，Open Existing Project&lt;br&gt;CLion会自动Load工程&lt;br&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/source_code/source_code01.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;然后，CLion 偏好设置，Build, Execution, Deployment 的CMake选项&lt;br&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/source_code/source_code02.jpeg?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;CMake Options和你编译安装时的选项一致&lt;/p&gt;
&lt;p&gt;-DCMAKE_INSTALL_PREFIX=/path/mysql&lt;br&gt;-DMYSQL_DATADIR=/path/mysql/data&lt;br&gt;-DSYSCONFDIR=/path/mysql&lt;br&gt;-DMYSQL_UNIX_ADDR=/path/mysql/mysql.sock&lt;br&gt;-DWITH_DEBUG=1  &lt;/p&gt;
&lt;p&gt;然后在CLion里，Reload CMake Project&lt;br&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/source_code/source_code03.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Run/Debug列表里就可以看到很多选项了 Edit Configurations…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/source_code/source_code04.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;找到mysqld配置下启动参数 mysqld配置下启动参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/source_code/source_code05.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;mysqld –defaults-file=/path/mysql/etc/my.cnf&lt;br&gt;然后以Debug模式启动，看下成功的效果 Debug模式启动&lt;br&gt;这里故意把ib_qry_type_t改为0ib_qry_type_t 让它报错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/source_code/source_code06.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;学习MySQL源码的文档&quot;&gt;&lt;a href=&quot;#学习MySQL源码的文档&quot; class=&quot;headerlink&quot; title=&quot;学习MySQL源码的文档&quot;&gt;&lt;/a&gt;学习MySQL源码的文档&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/internals/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/internals/en/&lt;/a&gt;&lt;br&gt;可以找到想要学习的功能的源码位置，比如主从同步功能（replication） &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/internals/en/replication-source-code-files.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/internals/en/replication-source-code-files.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;源码获取&quot;&gt;&lt;a href=&quot;#源码获取&quot; class=&quot;headerlink&quot; title=&quot;源码获取&quot;&gt;&lt;/a&gt;源码获取&lt;/h1&gt;&lt;p&gt;git clone &lt;a href=&quot;https://github.com/mysql/mysql-server&quot;
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="源码" scheme="http://idber.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的三种排序算法</title>
    <link href="http://idber.github.io/2019/04/28-MySQL%E7%9A%84%E4%B8%89%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html"/>
    <id>http://idber.github.io/2019/04/28-MySQL的三种排序算法.html</id>
    <published>2019-04-28T02:01:56.000Z</published>
    <updated>2019-04-30T03:17:35.940Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;MySQL内部实现排序主要有3种方式，常规排序，优化排序和优先队列排序，主要涉及3种排序算法：快速排序、归并排序和堆排序。&lt;/p&gt;
&lt;p&gt;关于排序算法，Youtube上有套有意思的3D机器人演示视频命令，方便理解。&lt;br&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=aXXWXz5rF64&amp;amp;index=2&amp;amp;list=PL2aHrV9pFqNRS2b2XX2BvgQIPKh72xREP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;via&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;p&gt;快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/p&gt;
&lt;p&gt;快速排序是对冒泡排序的一种改进。在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。&lt;/p&gt;
&lt;p&gt;快速排序使用分治法（Divide and conquer， 在计算机科学中，分治法是建基于多项分支递归的一种很重要的算法范式。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。&lt;/p&gt;
&lt;p&gt;步骤为：&lt;br&gt;挑选基准值：从数列中挑出一个元素，称为“基准”（pivot），&lt;br&gt;分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，&lt;br&gt;递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。&lt;br&gt;递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。&lt;/p&gt;
&lt;p&gt;由于基准是随机的，所以快速排序是不稳定排序。&lt;/p&gt;
&lt;h1 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h1&gt;&lt;p&gt;归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。&lt;br&gt;把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。&lt;br&gt;可从上到下或从下到上进行。&lt;/p&gt;
&lt;p&gt;归并操作&lt;br&gt;归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。&lt;/p&gt;
&lt;p&gt;步骤为：&lt;br&gt;申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列&lt;br&gt;设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;br&gt;比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&lt;br&gt;重复步骤3直到某一指针到达序列尾&lt;br&gt;将另一序列剩下的所有元素直接复制到合并序列尾&lt;/p&gt;
&lt;h1 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h1&gt;&lt;p&gt;堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。&lt;br&gt;从堆顶把根卸出来放在有序区之前，再恢复堆。&lt;/p&gt;
&lt;p&gt;若以升序排序说明，把数组转换成最大堆积(Max-Heap Heap)，这是一种满足最大堆积性质(Max-Heap Property)的二叉树：对于除了根之外的每个节点i, A[parent(i)] ≥ A[i]。&lt;/p&gt;
&lt;p&gt;重复从最大堆积取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆积维持最大堆积性质。&lt;/p&gt;
&lt;p&gt;堆的操作&lt;br&gt;在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作：&lt;br&gt;最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点&lt;br&gt;创建最大堆（Build Max Heap）：将堆中的所有数据重新排序&lt;br&gt;堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算&lt;/p&gt;
&lt;h1 id=&quot;MySQL的排序&quot;&gt;&lt;a href=&quot;#MySQL的排序&quot; class=&quot;headerlink&quot; title=&quot;MySQL的排序&quot;&gt;&lt;/a&gt;MySQL的排序&lt;/h1&gt;&lt;p&gt;a.常规排序&lt;br&gt;(1).从表t1中获取满足WHERE条件的记录&lt;br&gt;(2).对于每条记录，将记录的主键+排序键(id,col2)取出放入sort buffer&lt;br&gt;(3).如果sort buffer可以存放所有满足条件的(id,col2)对，则进行排序；否则sort buffer满后，进行排序并固化到临时文件中。(排序算法采用的是快速排序算法)&lt;br&gt;(4).若排序中产生了临时文件，需要利用归并排序算法，保证临时文件中记录是有序的&lt;br&gt;(5).循环执行上述过程，直到所有满足条件的记录全部参与排序&lt;br&gt;(6).扫描排好序的(id,col2)对，并利用id去捞取SELECT需要返回的列(col1,col2,col3)&lt;br&gt;(7).将获取的结果集返回给用户。&lt;br&gt;      从上述流程来看，是否使用文件排序主要看sort buffer是否能容下需要排序的(id,col2)对，这个buffer的大小由sort_buffer_size参数控制。此外一次排序需要两次IO，一次是捞(id,col2),第二次是捞(col1,col2,col3)，由于返回的结果集是按col2排序，因此id是乱序的，通过乱序的id去捞(col1,col2,col3)时会产生大量的随机IO。对于第二次MySQL本身一个优化，即在捞之前首先将id排序，并放入缓冲区，这个缓存区大小由参数read_rnd_buffer_size控制，然后有序去捞记录，将随机IO转为顺序IO。&lt;/p&gt;
&lt;p&gt;b.优化排序&lt;br&gt;     常规排序方式除了排序本身，还需要额外两次IO。优化的排序方式相对于常规排序，减少了第二次IO。主要区别在于，放入sort buffer不是(id,col2),而是(col1,col2,col3)。由于sort buffer中包含了查询需要的所有字段，因此排序完成后可以直接返回，无需二次捞数据。这种方式的代价在于，同样大小的sort buffer，能存放的(col1,col2,col3)数目要小于(id,col2)，如果sort buffer不够大，可能导致需要写临时文件，造成额外的IO。当然MySQL提供了参数max_length_for_sort_data，只有当排序元组小于max_length_for_sort_data时，才能利用优化排序方式，否则只能用常规排序方式。&lt;/p&gt;
&lt;p&gt;c.优先队列排序&lt;br&gt;     为了得到最终的排序结果，无论怎样，我们都需要将所有满足条件的记录进行排序才能返回。那么相对于优化排序方式，是否还有优化空间呢？5.6版本针对Order by limit M，N语句，在空间层面做了优化，加入了一种新的排序方式–优先队列，这种方式采用堆排序实现。堆排序算法特征正好可以解limit M，N 这类排序的问题，虽然仍然需要所有元素参与排序，但是只需要M+N个元组的sort buffer空间即可，对于M，N很小的场景，基本不会因为sort buffer不够而导致需要临时文件进行归并排序的问题。对于升序，采用大顶堆，最终堆中的元素组成了最小的N个元素，对于降序，采用小顶堆，最终堆中的元素组成了最大的N的元素。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;MySQL内部实现排序主要有3种方式，常规排序，优化排序和优先队列排序，主要涉及3种排序算法：快速排序、归并排序和堆排序。&lt;/p&gt;
&lt;p&gt;关于排序算法，Youtube上有套有意思的3D机器人演示视频命令，方便理解。&lt;br&gt;&lt;a href=&quot;https://www.
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="排序" scheme="http://idber.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="优化" scheme="http://idber.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Purge死锁</title>
    <link href="http://idber.github.io/2018/10/01-Purge%E6%AD%BB%E9%94%81.html"/>
    <id>http://idber.github.io/2018/10/01-Purge死锁.html</id>
    <published>2018-09-30T22:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.932Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;p&gt;场景：业务批量删除，然后插入操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select @@tx_isolation;
+----------------+
| @@tx_isolation |
+----------------+
| READ-COMMITTED |
+----------------+
1 row in set, 1 warning (0.00 sec)

set global innodb_status_output_locks=1;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启用后，InnoDB锁定监视器会打印有关SHOW ENGINE INNODB STATUS输出锁定的附加信息&lt;/p&gt;
&lt;p&gt;为了演示繁忙的场景，使用debug版本启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/home/mysql/mysql/bin/mysqld-debug --basedir=/home/mysql/mysql --datadir=/home/mysql/data

set global innodb_purge_stop_now=1;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;show这个变量􏰀,结果还是off,这个不用管,purge线程已􏰁停止了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table test_purge(a int auto_increment primary key, b int , unique key(b));

insert into test_purge(b) values(10),(20),(30),(40),(50),(60);

select * from test_purge;
+---+------+
| a | b    |
+---+------+
| 1 |   10 |
| 2 |   20 |
| 3 |   30 |
| 4 |   40 |
| 5 |   50 |
| 6 |   60 |
+---+------+
6 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;加锁过程&quot;&gt;&lt;a href=&quot;#加锁过程&quot; class=&quot;headerlink&quot; title=&quot;加锁过程&quot;&gt;&lt;/a&gt;加锁过程&lt;/h1&gt;&lt;p&gt;终端会话1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delete from test_purge where b=20;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;终端会话2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from test_purge;
beign;
insert into test_purge(b) values(20);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;终端会话3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pager less


show engine innodb status\G

---TRANSACTION 3342, ACTIVE 22 sec
3 lock struct(s), heap size 1160, 3 row lock(s), undo log entries 1
MySQL thread id 4, OS thread handle 139843750467328, query id 11 localhost root
TABLE LOCK table `guo_test`.`test_purge` trx id 3342 lock mode IX
RECORD LOCKS space id 28 page no 4 n bits 72 index b of table `guo_test`.`test_purge` trx id 3342 lock mode S
Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 32
 0: len 4; hex 80000014; asc     ;;
 1: len 4; hex 80000002; asc     ;;

-- heap no=3表示是第二个插入的记录20
-- 且info bits为32,表示记录被标记删除了
0: len 4; hex 80000014; asc ;; -- 记录为20
1: len 4; hex 80000002; asc ;; -- 对应的主键为2


Record lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 4; hex 8000001e; asc     ;;
 1: len 4; hex 80000003; asc     ;;
-- heap no=4表示的是20的下一个记录30
-- 且该记录上也有S lock
RECORD LOCKS space id 28 page no 4 n bits 72 index b of table `guo_test`.`test_purge` trx id 3342 lock mode S locks gap before rec
Record lock, heap no 6 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 #heap no=6为新插入的记录20,从隐式锁提升为显示锁
 0: len 4; hex 80000014; asc     ;;
 1: len 4; hex 80000005; asc     ;;
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;因为是唯一索引,需要做唯一性检查,从老的记录 20&lt;em&gt; 开始检查(第一个小于等于自己的值),则此时 20&lt;/em&gt; 上要加上一把 S lock ,然后往下检查到第一个不相等的记录,即 记录30 ,然后退出,但是这个 记录30 也要 加上S lock&lt;/li&gt;
&lt;li&gt;在插入新的记录20的时候,发现下一条记录30上有锁,则自己插入的时的隐式锁提升为显示锁(见插入步骤)&lt;/li&gt;
&lt;li&gt;目前锁住的范围是 (10,20], (20,30]&lt;/li&gt;
&lt;li&gt;新插入的记录20本身是一把 S-Gap Lock (前面20*的有S lock了,由于是唯一索引,本身其实就不需要有记录锁了,有GAP就够了)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以25，15都无法插入，都在锁定区间&lt;br&gt;会话3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@guo_test 01:48:14&amp;gt;insert into test_purge(b) values(25);
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
root@guo_test 01:48:23&amp;gt;insert into test_purge(b) values(15);
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;Purge死锁演示&quot;&gt;&lt;a href=&quot;#Purge死锁演示&quot; class=&quot;headerlink&quot; title=&quot;Purge死锁演示&quot;&gt;&lt;/a&gt;Purge死锁演示&lt;/h1&gt;&lt;p&gt;删除50，20前面已经删除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delete from test_purge where b=50;
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;T1&lt;/th&gt;
&lt;th&gt;T2&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;begin;&lt;/td&gt;
&lt;td&gt;begin;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insert into test_purge(b) values(25);&lt;/td&gt;
&lt;td&gt;insert into test_purge(b) values(55);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insert into test_purge(b) values(50);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;insert into test_purge(b) values(20);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Deadlock found..&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insert into test_purge(b) values(50);Query OK, 1 row affected (2.32 sec)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;show engine innodb status\G&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LATEST DETECTED DEADLOCK
------------------------
2018-09-18 12:25:41 0x7ff339aca700
*** (1) TRANSACTION:
TRANSACTION 6692, ACTIVE 53 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 4 lock struct(s), heap size 1160, 4 row lock(s), undo log entries 2
MySQL thread id 4, OS thread handle 140682621667072, query id 27 localhost root update
insert into test_purge(b) values(50)
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 35 page no 4 n bits 80 index b of table `guo_test`.`test_purge` trx id 6692 lock mode S waiting
Record lock, heap no 9 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 4; hex 80000037; asc    7;;     #等待55的S锁
 1: len 4; hex 80000008; asc     ;;

*** (2) TRANSACTION:
TRANSACTION 6693, ACTIVE 28 sec inserting, thread declared inside InnoDB 5000
mysql tables in use 1, locked 1
4 lock struct(s), heap size 1160, 4 row lock(s), undo log entries 2
MySQL thread id 5, OS thread handle 140682621396736, query id 28 localhost root update
insert into test_purge(b) values(20)
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 35 page no 4 n bits 80 index b of table `guo_test`.`test_purge` trx id 6693 lock_mode X locks rec but not gap
Record lock, heap no 9 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 4; hex 80000037; asc    7;;      #持有55的S锁
 1: len 4; hex 80000008; asc     ;;

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 35 page no 4 n bits 80 index b of table `guo_test`.`test_purge` trx id 6693 lock mode S waiting
Record lock, heap no 8 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 4; hex 80000019; asc     ;;      #等待25的S锁
 1: len 4; hex 80000007; asc     ;;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;该问题的场景&quot;&gt;&lt;a href=&quot;#该问题的场景&quot; class=&quot;headerlink&quot; title=&quot;该问题的场景&quot;&gt;&lt;/a&gt;该问题的场景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;使用了唯一索引(主要原因)&lt;/li&gt;
&lt;li&gt;大量delete数据后,又立即插入了数据&lt;/li&gt;
&lt;li&gt;插入的数据和部分删除的数据的唯一索引一样,且purge还没有来得及回收删除的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;解决办法&quot;&gt;&lt;a href=&quot;#解决办法&quot; class=&quot;headerlink&quot; title=&quot;解决办法&quot;&gt;&lt;/a&gt;解决办法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;delete后等待较长时间后(增大purge线程数,等Purge回收),再插入新数据 (不推荐) &lt;/li&gt;
&lt;li&gt;使用普通索引&lt;/li&gt;
&lt;li&gt;仍然使用唯一索引,但是插入前要对唯一索引进行分线程排序 (只会有等待,不会有死锁)&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;p&gt;场景：业务批量删除，然后插入操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select @@tx_isolation;
+-
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="死锁" scheme="http://idber.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Percona Xtrabackup 2.4 恢复指定表</title>
    <link href="http://idber.github.io/2018/09/09-Percona%20Xtrabackup%202.4%20%E6%81%A2%E5%A4%8D%E6%8C%87%E5%AE%9A%E8%A1%A8.html"/>
    <id>http://idber.github.io/2018/09/09-Percona Xtrabackup 2.4 恢复指定表.html</id>
    <published>2018-09-08T22:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.932Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;在5.6之前的服务版本，在不同的MySQL服务中通过复制表的文件来拷贝表是不可能的，即使启用了innodb_file_per_table。然而，通过Percona XtraBackup，可以从任意的InnoDB数据库中导出指定的表，并将它们导入到使用XtraDB的Percona服务中或MySQL 5.6。这只对.ibd文件有效。 &lt;/p&gt;
&lt;p&gt;创建测试表 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE `export_test` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `a` varchar(60) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3   ROW_FORMAT=DYNAMIC  DEFAULT CHARSET=utf8

insert into `test`.`export_test` ( `a`) values ( &amp;apos;aaa&amp;apos;);
insert into `test`.`export_test` ( `a`) values ( &amp;apos;ddd&amp;apos;);
insert into `test`.`export_test` ( `a`) values ( &amp;apos;ccc&amp;apos;);
insert into `test`.`export_test` ( `a`) values ( &amp;apos;dddccc&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;确认innodb_file_per_table是否开启&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show variables like &amp;apos;innodb_file_per_table&amp;apos;; 
+-----------------------+-------+ 
| Variable_name         | Value | 
+-----------------------+-------+ 
| innodb_file_per_table | ON    | 
+-----------------------+-------+ 
1 row in set (0.00 sec) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;确认行格式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show variables like &amp;apos;%format%&amp;apos;;
+---------------------------+-------------------+
| Variable_name             | Value             |
+---------------------------+-------------------+
| binlog_format             | ROW               |
| date_format               | %Y-%m-%d          |
| datetime_format           | %Y-%m-%d %H:%i:%s |
| default_week_format       | 0                 |
| innodb_default_row_format | dynamic           |
| innodb_file_format        | Barracuda         |
| innodb_file_format_check  | ON                |
| innodb_file_format_max    | Barracuda         |
| time_format               | %H:%i:%s          |
+---------------------------+-------------------+
9 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行备份 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;innobackupex --defaults-file=/etc/my.cnf --user=bkuser --password=xxxx  --socket=/tmp/mysql.sock ~/backup/fullbackup/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;导出的表必须是以 innodb_file_per_table 格式创建，在备份目录中以.bd文件格式存在。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;find . -name export_test.*
./guo_test/export_test.ibd
./guo_test/export_test.frm
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当准备备份的时候，增加xtrabackup –export参数到命令中。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;innobackupex --user=root --password=root --no-timestamp --apply-log --export ./
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在目标目录下，可以看到.exp文件 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;find . -name export_test.*
./guo_test/export_test.ibd
./guo_test/export_test.exp
./guo_test/export_test.cfg
./guo_test/export_test.frm
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;.exp、.ibd、.cfg这三个文件用于数据库导入中&lt;br&gt;Percona官方对这三个文件的描述&lt;br&gt;After this, copy mytable.ibd and mytable.exp ( or mytable.cfg if importing to MySQL 5.6) files to database’s home, and import its tablespace:&lt;/p&gt;
&lt;p&gt;删除表 （如果表结构一致可以不用删除）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;drop table export_test; 
Query OK, 0 rows affected (1.45 sec) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在目标MySQL服务器上，创建一张具有相同结构的空表。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLE `export_test` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `a` varchar(60) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3   ROW_FORMAT=DYNAMIC  DEFAULT CHARSET=utf8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;清除表空间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE export_test DISCARD  TABLESPACE;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;拷贝导出文件到数据目录中 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cp -f  ~/export_test.* ./
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更改文件权限为mysql &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chown -R mysql:mysql .  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;导入表空间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE export_test IMPORT TABLESPACE;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;验证表中的数据 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; select * from `test`.`export_test`;
+----+--------+
| id | a      |
+----+--------+
| 1  | aaa    |
| 2  | ddd    |
| 3  | ccc    |
| 4  | dddccc |
+----+--------+
4 rows in set (0.02 sec)

mysql&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;常见错误&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;ERROR 1815 (HY000): Internal error: Cannot reset LSNs in table &amp;apos;&amp;quot;test&amp;quot;.&amp;quot;export_test&amp;quot;&amp;apos; : Tablespace not found 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看export文件权限、export文件是否都已经导入到数据库目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;ERROR 1030 (HY000): Got error -1 from storage engine
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;检查innodb_file_per_table是否开启&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;Error : Schema mismatch (Table flags don&amp;apos;t match, server table has 0x0 and the meta-data file has 0x1)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;检查表ROW_FORMAT、innodb_file_format&lt;br&gt;以前支持COMPACT、REDUNDANT的innodb_file_format文件格式为Antelope，新的文件格式为Barracuda，新增格式Compressed、dynamic&lt;br&gt;    innodb_file_format&lt;br&gt;    Default Value (&amp;gt;= 5.7.7)    Barracuda&lt;br&gt;    Default Value (&amp;lt;= 5.7.6)    Antelope&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;在5.6之前的服务版本，在不同的MySQL服务中通过复制表的文件来拷贝表是不可能的，即使启用了innodb_file_per_table。然而，通过Percona XtraBackup，可以从任意的InnoDB数据库中导出指定的表，并将它们导入到使用XtraDB的
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="备份恢复" scheme="http://idber.github.io/tags/%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>ProxySQL 安装配置详解及读写分离、负载均衡</title>
    <link href="http://idber.github.io/2018/08/28-ProxySQL%20%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html"/>
    <id>http://idber.github.io/2018/08/28-ProxySQL 安装配置详解及读写分离、负载均衡.html</id>
    <published>2018-08-27T22:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.932Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在MySQL的高可用集群环境中，中间件是不可缺少的一部分，它提供了读写分离、负载均衡等各种功能，满足集群的横向、纵向的可扩展。由于官方并没有在这方面推出好的产品，更多的是第三方的产品。如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ProxySQL #Percona&lt;/li&gt;
&lt;li&gt;MaxScale #MariaDB&lt;/li&gt;
&lt;li&gt;Atlas #360开源&lt;/li&gt;
&lt;li&gt;OneProxy #平民软件楼方鑫&lt;/li&gt;
&lt;li&gt;MyCat #社区推广&lt;/li&gt;
&lt;li&gt;KingShard #原Atlas作者离职后使用go开发&lt;/li&gt;
&lt;li&gt;TDDL #阿里巴巴开源&lt;/li&gt;
&lt;li&gt;Cobar #阿里巴巴开源&lt;/li&gt;
&lt;li&gt;DBProxy #美团在360Atlas上修改后开源&lt;/li&gt;
&lt;li&gt;Fabric #官方产品&lt;/li&gt;
&lt;li&gt;DRDS #阿里云分库分表产品&lt;/li&gt;
&lt;li&gt;本次以测试ProxySQL为例，逐步了解ProxySQL的使用方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h1&gt;&lt;p&gt;环境：&lt;br&gt;ProxySQL: 1.4.1&lt;br&gt;Master: 192.168.56.101&lt;br&gt;Slave: 192.168.56.102&lt;/p&gt;
&lt;h1 id=&quot;安装配置详解&quot;&gt;&lt;a href=&quot;#安装配置详解&quot; class=&quot;headerlink&quot; title=&quot;安装配置详解&quot;&gt;&lt;/a&gt;安装配置详解&lt;/h1&gt;&lt;p&gt;官网：&lt;a href=&quot;http://www.proxysql.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.proxysql.com/&lt;/a&gt;&lt;br&gt;Percona地址：&lt;a href=&quot;https://www.percona.com/downloads/proxysql/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.percona.com/downloads/proxysql/&lt;/a&gt;&lt;br&gt;Github地址：&lt;a href=&quot;https://github.com/sysown/proxysql/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sysown/proxysql/&lt;/a&gt;&lt;br&gt;本文通过作者编译好的rpm安装，也可通过编译安装的方式安装，本文省略&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;下载proxysql可以有三种途径,分别为官网、Percona网站和Github网站&lt;br&gt;本文从github上下载最新稳定版本，这里选择centos67对应的rpm包&lt;br&gt;下载：wget -c -O proxysql-1.4.1-1-centos67.x86_64.rpm &lt;a href=&quot;https://github.com/sysown/proxysql/releases/download/v1.4.1/proxysql-1.4.1-1-centos67.x86_64.rpm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sysown/proxysql/releases/download/v1.4.1/proxysql-1.4.1-1-centos67.x86_64.rpm&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@mysql test]# yum localinstall -y proxysql-1.4.1-1-centos67.x86_64.rpm
Loaded plugins: security
docker-main-repo                                                                                                                                 | 2.9 kB     00:00     
Setting up Install Process
Resolving Dependencies
There are unfinished transactions remaining. You might consider running yum-complete-transaction first to finish them.
--&amp;gt; Running transaction check
---&amp;gt; Package proxysql.x86_64 0:1.4.1-1 will be installed
--&amp;gt; Finished Dependency Resolution
Dependencies Resolved
========================================================================================================================================================================
 Package                           Arch                            Version                             Repository                                                  Size
========================================================================================================================================================================
Installing:
 proxysql                          x86_64                          1.4.1-1                             /proxysql-1.4.1-1-centos67.x86_64                           19 M
Transaction Summary
========================================================================================================================================================================
Install       1 Package(s)
Total size: 19 M
Installed size: 19 M
Downloading Packages:
Running rpm_check_debug
Running Transaction Test
Transaction Test Succeeded
Running Transaction
  Installing : proxysql-1.4.1-1.x86_64                                                                                                                              1/1 
  Verifying  : proxysql-1.4.1-1.x86_64                                                                                                                              1/1 
Installed:
  proxysql.x86_64 0:1.4.1-1                                                                                                                                             
Complete!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ProxySQL默认配置文件为/etc/proxysql.cnf,只在第一次启动的时候有用,后续的所有配置都是通过对SQLite数据库的操作,并且不会更新到proxysql中,而是存储在/var/lib/proxysql/proxysql.db中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@mysql_slave test]#  proxysql --version    #查看版本
ProxySQL version 1.4.1-45-gab4e6ee, codename Truls
[root@mysql_slave test]# rpm -ql proxysql   #查看安装的具体内容
/etc/init.d/proxysql                    #启动脚本
/etc/proxysql.cnf                       #默认配置文件
/usr/bin/proxysql                       #执行文件
/usr/share/proxysql/tools/proxysql_galera_checker.sh    #ProxySQL调度程序检查pxc_maint_mode参数状态,持续检测各个节点的状态
/usr/share/proxysql/tools/proxysql_galera_writer.pl #ProxySQL指定一个节点直接将流量写入galera
[root@mysql_slave test]#
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;启动&quot;&gt;&lt;a href=&quot;#启动&quot; class=&quot;headerlink&quot; title=&quot;启动&quot;&gt;&lt;/a&gt;启动&lt;/h2&gt;&lt;p&gt;启动之后才会生成存储目录/var/lib/proxysql&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@mysql_slave test]# /etc/init.d/proxysql start
Starting ProxySQL: DONE!
[root@mysql_slave test]# ll /var/lib/proxysql/
总用量 108
-rw------- 1 root root 98304 8月  29 15:37 proxysql.db
-rw------- 1 root root  4306 8月  29 16:25 proxysql.log
-rw-r--r-- 1 root root     5 8月  29 16:25 proxysql.pid
[root@mysql_slave test]#
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;内置对象介绍&quot;&gt;&lt;a href=&quot;#内置对象介绍&quot; class=&quot;headerlink&quot; title=&quot;内置对象介绍&quot;&gt;&lt;/a&gt;内置对象介绍&lt;/h1&gt;&lt;h2 id=&quot;登录&quot;&gt;&lt;a href=&quot;#登录&quot; class=&quot;headerlink&quot; title=&quot;登录&quot;&gt;&lt;/a&gt;登录&lt;/h2&gt;&lt;p&gt;启动了6032和6033两个端口,默认管理端口是6032,客户端服务端口是6033,默认的用户名密码都是 admin,通过mysql的客户端可以登录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@mysql_slave test]# netstat -tunlp|grep proxysql
tcp        0      0 0.0.0.0:6032                0.0.0.0:*                   LISTEN      5181/proxysql       
tcp        0      0 0.0.0.0:6033                0.0.0.0:*                   LISTEN      5181/proxysql       
[root@mysql_slave test]# mysql -uadmin -padmin -h127.0.0.1 -P6032
Warning: Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 1
Server version: 5.5.30 (ProxySQL Admin Module)
Copyright (c) 2009-2017 Percona LLC and/or its affiliates
Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.
Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.
Type &amp;apos;help;&amp;apos; or &amp;apos;\h&amp;apos; for help. Type &amp;apos;\c&amp;apos; to clear the current input statement.
MySQL [(none)] 16:28:32 &amp;gt; show databases;
+-----+---------+-------------------------------+
| seq | name    | file                          |
+-----+---------+-------------------------------+
| 0   | main    |                               |
| 2   | disk    | /var/lib/proxysql/proxysql.db |
| 3   | stats   |                               |
| 4   | monitor |                               |
+-----+---------+-------------------------------+
4 rows in set (0.00 sec)
MySQL [(none)] 16:28:41 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;内置库&quot;&gt;&lt;a href=&quot;#内置库&quot; class=&quot;headerlink&quot; title=&quot;内置库&quot;&gt;&lt;/a&gt;内置库&lt;/h2&gt;&lt;p&gt;main：默认数据库名,用于存放后端db实例、用户认证、路由规则等信息。表名以runtime开头的表示proxysql当前运行的配置内容，不能通过dml语句修改。只能修改对应的不以runtime开头的（在内存）里的表，然后LOAD使其生效，SAVE使其存到硬盘以供下次重启加载。&lt;br&gt;disk：是持久化到硬盘的配置，sqlite数据文件。&lt;br&gt;stats：是proxysql运行抓取的统计信息，包括到后端各命令的执行次数、流量、processlist、查询各类汇总、执行时间等。&lt;br&gt;monitor：库存储monitor模块收集的信息，主要是对后端db的健康、延迟检查。&lt;/p&gt;
&lt;h3 id=&quot;main库&quot;&gt;&lt;a href=&quot;#main库&quot; class=&quot;headerlink&quot; title=&quot;main库&quot;&gt;&lt;/a&gt;main库&lt;/h3&gt;&lt;h4 id=&quot;runtime-表&quot;&gt;&lt;a href=&quot;#runtime-表&quot; class=&quot;headerlink&quot; title=&quot;runtime_表&quot;&gt;&lt;/a&gt;runtime_表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [main] 17:19:10 &amp;gt; use main
Database changed
MySQL [main] 17:22:15 &amp;gt; show tables;
+--------------------------------------------+
| tables                                     |
+--------------------------------------------+
| global_variables                           |
| mysql_collations                           |
| mysql_group_replication_hostgroups         |
| mysql_query_rules                          |
| mysql_replication_hostgroups               |
| mysql_servers                              |
| mysql_users                                |
| proxysql_servers                           |
| runtime_global_variables                   |
| runtime_mysql_group_replication_hostgroups |
| runtime_mysql_query_rules                  |
| runtime_mysql_replication_hostgroups       |
| runtime_mysql_servers                      |
| runtime_mysql_users                        |
| runtime_proxysql_servers                   |
| runtime_scheduler                          |
| scheduler                                  |
+--------------------------------------------+
17 rows in set (0.00 sec)
MySQL [main] 17:22:16 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，runtime_开关的表如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;runtime_global_variables：global_variables的运行时版本
runtime_mysql_group_replication_hostgroups：mysql_group_replication_hostgroups的运行时版本
runtime_mysql_query_rules：mysql_query_rules的运行时版本
runtime_mysql_replication_hostgroups：mysql_replication_hostsgroups的运行时版本
runtime_mysql_servers：mysql_servers的运行时版本
runtime_mysql_users：mysql_users的运行时版本
runtime_scheduler：scheduler调度程序的运行时版本

global_variables表
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内置参数表，参考下文&lt;/p&gt;
&lt;h4 id=&quot;mysql-servers表&quot;&gt;&lt;a href=&quot;#mysql-servers表&quot; class=&quot;headerlink&quot; title=&quot;mysql_servers表&quot;&gt;&lt;/a&gt;mysql_servers表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [main] 17:22:16 &amp;gt; show create table mysql_servers\G
*************************** 1. row ***************************
       table: mysql_servers
Create Table: CREATE TABLE mysql_servers (
    hostgroup_id INT NOT NULL DEFAULT 0,
    hostname VARCHAR NOT NULL,
    port INT NOT NULL DEFAULT 3306,
    status VARCHAR CHECK (UPPER(status) IN (&amp;apos;ONLINE&amp;apos;,&amp;apos;SHUNNED&amp;apos;,&amp;apos;OFFLINE_SOFT&amp;apos;, &amp;apos;OFFLINE_HARD&amp;apos;)) NOT NULL DEFAULT &amp;apos;ONLINE&amp;apos;,
    weight INT CHECK (weight &amp;gt;= 0) NOT NULL DEFAULT 1,
    compression INT CHECK (compression &amp;gt;=0 AND compression &amp;lt;= 102400) NOT NULL DEFAULT 0,
    max_connections INT CHECK (max_connections &amp;gt;=0) NOT NULL DEFAULT 1000,
    max_replication_lag INT CHECK (max_replication_lag &amp;gt;= 0 AND max_replication_lag &amp;lt;= 126144000) NOT NULL DEFAULT 0,
    use_ssl INT CHECK (use_ssl IN(0,1)) NOT NULL DEFAULT 0,
    max_latency_ms INT UNSIGNED CHECK (max_latency_ms&amp;gt;=0) NOT NULL DEFAULT 0,
    comment VARCHAR NOT NULL DEFAULT &amp;apos;&amp;apos;,
    PRIMARY KEY (hostgroup_id, hostname, port) )
1 row in set (0.00 sec)
MySQL [main] 17:34:05 &amp;gt;
hostgroup_id：ProxySQL通过hostgroup的形式组织后端db实例,一个hostgroup代表同属于一个角色。
表的主键是(hostgroup_id, hostname, port),以hostname:port在多个hostgroup中存在。
一个hostgroup可以有多个实例，即是多个从库，可能通过weight分配权重。
hostgroup_id 0是一个特殊的hostgroup，路由查询的时候，没有匹配到规则则默认选择hostgroup 0。

status：
ONLINE：当前后端实例状态正常。
SHUNNED：临时被剔除，可能因为后端too many connection error，或者超过了max_replication_lag。
OFFLINE_SOFT：软离线状态，不再接受新的连接，但已建立的连接会等待活跃事务完成。
OFFLINE_HARD：硬离线状态，不再接受新的连接，已建立的连接或被强制中断，当后端实例宕机或网络不可达，会出现。
max_connections：允许连接到该后端实例的最大连接数，不要大于MySQL的max_connections。
如果后端实例hostname:port在多个hostgroup里，以较大者为准，而不是各自独立允许的最大连接数。
max_replication_lag：允许的最大延迟，主库不受影响，默认为0，如果&amp;gt;0，monitor模块监控主从延迟大于阈值时，会临时把它的状态变更为SHUNNED。
max_latency_ms：mysql_ping响应时间，大于这个阈值会把它从连接池剔除，即使是ONLINE。
comment：备注，不建设为空。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他的字段，可通过字面意思理解。&lt;/p&gt;
&lt;h4 id=&quot;mysql-users表&quot;&gt;&lt;a href=&quot;#mysql-users表&quot; class=&quot;headerlink&quot; title=&quot;mysql_users表&quot;&gt;&lt;/a&gt;mysql_users表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [main] 09:13:02 &amp;gt; show create table mysql_users\G
*************************** 1. row ***************************
       table: mysql_users
Create Table: CREATE TABLE mysql_users (
    username VARCHAR NOT NULL,
    password VARCHAR,
    active INT CHECK (active IN (0,1)) NOT NULL DEFAULT 1,
    use_ssl INT CHECK (use_ssl IN (0,1)) NOT NULL DEFAULT 0,
    default_hostgroup INT NOT NULL DEFAULT 0,
    default_schema VARCHAR,
    schema_locked INT CHECK (schema_locked IN (0,1)) NOT NULL DEFAULT 0,
    transaction_persistent INT CHECK (transaction_persistent IN (0,1)) NOT NULL DEFAULT 1,
    fast_forward INT CHECK (fast_forward IN (0,1)) NOT NULL DEFAULT 0,
    backend INT CHECK (backend IN (0,1)) NOT NULL DEFAULT 1,
    frontend INT CHECK (frontend IN (0,1)) NOT NULL DEFAULT 1,
    max_connections INT CHECK (max_connections &amp;gt;=0) NOT NULL DEFAULT 10000,
    PRIMARY KEY (username, backend),
    UNIQUE (username, frontend))
1 row in set (0.00 sec)
MySQL [main] 09:13:08 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;username,password：连接到后端MySQL或ProxySQL实例的凭证,参考密码管理。&lt;br&gt;密码可插入明文，也可通过PASSWORD()插入密文，proxysql以*开头判断插入是否是密文。&lt;br&gt;但是runtime_mysql_users里统一是密文，所以明文插入，再SAVE MYSQL USERS TO MEM，此时看到的也是HASH密文。&lt;/p&gt;
&lt;p&gt;active：是否生效该用户，active=0的用户将在数据库中被跟踪，但不会加载到内存中的数据结构中。&lt;br&gt;default_hostgroup：这个用户的请求没有匹配到规则时，默认发到hostgroup，默认0。&lt;br&gt;default_schema：这个用户连接时没有指定schema时，默认使用的schema。&lt;br&gt;默认为NULL，实际上受变量mysql-default_schema的影响，默认为information_schema。&lt;br&gt;transaction_persistent： 如果设置为1，连接上ProxySQL的会话后，如果在一个hostgroup上开启了事务，那么后续的sql都继续维持在这个hostgroup上，不论是否会匹配上其它路由规则，直到事务结束。&lt;br&gt;frontend：如果设置为1，则用户名、密码对ProxySQL进行身份验证。&lt;br&gt;backend：如果设置为1，则用户名、密码根据任何主机组向mysqld服务器进行身份验证。&lt;br&gt;注意，目前所有用户都需要将“前端”和“后端“都设置为1，未来版本的ProxySQL将分离前端和后端之间的crendentials。以这种方式，前端将永远不会知道直接连接到后端的凭据，强制所有通过ProxySQL的连接并增加系统的安全性。&lt;/p&gt;
&lt;p&gt;mysql_replication_hostgroups表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [main] 10:18:15 &amp;gt; show create table mysql_replication_hostgroups\G
*************************** 1. row ***************************
       table: mysql_replication_hostgroups
Create Table: CREATE TABLE mysql_replication_hostgroups (
    writer_hostgroup INT CHECK (writer_hostgroup&amp;gt;=0) NOT NULL PRIMARY KEY,
    reader_hostgroup INT NOT NULL CHECK (reader_hostgroup&amp;lt;&amp;gt;writer_hostgroup AND reader_hostgroup&amp;gt;0),
    comment VARCHAR,
    UNIQUE (reader_hostgroup))
1 row in set (0.00 sec)
MySQL [main] 10:18:22 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义hostgroup的主从关系。ProxySQL monitor模块会监控hostgroup后端所有servers的read_only变量，如果发现从库的read_only变为0、主库变为1，则认为角色互换了，自动改写mysql_servers表里面hostgroup关系，达到failover效果。&lt;/p&gt;
&lt;h4 id=&quot;mysql-query-rules查询规则表&quot;&gt;&lt;a href=&quot;#mysql-query-rules查询规则表&quot; class=&quot;headerlink&quot; title=&quot;mysql_query_rules查询规则表&quot;&gt;&lt;/a&gt;mysql_query_rules查询规则表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [main] 10:25:22 &amp;gt; show create table mysql_query_rules\G           
*************************** 1. row ***************************
       table: mysql_query_rules
Create Table: CREATE TABLE mysql_query_rules (
    rule_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
    active INT CHECK (active IN (0,1)) NOT NULL DEFAULT 0,
    username VARCHAR,
    schemaname VARCHAR,
    flagIN INT NOT NULL DEFAULT 0,
    client_addr VARCHAR,
    proxy_addr VARCHAR,
    proxy_port INT,
    digest VARCHAR,
    match_digest VARCHAR,
    match_pattern VARCHAR,
    negate_match_pattern INT CHECK (negate_match_pattern IN (0,1)) NOT NULL DEFAULT 0,
    re_modifiers VARCHAR DEFAULT &amp;apos;CASELESS&amp;apos;,
    flagOUT INT,
    replace_pattern VARCHAR,
    destination_hostgroup INT DEFAULT NULL,
    cache_ttl INT CHECK(cache_ttl &amp;gt; 0),
    reconnect INT CHECK (reconnect IN (0,1)) DEFAULT NULL,
    timeout INT UNSIGNED,
    retries INT CHECK (retries&amp;gt;=0 AND retries &amp;lt;=1000),
    delay INT UNSIGNED,
    next_query_flagIN INT UNSIGNED,
    mirror_flagOUT INT UNSIGNED,
    mirror_hostgroup INT UNSIGNED,
    error_msg VARCHAR,
    OK_msg VARCHAR,
    sticky_conn INT CHECK (sticky_conn IN (0,1)),
    multiplex INT CHECK (multiplex IN (0,1,2)),
    log INT CHECK (log IN (0,1)),
    apply INT CHECK(apply IN (0,1)) NOT NULL DEFAULT 0,
    comment VARCHAR)
1 row in set (0.00 sec)
MySQL [main] 10:25:34 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;rule_id：表主键，自增，规则处理是以rule_id为顺序进行。&lt;/p&gt;
&lt;p&gt;active：只有active=1时的规则才会参与匹配。&lt;br&gt;username：过滤匹配用户名的条件，如果是非空值，则仅当连接使用正确的用户名时，查询才匹配。&lt;br&gt;schemaname：匹配schemaname的过滤条件，如果是非空值，则仅当连接schemaname用作默认模式时，查询才匹配。&lt;br&gt;flagIN,flagOUT,apply：用来定义路由链chains of rules&lt;br&gt;首先会检查flagIN=0的规则，以rule_id的顺序；如果没有匹配上，则走这个用户的default_hostgroup。&lt;br&gt;当匹配一条规则后，会检查flagOUT。&lt;br&gt;如果不为NULL，并且flagIN!=flagOUT，则进入以flagIN为上一个flagOUT值的新规则链。&lt;br&gt;如果不为NULL，并且flagIN=flagOUT，则应用这条规则。&lt;br&gt;如果为NULL，或者apply=1，则结束，应用这条规则。&lt;br&gt;如果最终没有匹配到，则找到这个用户的default_hostgroup。&lt;br&gt;client_addr：匹配客户端来源IP。&lt;br&gt;proxy_addr,proxy_port：匹配本地proxysql的ip、端口。&lt;br&gt;digest：精确匹配的查询。&lt;br&gt;match_digest：正则匹配查询。query,digest是指对查询去掉具体值后进行”模糊化“后的查询，类似pt-query-digest的效果。&lt;br&gt;match_pattern：正则匹配查询。&lt;br&gt;以上都是匹配查询的规则，1.4版本可以通过变量mysql-query_processor_regex设置，支持RE2和PCRE，1.4版本开始默认为PCRE。&lt;br&gt;negate_match_pattern：反向匹配，相当于对match_digest/match_pattern的匹配取反。&lt;br&gt;re_modifiers：修改正则匹配的参数，比如默认的：忽略大小写CASELESS、禁用GLOBAL。&lt;br&gt;下面是匹配后的行为：&lt;br&gt;replace_pattern：查询重写，默认为空。&lt;br&gt;destination_hostgroup：路由查询到这个hostgroup，当然如果用户显式start transaction且transaction_persistent=1,那么即使匹配到了，也依然按照事务里第一条sql的路由规则去走的。&lt;br&gt;cache_ttl：查询结果缓存的毫秒数。&lt;br&gt;timeout：这一类查询执行的的最大时间(毫秒),超时则自动kill。&lt;br&gt;这是对后端DB的保护机制，相当于阿里云RDS的loose_max_statement_time变量的功能，但不同的是，阿里云这个变量的时间时不包括DML操作出现InnoDB行锁等待的时间，而ProxySQL的这个timeout是计算从发送sql到等待响应的时间。默认mysql-default_query_timeout是10h。&lt;br&gt;retries：语句在执行失败时，重试次数。默认由mysql-query_retries_on_failure变量指定，为1。建议不要重试，有风险。&lt;br&gt;delay：查询延迟执行，这是ProxySQL提供的限流机制，会让其它的查询优先执行。&lt;br&gt;默认值mysql-default_query_delay为0。&lt;br&gt;mirror_flagOUT,mirror_hostgroup：与镜像相关的设置。&lt;br&gt;error_msg：默认为NULL，如果指定了则这个查询直接被block掉，将error_msg返回给客户端。&lt;br&gt;multiplex：连接是否利用，请参考文章。&lt;br&gt;log：是否记录查询日志，可以看到log是否记录的对象是根据规则。&lt;br&gt;要开启日志记录，需要设置变量mysql-eventslog_filename来指定文件名，然后这个log标记为1。但是目前proxysql记录的日志是二进制格式，需要特定的工具才能读取：eventslog_reader_sample。这个工具在源码目录 tools下面。&lt;/p&gt;
&lt;h4 id=&quot;scheduler调度表&quot;&gt;&lt;a href=&quot;#scheduler调度表&quot; class=&quot;headerlink&quot; title=&quot;scheduler调度表&quot;&gt;&lt;/a&gt;scheduler调度表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [main] 10:27:52 &amp;gt; show create table scheduler\G
*************************** 1. row ***************************
       table: scheduler
Create Table: CREATE TABLE scheduler (
    id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
    active INT CHECK (active IN (0,1)) NOT NULL DEFAULT 1,
    interval_ms INTEGER CHECK (interval_ms&amp;gt;=100 AND interval_ms&amp;lt;=100000000) NOT NULL,
    filename VARCHAR NOT NULL,
    arg1 VARCHAR,
    arg2 VARCHAR,
    arg3 VARCHAR,
    arg4 VARCHAR,
    arg5 VARCHAR,
    comment VARCHAR NOT NULL DEFAULT &amp;apos;&amp;apos;)
1 row in set (0.00 sec)
MySQL [main] 11:09:59 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;id：调度程序作业的唯一标识符。&lt;/p&gt;
&lt;p&gt;active：如果设置为1，则作业处于活动状态。&lt;br&gt;interval_ms：工作的开始频率(以毫秒为单位)，最小interval_ms为100毫秒。&lt;br&gt;filename：可执行文件的完整路径。&lt;br&gt;arg1-arg5：传递作业的参数。最多5个。&lt;br&gt;comment：注释。&lt;br&gt;参考文档&lt;/p&gt;
&lt;h3 id=&quot;disk库&quot;&gt;&lt;a href=&quot;#disk库&quot; class=&quot;headerlink&quot; title=&quot;disk库&quot;&gt;&lt;/a&gt;disk库&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;MySQL [main] 15:12:14 &amp;gt; show tables from disk;
+------------------------------------+
| tables                             |
+------------------------------------+
| global_variables                   |
| mysql_collations                   |
| mysql_group_replication_hostgroups |
| mysql_query_rules                  |
| mysql_replication_hostgroups       |
| mysql_servers                      |
| mysql_users                        |
| proxysql_servers                   |
| scheduler                          |
+------------------------------------+
9 rows in set (0.00 sec)
MySQL [main] 15:12:26 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体的表介绍和main库一致。&lt;/p&gt;
&lt;h3 id=&quot;stats库&quot;&gt;&lt;a href=&quot;#stats库&quot; class=&quot;headerlink&quot; title=&quot;stats库&quot;&gt;&lt;/a&gt;stats库&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;MySQL [main] 15:12:26 &amp;gt; show tables from stats;
+-----------------------------------+
| tables                            |
+-----------------------------------+
| global_variables                  |
| stats_memory_metrics              |
| stats_mysql_commands_counters     |
| stats_mysql_connection_pool       |
| stats_mysql_connection_pool_reset |
| stats_mysql_global                |
| stats_mysql_processlist           |
| stats_mysql_query_digest          |
| stats_mysql_query_digest_reset    |
| stats_mysql_query_rules           |
| stats_mysql_users                 |
| stats_proxysql_servers_metrics    |
| stats_proxysql_servers_status     |
+-----------------------------------+
13 rows in set (0.00 sec)
MySQL [main] 15:13:53 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;stats-mysql-commands-counters表&quot;&gt;&lt;a href=&quot;#stats-mysql-commands-counters表&quot; class=&quot;headerlink&quot; title=&quot;stats_mysql_commands_counters表&quot;&gt;&lt;/a&gt;stats_mysql_commands_counters表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:15:36 &amp;gt; show create table stats.stats_mysql_commands_counters\G
*************************** 1. row ***************************
       table: stats_mysql_commands_counters
Create Table: CREATE TABLE stats_mysql_commands_counters (
    Command VARCHAR NOT NULL PRIMARY KEY,
    Total_Time_us INT NOT NULL,
    Total_cnt INT NOT NULL,
    cnt_100us INT NOT NULL,
    cnt_500us INT NOT NULL,
    cnt_1ms INT NOT NULL,
    cnt_5ms INT NOT NULL,
    cnt_10ms INT NOT NULL,
    cnt_50ms INT NOT NULL,
    cnt_100ms INT NOT NULL,
    cnt_500ms INT NOT NULL,
    cnt_1s INT NOT NULL,
    cnt_5s INT NOT NULL,
    cnt_10s INT NOT NULL,
    cnt_INFs)
1 row in set (0.00 sec)
MySQL [stats] 15:15:58 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;command：已执行的SQL命令的类型，如FLUSH、INSERT、KILL、SELECT FOR UPDATE等。&lt;br&gt;Total_Time_us：执行该类型命令的总时间(以毫秒为单位)。&lt;br&gt;Total_cnt：执行该类型的命令的总数。&lt;br&gt;cnt_100us-cnt_INFs：在指定的时间限制内执行的给定类型的命令总数和前一个命令的总数。&lt;/p&gt;
&lt;h4 id=&quot;stats-mysql-connection-pool表&quot;&gt;&lt;a href=&quot;#stats-mysql-connection-pool表&quot; class=&quot;headerlink&quot; title=&quot;stats_mysql_connection_pool表&quot;&gt;&lt;/a&gt;stats_mysql_connection_pool表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:15:58 &amp;gt; show create table stats.stats_mysql_connection_pool \G 
*************************** 1. row ***************************
       table: stats_mysql_connection_pool
Create Table: CREATE TABLE stats_mysql_connection_pool (
    hostgroup INT,
    srv_host VARCHAR,
    srv_port INT,
    status VARCHAR,
    ConnUsed INT,
    ConnFree INT,
    ConnOK INT,
    ConnERR INT,
    Queries INT,
    Bytes_data_sent INT,
    Bytes_data_recv INT,
    Latency_us INT)
1 row in set (0.00 sec)
MySQL [stats] 15:20:08 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;hostgroup：后端服务器所属的主机组，单个后端服务器可以属于多个主机组。&lt;/p&gt;
&lt;p&gt;srv_host,srv_port：mysqld后端服务器正在侦听连接的TCP端点的IP和Port。&lt;br&gt;status：后端服务器的状态。可以有ONLINE，SHUNNED，OFFLINE_SOFT，OFFLINE_HARD。&lt;br&gt;ConnUsed：ProxySQL当前使用多少个连接来向后端服务器发送查询。&lt;br&gt;ConnFree：目前有多少个连接是空闲。&lt;br&gt;ConnOK：成功建立了多少个连接。&lt;br&gt;ConnERR：没有成功建立多少个连接。&lt;br&gt;Queries：路由到此特定后端服务器的查询数。&lt;br&gt;Bytes_data_sent：发送到后端的数据量。&lt;br&gt;Bytes_data_recv：从后端接收的数据量。&lt;br&gt;Latency_ms：从Monitor报告的当前ping以毫秒为单位的延迟时间。&lt;/p&gt;
&lt;h4 id=&quot;stats-mysql-global表&quot;&gt;&lt;a href=&quot;#stats-mysql-global表&quot; class=&quot;headerlink&quot; title=&quot;stats_mysql_global表&quot;&gt;&lt;/a&gt;stats_mysql_global表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:20:08 &amp;gt; show create table stats.stats_mysql_global\G          
*************************** 1. row ***************************
       table: stats_mysql_global
Create Table: CREATE TABLE stats_mysql_global (
    Variable_Name VARCHAR NOT NULL PRIMARY KEY,
    Variable_Value VARCHAR NOT NULL)
1 row in set (0.00 sec)
MySQL [stats] 15:22:35 &amp;gt;
Variable_Name：代表与MySQL相关的代理级别的全局统计
如Client_Connections_aborted：由于无效凭据或max_connections而导致的前端连接数已达到；
如Client_Connections_connected：当前连接的前端连接数。
如Client_Connections_created：到目前为止创建的前端连接数。等等。

Variable_Value：统计所对应的值。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;stats-mysql-processlist表&quot;&gt;&lt;a href=&quot;#stats-mysql-processlist表&quot; class=&quot;headerlink&quot; title=&quot;stats_mysql_processlist表&quot;&gt;&lt;/a&gt;stats_mysql_processlist表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:24:11 &amp;gt; show create table stats.stats_mysql_processlist\G
*************************** 1. row ***************************
       table: stats_mysql_processlist
Create Table: CREATE TABLE stats_mysql_processlist (
    ThreadID INT NOT NULL,
    SessionID INTEGER PRIMARY KEY,
    user VARCHAR,
    db VARCHAR,
    cli_host VARCHAR,
    cli_port INT,
    hostgroup INT,
    l_srv_host VARCHAR,
    l_srv_port INT,
    srv_host VARCHAR,
    srv_port INT,
    command VARCHAR,
    time_ms INT NOT NULL,
    info VARCHAR)
1 row in set (0.00 sec)
MySQL [stats] 15:26:43 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ThreadID：ProxySQL线程的内部ID。&lt;/p&gt;
&lt;p&gt;SessionID：ProxySQL会话ID，通过这个ID可以进行kill操作。&lt;br&gt;user：与MySQL客户端连接到ProxySQL的用户。&lt;br&gt;db：当前选择的数据库。&lt;br&gt;cli_host,cli_port：连接ProxySQL的IP和TCP端口。&lt;br&gt;hostgroup：当前主机组。如果正在处理查询，则是查询已被路由或将要路由的主机组，或默认主机组。可以通过这个查看该SQL到底是到哪个HG里。&lt;br&gt;l_srv_host,l_srv_port：ProxySQL的IP和TCP端口。&lt;br&gt;srv_host,srv_port：后端MySQL服务器的IP和端口。&lt;br&gt;command：正在执行的MySQL查询的类型。&lt;br&gt;time_ms：命令执行的时间(以毫秒为单位)。&lt;br&gt;info：正在执行的SQL。&lt;/p&gt;
&lt;h4 id=&quot;stats-mysql-query-digest表&quot;&gt;&lt;a href=&quot;#stats-mysql-query-digest表&quot; class=&quot;headerlink&quot; title=&quot;stats_mysql_query_digest表&quot;&gt;&lt;/a&gt;stats_mysql_query_digest表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:26:43 &amp;gt; show create table stats.stats_mysql_query_digest\G
*************************** 1. row ***************************
       table: stats_mysql_query_digest
Create Table: CREATE TABLE stats_mysql_query_digest (
    hostgroup INT,
    schemaname VARCHAR NOT NULL,
    username VARCHAR NOT NULL,
    digest VARCHAR NOT NULL,
    digest_text VARCHAR NOT NULL,
    count_star INTEGER NOT NULL,
    first_seen INTEGER NOT NULL,
    last_seen INTEGER NOT NULL,
    sum_time INTEGER NOT NULL,
    min_time INTEGER NOT NULL,
    max_time INTEGER NOT NULL,
    PRIMARY KEY(hostgroup, schemaname, username, digest))
1 row in set (0.00 sec)
MySQL [stats] 15:29:27 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;hostgroup：发送查询的主机组。值-1表示查询查询缓存。&lt;/p&gt;
&lt;p&gt;schemaname：查询的数据库。&lt;br&gt;user：连接ProxySQL的用户名。&lt;br&gt;digest：一个十六进制散列，表示其参数剥离的SQL。&lt;br&gt;digest_text：参数剥离的实际SQL文本&lt;br&gt;count_star：执行查询的总次数（参数的值不同）。&lt;br&gt;first_seen：unix时间戳，是通过代理路由查询的第一时刻。&lt;br&gt;last_seen：unix时间戳，当查询通过代理路由时的最后一刻（到目前为止）。&lt;br&gt;sum_time：执行此类查询的总时间（以微秒为单位）。&lt;br&gt;这对于确定应用程序工作负载中花费的最多时间在哪里是非常有用的，并为改进的地方提供了一个良好的起点。&lt;br&gt;min_time,max_time - 执行此类查询时期望的持续时间范围。&lt;br&gt;min_time是到目前为止所看到的最小执行时间，而max_time表示最大执行时间，以微秒为单位。&lt;/p&gt;
&lt;h4 id=&quot;stats-mysql-query-rules表&quot;&gt;&lt;a href=&quot;#stats-mysql-query-rules表&quot; class=&quot;headerlink&quot; title=&quot;stats_mysql_query_rules表&quot;&gt;&lt;/a&gt;stats_mysql_query_rules表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:29:27 &amp;gt; show create table stats.stats_mysql_query_rules\G 
*************************** 1. row ***************************
       table: stats_mysql_query_rules
Create Table: CREATE TABLE stats_mysql_query_rules (
    rule_id INTEGER PRIMARY KEY,
    hits INT NOT NULL)
1 row in set (0.00 sec)
MySQL [stats] 15:31:57 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;rule_id：路由规则的ID与main.mysql_query_rules的id对应。&lt;/p&gt;
&lt;p&gt;hits：此路由规则的匹配总数。 如果当前传入的查询符合规则，则会记录一次命中。&lt;br&gt;monitor库&lt;/p&gt;
&lt;p&gt;对后端MySQL的健康检查，由变量mysql-monitor_enabled来确定是否开启Monitor模块。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:35:32 &amp;gt; show tables from monitor;                               
+------------------------------------+
| tables                             |
+------------------------------------+
| mysql_server_connect               |
| mysql_server_connect_log           |
| mysql_server_group_replication_log |
| mysql_server_ping                  |
| mysql_server_ping_log              |
| mysql_server_read_only_log         |
| mysql_server_replication_lag_log   |
+------------------------------------+
7 rows in set (0.00 sec)
MySQL [stats] 15:35:52 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;mysql-server-connect-mysql-server-connect-log表&quot;&gt;&lt;a href=&quot;#mysql-server-connect-mysql-server-connect-log表&quot; class=&quot;headerlink&quot; title=&quot;mysql_server_connect/mysql_server_connect_log表&quot;&gt;&lt;/a&gt;mysql_server_connect/mysql_server_connect_log表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:37:39 &amp;gt; show create table monitor.mysql_server_connect\G  
*************************** 1. row ***************************
       table: mysql_server_connect
Create Table: CREATE TABLE mysql_server_connect (
    hostname VARCHAR NOT NULL,
    port INT NOT NULL DEFAULT 3306,
    time_since INT NOT NULL DEFAULT 0,
    time_until INT NOT NULL DEFAULT 0,
    connect_success_count INT NOT NULL DEFAULT 0,
    connect_success_first INT NOT NULL DEFAULT 0,
    connect_success_last INT NOT NULL DEFAULT 0,
    connect_success_time_min INT NOT NULL DEFAULT 0,
    connect_success_time_max INT NOT NULL DEFAULT 0,
    connect_success_time_total INT NOT NULL DEFAULT 0,
    connect_failure_count INT NOT NULL DEFAULT 0,
    connect_failure_first INT NOT NULL DEFAULT 0,
    connect_failure_last INT NOT NULL DEFAULT 0,
    PRIMARY KEY (hostname, port))
1 row in set (0.00 sec)
MySQL [stats] 15:37:46 &amp;gt; show create table monitor.mysql_server_connect_log\G
*************************** 1. row ***************************
       table: mysql_server_connect_log
Create Table: CREATE TABLE mysql_server_connect_log (
    hostname VARCHAR NOT NULL,
    port INT NOT NULL DEFAULT 3306,
    time_start_us INT NOT NULL DEFAULT 0,
    connect_success_time_us INT DEFAULT 0,
    connect_error VARCHAR,
    PRIMARY KEY (hostname, port, time_start_us))
1 row in set (0.00 sec)
MySQL [stats] 15:37:51 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;连接到所有MySQL服务器以检查它们是否可用，该表用来存放检测连接的日志。由变量mysql-monitor_connect_interval来控制其检测的时间间隔，由参数mysql-monitor_connect_timeout控制连接是否超时（默认200毫秒）。&lt;/p&gt;
&lt;h4 id=&quot;mysql-server-ping-mysql-server-ping-log表&quot;&gt;&lt;a href=&quot;#mysql-server-ping-mysql-server-ping-log表&quot; class=&quot;headerlink&quot; title=&quot;mysql_server_ping/mysql_server_ping_log表&quot;&gt;&lt;/a&gt;mysql_server_ping/mysql_server_ping_log表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:39:23 &amp;gt; show create table monitor.mysql_server_ping\G       
*************************** 1. row ***************************
       table: mysql_server_ping
Create Table: CREATE TABLE mysql_server_ping (
    hostname VARCHAR NOT NULL,
    port INT NOT NULL DEFAULT 3306,
    time_since INT NOT NULL DEFAULT 0,
    time_until INT NOT NULL DEFAULT 0,
    ping_success_count INT NOT NULL DEFAULT 0,
    ping_success_first INT NOT NULL DEFAULT 0, ping_success_last INT NOT NULL DEFAULT 0,
    ping_success_time_min INT NOT NULL DEFAULT 0,
    ping_success_time_max INT NOT NULL DEFAULT 0,
    ping_success_time_total INT NOT NULL DEFAULT 0,
    ping_failure_count INT NOT NULL DEFAULT 0,
    ping_failure_first INT NOT NULL DEFAULT 0,
    ping_failure_last INT NOT NULL DEFAULT 0,
    PRIMARY KEY (hostname, port))
1 row in set (0.00 sec)
MySQL [stats] 15:40:12 &amp;gt; show create table monitor.mysql_server_ping_log\G
*************************** 1. row ***************************
       table: mysql_server_ping_log
Create Table: CREATE TABLE mysql_server_ping_log (
     hostname VARCHAR NOT NULL,
    port INT NOT NULL DEFAULT 3306,
    time_start_us INT NOT NULL DEFAULT 0,
    ping_success_time_us INT DEFAULT 0,
    ping_error VARCHAR,
    PRIMARY KEY (hostname, port, time_start_us))
1 row in set (0.00 sec)
MySQL [stats] 15:40:15 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用mysql_ping API ping后端MySQL服务器检查它们是否可用，该表用来存放ping的日志。由变量mysql-monitor_ping_interval控制ping的时间间隔，默认值：10000（毫秒，相当于10秒）。&lt;/p&gt;
&lt;h4 id=&quot;mysql-server-replication-lag-log表&quot;&gt;&lt;a href=&quot;#mysql-server-replication-lag-log表&quot; class=&quot;headerlink&quot; title=&quot;mysql_server_replication_lag_log表&quot;&gt;&lt;/a&gt;mysql_server_replication_lag_log表&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;MySQL [stats] 15:40:53 &amp;gt; show create table monitor.mysql_server_replication_lag_log\G
*************************** 1. row ***************************
       table: mysql_server_replication_lag_log
Create Table: CREATE TABLE mysql_server_replication_lag_log (
     hostname VARCHAR NOT NULL,
    port INT NOT NULL DEFAULT 3306,
    time_start_us INT NOT NULL DEFAULT 0,
    success_time_us INT DEFAULT 0,
    repl_lag INT DEFAULT 0,
    error VARCHAR,
    PRIMARY KEY (hostname, port, time_start_us))
1 row in set (0.00 sec)
MySQL [stats] 15:41:12 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;后端MySQL服务主从延迟的检测。由参数mysql-monitor_replication_lag_interval控制检测间隔时间， 如果复制滞后太大，可以暂时关闭从。由mysql_servers.max_replication_lag列控制。默认值：10000（毫秒，相当于10秒）。&lt;/p&gt;
&lt;h2 id=&quot;内置参数&quot;&gt;&lt;a href=&quot;#内置参数&quot; class=&quot;headerlink&quot; title=&quot;内置参数&quot;&gt;&lt;/a&gt;内置参数&lt;/h2&gt;&lt;p&gt;global_variables 1.4版本中有95个参数，参数较多，解释请参考文档。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [main] 11:16:22 &amp;gt; show variables;
+-----------------------------------------------------+--------------------+
| Variable_name                                       | Value              |
+-----------------------------------------------------+--------------------+
| admin-admin_credentials                             | admin:admin        |
| admin-cluster_check_interval_ms                     | 1000               |
| admin-cluster_password                              |                    |
| admin-cluster_username                              |                    |
| admin-hash_passwords                                | true               |
| admin-mysql_ifaces                                  | 0.0.0.0:6032       |
| admin-read_only                                     | false              |
| admin-refresh_interval                              | 2000               |
| admin-stats_credentials                             | stats:stats        |
| admin-telnet_admin_ifaces                           | (null)             |
| admin-telnet_stats_ifaces                           | (null)             |
| admin-version                                       | 1.4.1-45-gab4e6ee  |
| mysql-client_found_rows                             | true               |
| mysql-commands_stats                                | true               |
| mysql-connect_retries_delay                         | 1                  |
| mysql-connect_retries_on_failure                    | 10                 |
| mysql-connect_timeout_server                        | 3000               |
| mysql-connect_timeout_server_max                    | 10000              |
| mysql-connection_delay_multiplex_ms                 | 0                  |
| mysql-connection_max_age_ms                         | 0                  |
| mysql-default_charset                               | utf8               |
| mysql-default_max_latency_ms                        | 1000               |
| mysql-default_query_delay                           | 0                  |
| mysql-default_query_timeout                         | 36000000           |
| mysql-default_reconnect                             | true               |
| mysql-default_schema                                | information_schema |
| mysql-default_sql_mode                              |                    |
| mysql-default_time_zone                             | SYSTEM             |
| mysql-enforce_autocommit_on_reads                   | false              |
| mysql-eventslog_filename                            |                    |
| mysql-eventslog_filesize                            | 104857600          |
| mysql-forward_autocommit                            | false              |
| mysql-free_connections_pct                          | 10                 |
| mysql-have_compress                                 | true               |
| mysql-hostgroup_manager_verbose                     | 1                  |
| mysql-init_connect                                  | (null)             |
| mysql-interfaces                                    | 0.0.0.0:6033       |
| mysql-long_query_time                               | 1000               |
| mysql-max_allowed_packet                            | 4194304            |
| mysql-max_connections                               | 2048               |
| mysql-max_stmts_cache                               | 10000              |
| mysql-max_stmts_per_connection                      | 20                 |
| mysql-max_transaction_time                          | 14400000           |
| mysql-mirror_max_concurrency                        | 16                 |
| mysql-mirror_max_queue_length                       | 32000              |
| mysql-monitor_connect_interval                      | 60000              |
| mysql-monitor_connect_timeout                       | 600                |
| mysql-monitor_enabled                               | true               |
| mysql-monitor_groupreplication_healthcheck_interval | 5000               |
| mysql-monitor_groupreplication_healthcheck_timeout  | 800                |
| mysql-monitor_history                               | 600000             |
| mysql-monitor_password                              | monitor            |
| mysql-monitor_ping_interval                         | 10000              |
| mysql-monitor_ping_max_failures                     | 3                  |
| mysql-monitor_ping_timeout                          | 1000               |
| mysql-monitor_query_interval                        | 60000              |
| mysql-monitor_query_timeout                         | 100                |
| mysql-monitor_read_only_interval                    | 1500               |
| mysql-monitor_read_only_timeout                     | 500                |
| mysql-monitor_replication_lag_interval              | 10000              |
| mysql-monitor_replication_lag_timeout               | 1000               |
| mysql-monitor_slave_lag_when_null                   | 60                 |
| mysql-monitor_username                              | monitor            |
| mysql-monitor_wait_timeout                          | true               |
| mysql-monitor_writer_is_also_reader                 | true               |
| mysql-multiplexing                                  | true               |
| mysql-ping_interval_server_msec                     | 120000             |
| mysql-ping_timeout_server                           | 500                |
| mysql-poll_timeout                                  | 2000               |
| mysql-poll_timeout_on_failure                       | 100                |
| mysql-query_cache_size_MB                           | 256                |
| mysql-query_digests                                 | true               |
| mysql-query_digests_lowercase                       | false              |
| mysql-query_digests_max_digest_length               | 2048               |
| mysql-query_digests_max_query_length                | 65000              |
| mysql-query_processor_iterations                    | 0                  |
| mysql-query_processor_regex                         | 1                  |
| mysql-query_retries_on_failure                      | 1                  |
| mysql-server_capabilities                           | 45578              |
| mysql-server_version                                | 5.5.30             |
| mysql-servers_stats                                 | true               |
| mysql-session_idle_ms                               | 1000               |
| mysql-session_idle_show_processlist                 | true               |
| mysql-sessions_sort                                 | true               |
| mysql-shun_on_failures                              | 5                  |
| mysql-shun_recovery_time_sec                        | 10                 |
| mysql-ssl_p2s_ca                                    | (null)             |
| mysql-ssl_p2s_cert                                  | (null)             |
| mysql-ssl_p2s_cipher                                | (null)             |
| mysql-ssl_p2s_key                                   | (null)             |
| mysql-stacksize                                     | 1048576            |
| mysql-threads                                       | 4                  |
| mysql-threshold_query_length                        | 524288             |
| mysql-threshold_resultset_size                      | 4194304            |
| mysql-wait_timeout                                  | 28800000           |
+-----------------------------------------------------+--------------------+
95 rows in set (0.00 sec)
MySQL [main] 11:16:33 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;ProxySQL多层配置设计&quot;&gt;&lt;a href=&quot;#ProxySQL多层配置设计&quot; class=&quot;headerlink&quot; title=&quot;ProxySQL多层配置设计&quot;&gt;&lt;/a&gt;ProxySQL多层配置设计&lt;/h2&gt;&lt;h3 id=&quot;ProxySQL设计模型介绍&quot;&gt;&lt;a href=&quot;#ProxySQL设计模型介绍&quot; class=&quot;headerlink&quot; title=&quot;ProxySQL设计模型介绍&quot;&gt;&lt;/a&gt;ProxySQL设计模型介绍&lt;/h3&gt;&lt;p&gt;ProxySQL使用多层配置系统，适合满足以下需求：&lt;/p&gt;
&lt;p&gt;允许自动更新配置，与MySQL兼容管理界面；&lt;br&gt;允许在线修改配置，不用重启ProxySQL；&lt;br&gt;允许回滚配置；&lt;br&gt;多层配置系统的实现，如下图：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------------------------+
|         RUNTIME         |
+-------------------------+
       /|\          |
        |           |
    [1] |       [2] |
        |          \|/
+-------------------------+
|         MEMORY          |
+-------------------------+ _
       /|\          |      |\
        |           |        \
    [3] |       [4] |         \ [5]
        |          \|/         \
+-------------------------+  +-------------------------+
|          DISK           |  |       CONFIG FILE       |
+-------------------------+  +-------------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RUNTIME代表ProxySQL当前生效的配置，包括global_variables、mysql_servers、mysql_users、mysql_query_rules。无法直接修改这里的配置，必须要从下一层load过来。&lt;/p&gt;
&lt;p&gt;MEMORY(main)代表平时在mysql命令行修改的main里的配置，可以认为是SQLite数据库在内存的镜像。可修改以下：&lt;/p&gt;
&lt;p&gt;mysql_server        后端服务器列表&lt;br&gt;mysql_users         连接到ProxySQL的用户列表及其凭据&lt;br&gt;mysql_query_rules   将流量路由到不同的后端服务器的规则列表&lt;br&gt;global_variables    全局变量列表&lt;br&gt;mysql_collat        MySQL排序规则列表&lt;br&gt;DISK和CONFIG FILE表示磁盘上SQLite数据库，默认位置在$datadir/proxysql.db，在重新启动过程中，内存中未被保存的配置将丢失。/etc/proxysql.cnf文件只在第一次初始化的时候用到。如要修改端口，还是需要在管理命令行里修改，再save到磁盘。&lt;/p&gt;
&lt;p&gt;ProxySQL多层配置修改示例&lt;/p&gt;
&lt;p&gt;mysql users&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;LOAD MYSQL USERS TO RUNTIME / LOAD MYSQL USERS FROM MEMORY
SAVE MYSQL USERS TO MEMORY / SAVE MYSQL USERS FROM RUNTIME
LOAD MYSQL USERS TO MEMORY / LOAD MYSQL USERS FROM DISK
SAVE MYSQL USERS TO DISK /  SAVE MYSQL USERS FROM MEMORY
LOAD MYSQL USERS FROM CONFIG
mysql servers

LOAD MYSQL SERVERS TO RUNTIME   让修改的配置生效
SAVE MYSQL SERVERS TO MEMORY
LOAD MYSQL SERVERS TO MEMORY
SAVE MYSQL SERVERS TO DISK      将修改的配置持久化
LOAD MYSQL SERVERS FROM CONFIG
mysql query rules

load mysql query rules to run
save mysql query rules to mem
load mysql query rules to mem
save mysql query rules to disk
load mysql query rules from config
mysql variables

load mysql variables to runtime
save mysql variables to memory
load mysql variables to memory
save mysql variables to disk
load mysql variables from config
admin variables

load admin variables to runtime
save admin variables to memory
load admin variables to memory
save admin variables to disk
load admin variables from config
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sysown/proxysql/wiki/Multi-layer-configuration-system&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sysown/proxysql/wiki/Multi-layer-configuration-system&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://severalnines.com/blog/mysql-load-balancing-proxysql-overview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://severalnines.com/blog/mysql-load-balancing-proxysql-overview&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://seanlook.com/2017/04/10/mysql-proxysql-install-config/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://seanlook.com/2017/04/10/mysql-proxysql-install-config/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;ProxySQL读写分离示例&quot;&gt;&lt;a href=&quot;#ProxySQL读写分离示例&quot; class=&quot;headerlink&quot; title=&quot;ProxySQL读写分离示例&quot;&gt;&lt;/a&gt;ProxySQL读写分离示例&lt;/h1&gt;&lt;h2 id=&quot;准备-1&quot;&gt;&lt;a href=&quot;#准备-1&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;Master:192.168.56.101:3306&lt;br&gt;Slave :192.168.56.102:3306(192.168.56.102)&lt;br&gt;ProxySQL：192.168.56.102:3306(192.168.56.102)&lt;br&gt;版本：percona-server 5.7.18&lt;/p&gt;
&lt;h2 id=&quot;安装配置&quot;&gt;&lt;a href=&quot;#安装配置&quot; class=&quot;headerlink&quot; title=&quot;安装配置&quot;&gt;&lt;/a&gt;安装配置&lt;/h2&gt;&lt;p&gt;主从安装配置省略。&lt;/p&gt;
&lt;h2 id=&quot;示例目标&quot;&gt;&lt;a href=&quot;#示例目标&quot; class=&quot;headerlink&quot; title=&quot;示例目标&quot;&gt;&lt;/a&gt;示例目标&lt;/h2&gt;&lt;p&gt;客户端通过访问ProxySQL的ip，实际访问Master和Slave的效果。&lt;/p&gt;
&lt;h2 id=&quot;添加后端DB服务&quot;&gt;&lt;a href=&quot;#添加后端DB服务&quot; class=&quot;headerlink&quot; title=&quot;添加后端DB服务&quot;&gt;&lt;/a&gt;添加后端DB服务&lt;/h2&gt;&lt;p&gt;100是主库，101是从库，同时主库也处理1/10的读请求，登录ProxySQL管理端设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 14:22:06 &amp;gt; insert into mysql_servers(hostgroup_id,hostname,port,weight,comment) values(100, &amp;apos;192.168.56.101&amp;apos;, 3306, 1, &amp;apos;db0,ReadWrite&amp;apos;),(101, &amp;apos;192.168.56.102&amp;apos;, 3306, 9, &amp;apos;db0,ReadOnly&amp;apos;);
Query OK, 2 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;添加访问用户&quot;&gt;&lt;a href=&quot;#添加访问用户&quot; class=&quot;headerlink&quot; title=&quot;添加访问用户&quot;&gt;&lt;/a&gt;添加访问用户&lt;/h2&gt;&lt;p&gt;登录Master主库设置监控用户和程序用户(由于是测试使用，权限较大，主机允许所有)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 15:51:32 &amp;gt; create user &amp;apos;monitor&amp;apos;@&amp;apos;%&amp;apos; identified by &amp;apos;monitor&amp;apos;;
Query OK, 0 rows affected (0.00 sec)
MySQL [(none)] 15:51:37 &amp;gt; grant select,super,process,show databases,replication client,replication slave on *.* to &amp;apos;monitor&amp;apos;@&amp;apos;%&amp;apos;;
Query OK, 0 rows affected (0.00 sec)
MySQL [(none)] 15:45:23 &amp;gt; create user &amp;apos;user0&amp;apos;@&amp;apos;%&amp;apos; identified by &amp;apos;password0&amp;apos;;                   
Query OK, 0 rows affected (0.00 sec)
MySQL [(none)] 15:49:42 &amp;gt; GRANT SELECT, RELOAD, PROCESS, SHOW DATABASES, SUPER, LOCK TABLES, EXECUTE, SHOW VIEW, TRIGGER, EVENT ON *.* TO &amp;apos;read0&amp;apos;@&amp;apos;%&amp;apos;;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;登录ProxySQL管理端设置：&lt;br&gt;这里default_hostgroup指定了hostgroup为100的主库，下文会设置SELECT …FOR UPDATE规则到100，SELECT到101，其他所有的SQL到default_hostgroup，也就是主库。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 14:22:15 &amp;gt; INSERT INTO mysql_users (username, password, active, default_hostgroup, max_connections) VALUES (&amp;apos;user0&amp;apos;, &amp;apos;password0&amp;apos;, 1, 100, 1000); 
Query OK, 2 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;添加复制关系&quot;&gt;&lt;a href=&quot;#添加复制关系&quot; class=&quot;headerlink&quot; title=&quot;添加复制关系&quot;&gt;&lt;/a&gt;添加复制关系&lt;/h2&gt;&lt;p&gt;登录ProxySQL管理端设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [main] 17:32:46 &amp;gt; INSERT INTO mysql_replication_hostgroups VALUES(100,101,&amp;apos;db0&amp;apos;);
Query OK, 1 row affected (0.00 sec)
MySQL [main] 17:33:30 &amp;gt; load mysql variables to runtime;
Query OK, 0 rows affected (0.00 sec)
MySQL [main] 17:33:54 &amp;gt; save mysql variables to disk;
Query OK, 83 rows affected (0.01 sec)
MySQL [main] 17:35:53 &amp;gt; SELECT * FROM monitor.mysql_server_read_only_log ORDER BY time_start_us DESC LIMIT 10;
+---------------+------+------------------+-----------------+-----------+-------+
| hostname      | port | time_start_us    | success_time_us | read_only | error |
+---------------+------+------------------+-----------------+-----------+-------+
| 192.168.56.102  | 3306 | 1504085770195146 | 630             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504085770194710 | 23722           | 0         | NULL  |
| 192.168.56.102  | 3306 | 1504085768695087 | 650             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504085768694620 | 23706           | 0         | NULL  |
| 192.168.56.102  | 3306 | 1504085767194957 | 628             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504085767194507 | 23686           | 0         | NULL  |
| 192.168.56.102  | 3306 | 1504085765694834 | 634             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504085765694387 | 23669           | 0         | NULL  |
| 192.168.56.102  | 3306 | 1504085764194744 | 641             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504085764194301 | 23729           | 0         | NULL  |
+---------------+------+------------------+-----------------+-----------+-------+
10 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;修改全局变量&quot;&gt;&lt;a href=&quot;#修改全局变量&quot; class=&quot;headerlink&quot; title=&quot;修改全局变量&quot;&gt;&lt;/a&gt;修改全局变量&lt;/h2&gt;&lt;p&gt;登录ProxySQL管理端设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 14:25:07 &amp;gt; set mysql-query_retries_on_failure=0;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-max_stmts_per_connection=1000;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-eventslog_filename=&amp;apos;queries.log&amp;apos;;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-monitor_slave_lag_when_null=7200;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-ping_timeout_server=1500;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-monitor_connect_timeout=1000;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-default_max_latency_ms=2000;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-monitor_username=&amp;apos;monitor&amp;apos;;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-monitor_password=&amp;apos;monitor&amp;apos;;
Query OK, 1 row affected (0.00 sec)
MySQL [(none)] 14:25:07 &amp;gt; set mysql-server_version=&amp;apos;5.7.18&amp;apos;;
Query OK, 1 row affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;全局变量生效并保存到磁盘：&lt;br&gt;登录ProxySQL管理端设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 14:25:07 &amp;gt; load mysql users to runtime;
Query OK, 0 rows affected (0.00 sec)
MySQL [(none)] 14:25:27 &amp;gt; load mysql servers to runtime;
Query OK, 0 rows affected (0.00 sec)
MySQL [(none)] 14:25:27 &amp;gt; load mysql variables to runtime;
Query OK, 0 rows affected (0.00 sec)
MySQL [(none)] 14:25:28 &amp;gt; save mysql users to disk;
Query OK, 0 rows affected (0.02 sec)
MySQL [(none)] 14:25:36 &amp;gt; save mysql servers to disk;
save mysql variables to disk;Query OK, 0 rows affected (0.03 sec)
MySQL [(none)] 14:25:37 &amp;gt; save mysql variables to disk;
Query OK, 83 rows affected (0.01 sec)
MySQL [(none)] 14:25:37 &amp;gt; save mysql users to mem;  -- 可以屏蔽看到的明文密码
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;路由规则&quot;&gt;&lt;a href=&quot;#路由规则&quot; class=&quot;headerlink&quot; title=&quot;路由规则&quot;&gt;&lt;/a&gt;路由规则&lt;/h2&gt;&lt;p&gt;ProxySQL使用查询规则来确定路由，如果没有规则用于查询，默认会访问hostgroup 0主机组，会报以下错误：&lt;/p&gt;
&lt;p&gt;[root@mysql_slave ~]# mysql -uuser0 -ppassword0 -h 127.0.0.1 -P6033 -e “SELECT 1”&lt;br&gt;mysql: [Warning] Using a password on the command line interface can be insecure.&lt;br&gt;ERROR 9001 (HY000) at line 1: Max connect timeout reached while reaching hostgroup 1 after 2000ms&lt;br&gt;设置路由规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 09:29:14 &amp;gt; use main;
Database changed
MySQL [main] 09:29:17 &amp;gt; INSERT INTO mysql_query_rules (active, match_pattern, destination_hostgroup, cache_ttl) VALUES (1, &amp;apos;^.*&amp;apos;, 101, NULL);
MySQL [main] 09:29:15 &amp;gt; INSERT INTO mysql_query_rules (active, match_pattern, destination_hostgroup, cache_ttl) VALUES (1, &amp;apos;^SELECT .* FOR UPDATE&amp;apos;, 100, NULL);
Query OK, 1 row affected (0.00 sec)
MySQL [main] 09:29:17 &amp;gt; INSERT INTO mysql_query_rules (active, match_pattern, destination_hostgroup, cache_ttl) VALUES (1, &amp;apos;^SELECT .*&amp;apos;, 101, NULL);
Query OK, 1 row affected (0.00 sec)
MySQL [main] 09:29:18 &amp;gt; load mysql query rules to run;
Query OK, 0 rows affected (0.00 sec)
MySQL [main] 09:29:56 &amp;gt; save mysql query rules to disk;
Query OK, 0 rows affected (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;常用查询&quot;&gt;&lt;a href=&quot;#常用查询&quot; class=&quot;headerlink&quot; title=&quot;常用查询&quot;&gt;&lt;/a&gt;常用查询&lt;/h2&gt;&lt;p&gt;查询连接日志：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:45:08 &amp;gt; SELECT * FROM monitor.mysql_server_connect_log ORDER BY time_start_us DESC LIMIT 10;
+---------------+------+------------------+-------------------------+---------------+
| hostname      | port | time_start_us    | connect_success_time_us | connect_error |
+---------------+------+------------------+-------------------------+---------------+
| 192.168.56.102  | 3306 | 1504590343795072 | 410                     | NULL          |
| 192.168.56.101 | 3306 | 1504590343780010 | 69662                   | NULL          |
| 192.168.56.102  | 3306 | 1504590283795083 | 521                     | NULL          |
| 192.168.56.101 | 3306 | 1504590283779977 | 68310                   | NULL          |
| 192.168.56.102  | 3306 | 1504590223794987 | 533                     | NULL          |
| 192.168.56.101 | 3306 | 1504590223779913 | 53220                   | NULL          |
| 192.168.56.102  | 3306 | 1504590163794887 | 497                     | NULL          |
| 192.168.56.101 | 3306 | 1504590163779772 | 71389                   | NULL          |
| 192.168.56.102  | 3306 | 1504590103794788 | 487                     | NULL          |
| 192.168.56.101 | 3306 | 1504590103779728 | 68372                   | NULL          |
+---------------+------+------------------+-------------------------+---------------+
10 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询ping日志：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:46:22 &amp;gt; SELECT * FROM monitor.mysql_server_ping_log ORDER BY time_start_us DESC LIMIT 10;
+---------------+------+------------------+----------------------+------------+
| hostname      | port | time_start_us    | ping_success_time_us | ping_error |
+---------------+------+------------------+----------------------+------------+
| 192.168.56.102  | 3306 | 1504590413773092 | 100                  | NULL       |
| 192.168.56.101 | 3306 | 1504590413770521 | 23105                | NULL       |
| 192.168.56.102  | 3306 | 1504590403773088 | 168                  | NULL       |
| 192.168.56.101 | 3306 | 1504590403770479 | 23080                | NULL       |
| 192.168.56.102  | 3306 | 1504590393772977 | 135                  | NULL       |
| 192.168.56.101 | 3306 | 1504590393770364 | 23078                | NULL       |
| 192.168.56.102  | 3306 | 1504590383772899 | 138                  | NULL       |
| 192.168.56.101 | 3306 | 1504590383770309 | 23205                | NULL       |
| 192.168.56.102  | 3306 | 1504590373772885 | 102                  | NULL       |
| 192.168.56.101 | 3306 | 1504590373770291 | 23099                | NULL       |
+---------------+------+------------------+----------------------+------------+
10 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询后端DB状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:46:55 &amp;gt; SELECT * FROM mysql_servers;
+--------------+---------------+------+--------+--------+-------------+-----------------+---------------------+---------+----------------+---------------+
| hostgroup_id | hostname      | port | status | weight | compression | max_connections | max_replication_lag | use_ssl | max_latency_ms | comment       |
+--------------+---------------+------+--------+--------+-------------+-----------------+---------------------+---------+----------------+---------------+
| 100          | 192.168.56.101 | 3306 | ONLINE | 1      | 0           | 1000            | 0                   | 0       | 0              | db0,ReadWrite |
| 101          | 192.168.56.102  | 3306 | ONLINE | 9      | 0           | 1000            | 0                   | 0       | 0              | db0,ReadOnly  |
+--------------+---------------+------+--------+--------+-------------+-----------------+---------------------+---------+----------------+---------------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询监控状态：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:47:56 &amp;gt; SELECT * FROM monitor.mysql_server_read_only_log ORDER BY time_start_us DESC LIMIT 10;   
+---------------+------+------------------+-----------------+-----------+-------+
| hostname      | port | time_start_us    | success_time_us | read_only | error |
+---------------+------+------------------+-----------------+-----------+-------+
| 192.168.56.102  | 3306 | 1504590524103828 | 577             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504590524103406 | 23499           | 0         | NULL  |
| 192.168.56.102  | 3306 | 1504590522603717 | 646             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504590522603268 | 23487           | 0         | NULL  |
| 192.168.56.102  | 3306 | 1504590521103641 | 629             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504590521103182 | 23497           | 0         | NULL  |
| 192.168.56.102  | 3306 | 1504590519603662 | 639             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504590519603201 | 23525           | 0         | NULL  |
| 192.168.56.102  | 3306 | 1504590518103492 | 618             | 1         | NULL  |
| 192.168.56.101 | 3306 | 1504590518103062 | 23508           | 0         | NULL  |
+---------------+------+------------------+-----------------+-----------+-------+
10 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询用户信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:49:28 &amp;gt;  SELECT * FROM mysql_users;   
+----------+-----------+--------+---------+-------------------+----------------+---------------+------------------------+--------------+---------+----------+-----------------+
| username | password  | active | use_ssl | default_hostgroup | default_schema | schema_locked | transaction_persistent | fast_forward | backend | frontend | max_connections |
+----------+-----------+--------+---------+-------------------+----------------+---------------+------------------------+--------------+---------+----------+-----------------+
| user0    | password0 | 1      | 0       | 100               | NULL           | 0             | 1                      | 0            | 1       | 1        | 1000            |
+----------+-----------+--------+---------+-------------------+----------------+---------------+------------------------+--------------+---------+----------+-----------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询连接池：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:51:19 &amp;gt; SELECT * FROM stats.stats_mysql_connection_pool;
+-----------+---------------+----------+--------+----------+----------+--------+---------+---------+-----------------+-----------------+------------+
| hostgroup | srv_host      | srv_port | status | ConnUsed | ConnFree | ConnOK | ConnERR | Queries | Bytes_data_sent | Bytes_data_recv | Latency_us |
+-----------+---------------+----------+--------+----------+----------+--------+---------+---------+-----------------+-----------------+------------+
| 100       | 192.168.56.101 | 3306     | ONLINE | 0        | 1        | 1      | 0       | 3       | 58              | 233             | 23059      |
| 101       | 192.168.56.102  | 3306     | ONLINE | 0        | 1        | 3      | 88      | 5       | 106             | 360             | 102        |
+-----------+---------------+----------+--------+----------+----------+--------+---------+---------+-----------------+-----------------+------------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询执行命令统计信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:51:47 &amp;gt; SELECT * FROM stats_mysql_commands_counters WHERE Total_cnt;
+---------+---------------+-----------+-----------+-----------+---------+---------+----------+----------+-----------+-----------+--------+--------+---------+----------+
| Command | Total_Time_us | Total_cnt | cnt_100us | cnt_500us | cnt_1ms | cnt_5ms | cnt_10ms | cnt_50ms | cnt_100ms | cnt_500ms | cnt_1s | cnt_5s | cnt_10s | cnt_INFs |
+---------+---------------+-----------+-----------+-----------+---------+---------+----------+----------+-----------+-----------+--------+--------+---------+----------+
| SELECT  | 167664        | 27        | 15        | 4         | 0       | 6       | 0        | 1        | 0         | 1         | 0      | 0      | 0       | 0        |
| SET     | 0             | 2         | 2         | 0         | 0       | 0       | 0        | 0        | 0         | 0         | 0      | 0      | 0       | 0        |
| SHOW    | 13818         | 1         | 0         | 0         | 0       | 0       | 0        | 1        | 0         | 0         | 0      | 0      | 0       | 0        |
+---------+---------------+-----------+-----------+-----------+---------+---------+----------+----------+-----------+-----------+--------+--------+---------+----------+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询路由规则的详情：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:53:05 &amp;gt; SELECT * FROM stats_mysql_query_digest ORDER BY sum_time DESC;
+-----------+--------------------+----------+--------------------+----------------------------------+------------+------------+------------+----------+----------+----------+
| hostgroup | schemaname         | username | digest             | digest_text                      | count_star | first_seen | last_seen  | sum_time | min_time | max_time |
+-----------+--------------------+----------+--------------------+----------------------------------+------------+------------+------------+----------+----------+----------+
| 100       | information_schema | user0    | 0xA322907BCBC120DD | select * from tables limit ?     | 1          | 1504589288 | 1504589288 | 133826   | 133826   | 133826   |
| 100       | information_schema | user0    | 0x02033E45904D3DF0 | show databases                   | 1          | 1504589886 | 1504589886 | 13818    | 13818    | 13818    |
| 100       | information_schema | user0    | 0x3765930C7143F468 | select * from t1                 | 1          | 1504589311 | 1504589311 | 13466    | 13466    | 13466    |
| 101       | information_schema | user0    | 0xA322907BCBC120DD | select * from tables limit ?     | 2          | 1504582304 | 1504583327 | 7325     | 3564     | 3761     |
| 101       | test               | user0    | 0x814EDBB68FBACD5D | select * from neworders limit ?  | 2          | 1504583184 | 1504583242 | 5959     | 2964     | 2995     |
| 101       | test               | user0    | 0x3765930C7143F468 | select * from t1                 | 3          | 1504583288 | 1504589859 | 3386     | 64       | 3056     |
| 101       | test               | user0    | 0xA322907BCBC120DD | select * from tables limit ?     | 2          | 1504583168 | 1504583299 | 3095     | 117      | 2978     |
| 101       | information_schema | user0    | 0x620B328FE9D6D71A | SELECT DATABASE()                | 2          | 1504589729 | 1504589859 | 607      | 193      | 414      |
| 100       | information_schema | user0    | 0x226CD90D52A2BA0B | select @@version_comment limit ? | 8          | 1504582304 | 1504589886 | 0        | 0        | 0        |
| 100       | test               | user0    | 0x52B8B04283B3A18D | set names utf8                   | 1          | 1504583162 | 1504583162 | 0        | 0        | 0        |
| 100       | information_schema | user0    | 0x52B8B04283B3A18D | set names utf8                   | 1          | 1504582582 | 1504582582 | 0        | 0        | 0        |
| 100       | test               | user0    | 0x226CD90D52A2BA0B | select @@version_comment limit ? | 6          | 1504583162 | 1504583299 | 0        | 0        | 0        |
+-----------+--------------------+----------+--------------------+----------------------------------+------------+------------+------------+----------+----------+----------+
12 rows in set (0.00 sec)
MySQL [(none)] 13:55:46 &amp;gt; SELECT hostgroup hg, sum_time, count_star, digest_text FROM stats_mysql_query_digest ORDER BY sum_time DESC;
+-----+----------+------------+----------------------------------+
| hg  | sum_time | count_star | digest_text                      |
+-----+----------+------------+----------------------------------+
| 100 | 133826   | 1          | select * from tables limit ?     |
| 100 | 13818    | 1          | show databases                   |
| 100 | 13466    | 1          | select * from t1                 |
| 101 | 7325     | 2          | select * from tables limit ?     |
| 101 | 5959     | 2          | select * from neworders limit ?  |
| 101 | 3386     | 3          | select * from t1                 |
| 101 | 3095     | 2          | select * from tables limit ?     |
| 101 | 607      | 2          | SELECT DATABASE()                |
| 100 | 0        | 8          | select @@version_comment limit ? |
| 100 | 0        | 1          | set names utf8                   |
| 100 | 0        | 1          | set names utf8                   |
| 100 | 0        | 6          | select @@version_comment limit ? |
+-----+----------+------------+----------------------------------+
12 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询路由规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)] 13:57:12 &amp;gt; SELECT rule_id, match_digest, match_pattern, replace_pattern, cache_ttl, apply FROM mysql_query_rules ORDER BY rule_id;
+---------+--------------+-----------------------+-----------------+-----------+-------+
| rule_id | match_digest | match_pattern         | replace_pattern | cache_ttl | apply |
+---------+--------------+-----------------------+-----------------+-----------+-------+
| 10      | NULL         | ^SELECT .* FOR UPDATE | NULL            | NULL      | 0     |
| 11      | NULL         | ^SELECT .*            | NULL            | NULL      | 0     |
+---------+--------------+-----------------------+-----------------+-----------+-------+
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sysown/proxysql/wiki/ProxySQL-Configuration#p6033&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sysown/proxysql/wiki/ProxySQL-Configuration#p6033&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://seanlook.com/2017/04/17/mysql-proxysql-route-rw_split/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://seanlook.com/2017/04/17/mysql-proxysql-route-rw_split/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://severalnines.com/blog/how-proxysql-adds-failover-and-query-control-your-mysql-replication-setup&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://severalnines.com/blog/how-proxysql-adds-failover-and-query-control-your-mysql-replication-setup&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;ProxySQL监控&quot;&gt;&lt;a href=&quot;#ProxySQL监控&quot; class=&quot;headerlink&quot; title=&quot;ProxySQL监控&quot;&gt;&lt;/a&gt;ProxySQL监控&lt;/h1&gt;&lt;p&gt;PMM是Percona推出的一款很好的监控MySQL和MongoDB的开源工具，安装方便，功能丰富，图表美观，同时也支持ProxySQL的监控，故选择PMM作为ProxySQL的监控软件。&lt;br&gt;这里以ProxySQL服务端(192.168.56.102)为例，作为PMM的客户端，PMM服务器为192.168.56.111,仅演示ProxySQL安装PMM客户端，服务器安装配置省略。&lt;/p&gt;
&lt;h2 id=&quot;PMM-Client安装&quot;&gt;&lt;a href=&quot;#PMM-Client安装&quot; class=&quot;headerlink&quot; title=&quot;PMM Client安装&quot;&gt;&lt;/a&gt;PMM Client安装&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;[root@mysql_slave ~]# yum localinstall -y /hwdata/duanwenjie/test/proxysql-1.4.1-1-centos67.x86_64.rpm 
Loaded plugins: security
Setting up Local Package Process
Examining /hwdata/duanwenjie/test/proxysql-1.4.1-1-centos67.x86_64.rpm: proxysql-1.4.1-1.x86_64
Marking /hwdata/duanwenjie/test/proxysql-1.4.1-1-centos67.x86_64.rpm to be installed
Resolving Dependencies
There are unfinished transactions remaining. You might consider running yum-complete-transaction first to finish them.
--&amp;gt; Running transaction check
---&amp;gt; Package proxysql.x86_64 0:1.4.1-1 will be installed
--&amp;gt; Finished Dependency Resolution
Dependencies Resolved
========================================================================================================================================================================
 Package                           Arch                            Version                             Repository                                                  Size
========================================================================================================================================================================
Installing:
 proxysql                          x86_64                          1.4.1-1                             /proxysql-1.4.1-1-centos67.x86_64                           19 M
Transaction Summary
========================================================================================================================================================================
Install       1 Package(s)
Total size: 19 M
Installed size: 19 M
Downloading Packages:
Running rpm_check_debug
Running Transaction Test
Transaction Test Succeeded
Running Transaction
Warning: RPMDB altered outside of yum.
** Found 1 pre-existing rpmdb problem(s), &amp;apos;yum check&amp;apos; output follows:
mysql-community-libs-5.7.16-1.el6.x86_64 has missing requires of mysql-community-common(x86-64) &amp;gt;= (&amp;apos;0&amp;apos;, &amp;apos;5.7.9&amp;apos;, None)
  Installing : proxysql-1.4.1-1.x86_64                                                                                                                              1/1 
  Verifying  : proxysql-1.4.1-1.x86_64                                                                                                                              1/1 
Installed:
  proxysql.x86_64 0:1.4.1-1                                                                                                                                             
Complete!
[root@mysql_slave ~]#
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;PMM-Client配置&quot;&gt;&lt;a href=&quot;#PMM-Client配置&quot; class=&quot;headerlink&quot; title=&quot;PMM Client配置&quot;&gt;&lt;/a&gt;PMM Client配置&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;[root@mysql_slave ~]# ifconfig  #查看IP地址
eth0      Link encap:Ethernet  HWaddr 00:16:3E:00:DC:49  
          inet addr:192.168.56.102  Bcast:192.168.15.255  Mask:255.255.240.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1017660 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1380639 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:273791594 (261.1 MiB)  TX bytes:116287303 (110.9 MiB)
lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:1297762 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1297762 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:141606631 (135.0 MiB)  TX bytes:141606631 (135.0 MiB)
[root@mysql_slave ~]# pmm-admin config --bind-address 192.168.56.102 --client-address 192.168.56.102 --server 192.168.56.111:8080 --client-name ProxySQL_Test   #添加config
OK, PMM server is alive.
PMM Server      | 192.168.56.111:8080 
Client Name     | ProxySQL_Test
Client Address  | 192.168.56.102 (192.168.56.102)
[root@mysql_slave ~]# pmm-admin add linux:metrics --force ProxySQL_Test     #添加Linux监控
OK, now monitoring this system.
[root@mysql_slave ~]# 
[root@mysql_slave ~]# pmm-admin add proxysql:metrics --dsn &amp;quot;admin:admin@tcp(127.0.0.1:6032)/&amp;quot; proxysql6032 #添加ProxySQL监控
OK, now monitoring ProxySQL metrics using DSN admin:***@tcp(localhost:6032)
[root@mysql_slave ~]# 
[root@mysql_slave ~]# pmm-admin list    #查看状态
pmm-admin 1.3.0
PMM Server      | 192.168.56.111:8080 
Client Name     | ProxySQL_Test
Client Address  | 192.168.56.102 (192.168.56.102)
Service Manager | unix-systemv
----------------- -------------- ----------- -------- ------------------------------ --------
SERVICE TYPE      NAME           LOCAL PORT  RUNNING  DATA SOURCE                    OPTIONS 
----------------- -------------- ----------- -------- ------------------------------ --------
linux:metrics     ProxySQL_Test  42000       YES      -                                      
mysql:metrics     ProxySQL_Test  42002       YES      root:***@tcp(127.0.0.1:3306)           
proxysql:metrics  proxysql6032   42004       YES      admin:***@tcp(127.0.0.1:6032)          
[root@mysql_slave ~]#
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PMM Server监控项包括：&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;ProxySQL是一款很出色的MySQL中间件，在稳定性上、易用性、高性能等方面表现很不错。由于发布的时间较短，功能可能还不太完善，需要多做测试，特别是查询路由和规则方面需要详情的了解，测试。可重点关注。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在MySQL的高可用集群环境中，中间件是不可缺少的一部分，它提供了读写分离、负载均衡等各种功能，满足集群的横向、纵向的可扩展。由于
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="读写分离" scheme="http://idber.github.io/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>内存的80％？应该如何调整你的innodb_buffer_pool_size</title>
    <link href="http://idber.github.io/2018/08/26-%E5%86%85%E5%AD%98%E7%9A%8480%EF%BC%85%EF%BC%9F%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E4%BD%A0%E7%9A%84innodb_buffer_pool_size.html"/>
    <id>http://idber.github.io/2018/08/26-内存的80％？应该如何调整你的innodb_buffer_pool_size.html</id>
    <published>2018-08-26T02:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.935Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;现在看来，如果有人知道如何调优InnoDB，那就是你必须将innodb_buffer_pool_size调整到物理内存的80％。多数都是这样建议，它似乎深深植根于DBA的脑海中。&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL手册&lt;/a&gt;引用了这个规则，那么谁能责怪DBA呢？问题是：这有意义吗？&lt;/p&gt;
&lt;h1 id=&quot;什么使用服务器上的内存？&quot;&gt;&lt;a href=&quot;#什么使用服务器上的内存？&quot; class=&quot;headerlink&quot; title=&quot;什么使用服务器上的内存？&quot;&gt;&lt;/a&gt;什么使用服务器上的内存？&lt;/h1&gt;&lt;p&gt;在我们质疑这样的建议之前，让我们考虑一下在典型的MySQL服务器中可以占用RAM的广泛类别。这个列表不一定完整，但我认为它概述了MySQL服务器消耗内存的大面积。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;操作系统：内核，正在运行的进程，文件系统缓存等。
MySQL固定使用：查询缓存，InnoDB缓冲池大小，mysqld rss等。
基于MySQL工作负载的使用：连接，每个查询缓冲区（连接缓冲区，排序缓冲区等）
MySQL复制：  二进制日志缓存，复制连接，Galera gcache和证书索引等。
同一服务器上的任何其他服务： Web服务器，缓存服务器，cronjobs等。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;毫无疑问，对于调优InnoDB，innodb_buffer_pool_size是最重要的变量。预计它将占用专用MySQL / Innodb服务器上的大部分RAM，但当然其他本地服务可能会影响它的调整方式。如果它（以及服务器上的其他内存消耗）太大，交换可能会启动并迅速降低性能。&lt;/p&gt;
&lt;p&gt;此外，MySQL服务器本身的工作量可能会导致很多变化。服务器是否有大量的开放连接和活动查询工作负载消耗内存？由此引起的内存消耗可能与服务器有很大不同。&lt;/p&gt;
&lt;p&gt;最后，像Galera这样的复制机制有自己的内存使用模式，可能需要对缓冲池进行一些调整。&lt;/p&gt;
&lt;p&gt;我们可以清楚地看到，80％的规则并不像现实那样微妙。&lt;/p&gt;
&lt;h1 id=&quot;经验法则&quot;&gt;&lt;a href=&quot;#经验法则&quot; class=&quot;headerlink&quot; title=&quot;经验法则&quot;&gt;&lt;/a&gt;经验法则&lt;/h1&gt;&lt;p&gt;但是，为了论证，让我们说80％的规则是一个起点。根据经验，帮助我们获得快速调整数字以使服务器运行。假设我们对系统的工作负载还不知道，但我们知道该系统专用于InnoDB，我们的80％规则怎么能发挥作用呢？&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;服务器总RAM&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;具有80％规则的缓冲池&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;剩余的RAM&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;800MB&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;200MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;16G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;13G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;3G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;32G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;26G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;6G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;64G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;51G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;13G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;128G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;102G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;26G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;256G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;205G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;51G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;512G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;409G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;103G&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1024G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;819G&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;205G&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;数字较低，我们的80％规则看起来很合理。然而，当我们进入大型服务器时，它似乎开始变得不那么理智了。要使规则成立，它必须意味着工作负载内存消耗与缓冲池所需大小成比例增加，但通常情况并非如此。我们的服务器具有1TB的RAM可能不需要205G来处理连接和查询之类的东西（可能MySQL无法处理那么多活动连接和查询）。&lt;/p&gt;
&lt;p&gt;那么，如果你真的把所有的钱花在了一台强大的服务器上，你是否真的想因为这个经验法则对该资源征收20％的税？&lt;/p&gt;
&lt;h1 id=&quot;规则的起源&quot;&gt;&lt;a href=&quot;#规则的起源&quot; class=&quot;headerlink&quot; title=&quot;规则的起源&quot;&gt;&lt;/a&gt;规则的起源&lt;/h1&gt;&lt;p&gt;在我的第一次MySQL会议上，可能是在2006-2007我在雅虎工作时，我参加了由Heikki Tuuri（InnoDB的原作者）和Peter Zaitsev主持的InnoDB调优讲座。我清楚地记得询问80％的规则，因为当时雅虎有一些强大的64G服务器而且规则并不适合我。&lt;/p&gt;
&lt;p&gt;Heikki的答案让我印象深刻。他说了一些（不是直接引用）的结果：“好吧，我测试的服务器有1GB内存，80％似乎是正确的”。然后，如果记忆服务，他澄清了它并说它不会适用于更大的服务器。&lt;/p&gt;
&lt;h1 id=&quot;你应该如何调整？&quot;&gt;&lt;a href=&quot;#你应该如何调整？&quot; class=&quot;headerlink&quot; title=&quot;你应该如何调整？&quot;&gt;&lt;/a&gt;你应该如何调整？&lt;/h1&gt;&lt;p&gt;80％可能是一个很好的开始和经验法则。您确实希望确保服务器有足够的可用RAM用于操作系统和通常未知的工作负载。但是，正如我们上面所看到的，服务器越大，规则就越有可能浪费RAM。我认为对于大多数人来说，它以经验法则开始和结束，主要是因为更改InnoDB缓冲池需要在当前版本中重新启动。&lt;/p&gt;
&lt;p&gt;那么什么是更好的经验法则？我的规则是，当系统运行生产工作负载时，您可以在不使用swap的情况下调整innodb_buffer_pool_size尽可能大。原则上听起来不错，但同样需要一堆重启，说起来容易做起来难。&lt;/p&gt;
&lt;p&gt;幸运的是，  MySQL 5.7及其在线缓冲池调整大小功能应该使这个原则更容易理解。看到大量的空闲RAM（或者文件系统缓存使用）？动态调高缓冲池。看到一些交换活动？只需将其关闭即可，无需重启。在实践中，我怀疑使用此功能会有一些与性能相关的打嗝，但这至少是朝着正确方向迈出的一大步。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;现在看来，如果有人知道如何调优InnoDB，那就是你必须将innodb_buffer_pool_size调整到物理内存的80％。多数都是这样建议，它似乎深深植根于DBA的脑海中。&lt;a href=&quot;https://dev.mysql.com/doc/refman/5
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="性能" scheme="http://idber.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 5.7新特性系列二</title>
    <link href="http://idber.github.io/2018/08/24-MySQL%205.7%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%E4%BA%8C.html"/>
    <id>http://idber.github.io/2018/08/24-MySQL 5.7新特性系列二.html</id>
    <published>2018-08-23T22:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.929Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;系统变量&lt;br&gt;5.7以后System and status 变量需要从performance_schema中进行获取，information_schema仍然保留了GLOBAL_STATUS，GLOBAL_VARIABLES两个表做兼容。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[兼容性]&lt;br&gt;如果希望沿用information_schema中进行查询的习惯，5.7提供了show_compatibility_56参数，设置为ON可以兼容5.7之前的用法，否则就会报错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ERROR 3167 (HY000): The &amp;apos;INFORMATION_SCHEMA.GLOBAL_STATUS&amp;apos; feature is disabled; see the documentation for &amp;apos;show_compatibility_56&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.7.6之后，在performance_schema新增了如下的表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;performance_schema.global_variables
performance_schema.session_variables
performance_schema.variables_by_thread
performance_schema.global_status
performance_schema.session_status
performance_schema.status_by_thread
performance_schema.status_by_account
performance_schema.status_by_host
performance_schema.status_by_user
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.7.9之前，需要有SELECT_ACL权限才能进行show查询，但5.7.9之后，默认这些表是不需要任何权限就可以访问了。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;sys schema&lt;br&gt;新增了sys数据库，主要是performance_schema收集的信息，帮助DBA和开发人员方便诊断问题。 sys下的一共包括三种对象：1. view，2. procedure 3 function 这些对象都是基于performance_schema下的表，进行了可读性的聚合，没有真正存储数据，只存储了定义。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[兼容性]&lt;br&gt;mysql_install_db可以选择–skip-sys-schema跳过安装过程， 但默认mysql_upgrade会帮你创建sys下面的对象。不存在兼容性的问题&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;p&gt;异常栈&lt;br&gt;5.7开始支持异常诊断栈信息，通过GET STACKED DIAGNOSTICS可以获取栈内的信息。 具体的使用方法参考：&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/diagnostics-area.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/diagnostics-area.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Triggers&lt;br&gt;支持在一个table对象上建多个trigger。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Generated Columns&lt;br&gt;5.7.6开始，支持生成列，这个列可以是虚拟的列，也可以是实体存储数据的列。 比如：&lt;/p&gt;
&lt;p&gt; CREATE TABLE triangle (&lt;br&gt;   sidea DOUBLE,&lt;br&gt;   sideb DOUBLE,&lt;br&gt;   sidec DOUBLE AS (SQRT(sidea &lt;em&gt; sidea + sideb &lt;/em&gt; sideb))&lt;br&gt; );&lt;br&gt;VIRTUAL： 表示这个字段是虚拟列，并不进行存储，查询的时候，通过计算得到&lt;br&gt;STORED： 需要存储空间，并且可以被索引的列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;exchange partition不验证&lt;br&gt;这个是在oracle分区表上支持的功能，dba在做大表维护的时候，非常有用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;语法： ALTER TABLE … EXCHANGE PARTITION WITHOUT VALIDATION&lt;br&gt;如果不验证，那么只有元数据信息的更改，就可以完成exchange，否则，就需要读取每一行数据进行验证，维护时间将根据这个表大小有关系。&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;&lt;p&gt;dump线程增强&lt;br&gt;5.7.2之前，master dump线程需要持有LOCK_log锁去读取binlog然后发送到备库，而这时会阻塞client端去写入binlog。5.7.2之后，dump线程只需要持有LOCK_binlog_end_pos这个锁去读取binlog的当前的位置，来决定是否发送到备库去，这样就可以做到不阻塞任何binlog的写入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多源复制&lt;br&gt;多源复制可以从多个master复制到一个slave端，在数据库集群进行扩容和缩容的时候，非常有用。我们会在后面的系列单独来介绍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在线更改replication master&lt;br&gt;可以不用stop slave，然后在线更改replication master信息。 但这里并不是不需要slave停掉， 而是change master涉及到几个动作：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果只是更改当前relay的信息，那么只需要sql线程是不工作的就可以了，IO thread可以继续&lt;br&gt;如果只是更改主库的信息，那么只需要IO线程不工作就可以了。 sql thread可以继续&lt;br&gt;如果需要重新启动主库和备库的恢复信息，比如master_auto_positioin=1，那么就需要IO和sql线程都停掉。&lt;/p&gt;
&lt;ol start=&quot;10&quot;&gt;
&lt;li&gt;Group Replication&lt;br&gt;并行复制支持按照主库组提交的形式在备库进行回放。下一个系列进行单独来介绍&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面单独介绍一下MySQL 5.7对临时表进行的改动。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;背景&lt;br&gt;MySQL包括两类临时表，一类是通过create temporary table创建的临时表，一类是在query过程中using temporary而创建的临时表。 5.7之前，using temporary创建的临时表，默认只能使用myisam引擎，而在5.7之后，可以选择InnoDB引擎来创建。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;临时表的引擎选择使用下面的这两个参数来决定：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show global variables like &amp;apos;%tmp%&amp;apos;;
+----------------------------------+---------------------------------------+
| Variable_name                    | Value                                 |
+----------------------------------+---------------------------------------+
| default_tmp_storage_engine       | InnoDB                                |
| internal_tmp_disk_storage_engine | InnoDB                                |
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;临时表空间&lt;br&gt;5.7之后，使用了独立的临时表空间来存储临时表数据，但不能是压缩表。临时表空间在实例启动的时候进行创建，shutdown的时候进行删除。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如如下的配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show global variables like &amp;apos;%innodb_temp%&amp;apos;; 
+----------------------------+-----------------------+
| Variable_name              | Value                 |
+----------------------------+-----------------------+
| innodb_temp_data_file_path | ibtmp1:12M:autoextend |
+----------------------------+-----------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;create temporary table和using temporary table将共用这个临时表空间。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;临时表优化&lt;br&gt;临时表会伴随着大量的数据写入和读取，尤其是internal_tmp_table。所以，InnoDB专门对临时表进行了优化。&lt;br&gt;InnoDB使用如下两个标示临时表：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;dict_tf2_temporary： 表示普通临时表&lt;br&gt;dict_tf2_intrinsic： 表示内部临时表&lt;br&gt;这两个标示，会在IBD文件的segment header占用两个bit位。intrinsic一定是temproary，也就是temproary上进行的优化 完全适用于intrinsic表上。&lt;/p&gt;
&lt;p&gt;下面来看下具体的优化：&lt;/p&gt;
&lt;p&gt;3.1. redo&lt;br&gt;临时表在连接断开或者数据库实例关闭的时候，会进行删除，所以，临时表的数据不需要redo来保护，即recovery的过程中 不恢复临时表，只有临时表的metadata使用了redo保护，保护元数据的完整性，以便异常启动后进行清理工作。&lt;/p&gt;
&lt;p&gt;临时表的元数据，5.7之后，使用了一个独立的表进行保存，这样就不要使用redo保护，元数据也只保存在内存中。 但这有一个前提，必须使用共享的临时表空间，如果使用file-per-table，仍然需要持久化元数据，以便异常恢复清理。&lt;/p&gt;
&lt;p&gt;3.2 undo&lt;br&gt;temporary table仍然需要语句级的回滚，所以，需要为数据生成undo。但intrinsic table不需要回滚，所以，intrinsic table 减少了undo的生成，性能更高。&lt;/p&gt;
&lt;p&gt;3.3 lock&lt;br&gt;因为临时表只有本线程可以看见，所以减少了InnoDB的加锁过程。&lt;/p&gt;
&lt;p&gt;可以看下insert的时候，进行的分支判断：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; row_insert_for_mysql(
    const byte*        mysql_rec,
    row_prebuilt_t*        prebuilt)
{
    /* For intrinsic tables there a lot of restrictions that can be
    relaxed including locking of table, transaction handling, etc.
    Use direct cursor interface for inserting to intrinsic tables. */
    if (dict_table_is_intrinsic(prebuilt-&amp;gt;table)) {
        return(row_insert_for_mysql_using_cursor(mysql_rec, prebuilt));
    } else {
        return(row_insert_for_mysql_using_ins_graph(
            mysql_rec, prebuilt));
    }
}
row_insert_for_mysql_using_cursor直接跳过了加锁的lock_table过程。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后，如果是intrinsic table，就直接插入，减少了undo的生成。&lt;br&gt;如果不是，需要加lock，并生成undo信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (dict_table_is_intrinsic(index-&amp;gt;table)) {

            index-&amp;gt;rec_cache.rec_size = rec_size;

            *rec = page_cur_tuple_direct_insert(
                page_cursor, entry, index, n_ext, mtr);
        } else {
            /* Check locks and write to the undo log,
            if specified */
            err = btr_cur_ins_lock_and_undo(flags, cursor, entry,
                            thr, mtr, &amp;amp;inherit);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;插入的时候，如果是临时表。就关闭redo的生成。如下面的代码所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (dict_table_is_temporary(index-&amp;gt;table)) {
        /* Disable REDO logging as the lifetime of temp-tables is
        limited to server or connection lifetime and so REDO
        information is not needed on restart for recovery.
        Disable locking as temp-tables are local to a connection. */

        ut_ad(flags &amp;amp; BTR_NO_LOCKING_FLAG);
        ut_ad(!dict_table_is_intrinsic(index-&amp;gt;table)
              || (flags &amp;amp; BTR_NO_UNDO_LOG_FLAG));

        mtr.set_log_mode(MTR_LOG_NO_REDO);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;未完待续，下一个系列，我们将介绍一下undo的新特性，包括online truncated undo。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;系统变量&lt;br&gt;5.7以后System and status 变量需要从performance_schema中进行获取，information_schema仍然保留了GLOBAL_STATUS，GLOBAL_VARIABLES两个表做兼容。&lt;/li&gt;

    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="新特性" scheme="http://idber.github.io/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>MySQL经典模板参数详解</title>
    <link href="http://idber.github.io/2018/08/19-MySQL%E7%BB%8F%E5%85%B8%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3.html"/>
    <id>http://idber.github.io/2018/08/19-MySQL经典模板参数详解.html</id>
    <published>2018-08-18T22:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.931Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;最近两天整理的参数文件详细说明，常用的参数都涉及到了，主要适用于MySQL 5.6，参考姜承尧老师的mysql_best_configuration，时间匆忙，后续发现错误会及时更正。&lt;br&gt;&lt;a href=&quot;https://github.com/jdaaaaaavid/mysql_best_configuration&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源文件&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[mysql]
prompt=\\u@\\d \\r:\\m:\\s&amp;gt;
default_character_set=utf8 #character_set_client、character_set_connection、character_set_results这3个参数值是由客户端每次连接进来设置的，和服务器端没关系。我们登陆进mysql后，执行 set names utf8; 实际就是同时修改上面的这3个参数值的。
no_auto_rehash #启用自动补全功能，类似linux下tab补全。默认情况下，此选项处于启用状态，可以使数据库，表和列名称完成。使用 --disable-auto-rehash 禁用换汤不换药。禁用会导致mysql启动得更快，可以在连接时指定参数，例：mysql -u root --auto-rehash

[mysqld_safe]
malloc_lib=tcmalloc  #tcmalloc是Google开源的一个内存管理库， 作为glibc malloc的替代品。目前已经在chrome、safari等知名软件中运用。

[mysqldump]
single_transaction #single-transaction 选项和 lock-all-tables 选项是二选一的，前者是在导出开始时设置事务隔离状态并使用一致性快照开始事务,而后马上unlock tables，然后执行导出,导出过程不影响其它事务或业务连接，但只支持类似innodb多版本特性的引擎，因为必须保证即使导出期间其它操作(事务点t2)改变了数据，而导出时仍能取出导出开始的事务点t1时的数据。而lock-all-tables则一开始就 FLUSH TABLES WITH READ LOCK; 加全局读锁，直到dump完毕。
# -- 关于一致性快照，简单地说，就是通过回滚段能记录不同的事务点的各版本数据
# -- single-transaction 的流程如下：

[mysqld]
# basic settings #
user = mysql #mysql以什么用户运行 #-u, --user=name     Run mysqld daemon as user.
# sql_mode = &amp;quot;STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER&amp;quot;
# STRICT_TRANS_TABLES：严格模式，在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做任何限制
# NO_ZERO_IN_DATE：在严格模式，不接受月或日部分为0的日期。如果使用IGNORE选项，我们为类似的日期插入&amp;apos;0000-00-00&amp;apos;。在非严格模式，可以接受该日期，但会生成警告。
# NO_ZERO_DATE：在严格模式，不要将 &amp;apos;0000-00-00&amp;apos;做为合法日期。你仍然可以用IGNORE选项插入零日期。在非严格模式，可以接受该日期，但会生成警告
# ERROR_FOR_DIVISION_BY_ZERO：在严格模式，在INSERT或UPDATE过程中，如果被零除(或MOD(X，0))，则产生错误(否则为警告)。如果未给出该模式，被零除时MySQL返回NULL。如果用到INSERT IGNORE或UPDATE IGNORE中，MySQL生成被零除警告，但操作结果为NULL
# NO_AUTO_CREATE_USER：防止GRANT自动创建新用户，除非还指定了密码。
# NO_ENGINE_SUBSTITUTION：如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常autocommit = 1
server_id=8888 #指定服务器ID。此变量由--server-id选项设置 。在复制主服务器和每个复制从服务器上， 必须指定--server-id用于建立1到2 32到1范围内的唯一复制ID 的 选项。 “ 唯一 ”表示每个ID必须与任何正在使用的其他ID不同其他复制主机或从机。
character_set_server= utf8  #即使在配置文件里根本就没有配置character_set_database，重启mysql后character_set_database变量值也会和character_set_server保持一致，故只需要配置character_set_server就行了。如果库里有latin1，character_set_database会显示为latin1，需要把latin1的库改为utf8，character_set_database无法直接在配置文件里设置，会报错The server quit without updating PID file [FAILED]ysql/mysql/data/mysql.pid).
basedir=/home/mysql/mysql #MySQL安装基目录的路径
datadir=/home/mysql/mysql/data #MySQL服务器数据目录的路径。
transaction_isolation=READ-COMMITTED #事务隔离级别RC 如果您的查询和事务很短：请使用默认的REPEATABLE-READ模式！如果您的查询很长并且读取了很多可能被其他事务并行修改的数据：那么使用READ-COMMITTED模式 - 这将允许您在查询进行时读取已提交的更改并避免丢失而不是扫描旧页面图像（正如PeterZ在他的故事中向你展示的那样;-)）
explicit_defaults_for_timestamp = 1 #主要解决默认值为NULL的问题，应该放弃timestamp类型，此参数就不用设置了
max_allowed_packet=1073741824 #设置1G #MySQL根据配置文件会限制Server接受的数据包大小。有时候大的插入和更新会受 max_allowed_packet 参数限制，导致写入或者更新失败。
event_scheduler = 1 #全局变量event_scheduler用来设定是否服务器端运行执行计划任务，该变量有如下三种值：
# OFF：计划任务处于停止状态，event scheduler线程没有运行。是event_scheduler的默认值（执行一下任意一条命令关闭）；
# ON：计划任务处于运行状态，event scheduler线程启动，并执行所有的计划任务（执行一下任意一条命令开启）；
# DISABLED：该值将致使计划任务不可运行
lower_case_table_names=1 #0敏感1不敏感2不敏感     unix、linux下lower_case_table_names默认值为 0 .Windows下默认值是 1 .Mac OS X下默认值是 2 ,linux下不生效.
open_files_limit=65536 #操作系统允许mysqld打开的文件数 。此变量在运行时的值是系统允许的实际值，可能与您在服务器启动时指定的值不同。在MySQL无法更改打开文件数的系统上，该值为0。
default_storage_engine=INNODB

# connection #
interactive_timeout = 1800 
wait_timeout = 1800 #1. 控制连接最大空闲时长的wait_timeout参数。
# 2. 对于非交互式连接，类似于jdbc连接，wait_timeout的值继承自服务器端全局变量wait_timeout。对于交互式连接，类似于mysql客户单连接，wait_timeout的值继承自服务器端全局变量interactive_timeout。
# 3. 判断一个连接的空闲时间，可通过show processlist输出中Sleep状态的时间
lock_wait_timeout = 1800 #此变量指定尝试获取元数据锁的超时（以秒为单位）。允许值范围为1到31536000（1年）。默认值为31536000。此超时适用于使用元数据锁的所有语句。这些措施包括对表，视图DML和DDL操作，存储过程和存储功能，以及 LOCK TABLES， FLUSH TABLES WITH READ LOCK和HANDLER语句。
skip_name_resolve = 1 #此变量是从--skip-name-resolve选项的值设置的 。如果是OFF，mysqld 在检查客户端连接时解析主机名。如果是 ON，mysqld只使用IP号码; 在这种情况下，Host授权表中的所有列值必须是IP地址或 localhost。
max_connections = 4500 #允许的最大同时客户端连接数。默认情况下是151
max_user_connections = 256 #允许任何给定MySQL用户帐户的最大并发连接数。值0（默认值）表示 “ 无限制。”
max_connect_errors = 1000000 #如果来自主机的多个连续连接请求在没有成功连接的情况下中断，则服务器会阻止该主机进一步连接。您可以通过刷新主机缓存来取消阻止阻止的主机。为此，请发出FLUSH HOSTS声明或执行mysqladmin flush-hosts 命令。如果max_connect_errors 在先前连接中断后少于尝试的连接成功建立连接，则主机的错误计数将清零。但是，一旦主机被阻止，刷新主机缓存是解除阻塞的唯一方法。默认值为100。


# table cache performance settings
table_open_cache = 4096 #所有线程的打开表的数量。
table_definition_cache = 4096 #.frm可以存储在定义高速缓存中 的表定义（来自文件）的数量 。如果使用大量表，则可以创建大型表定义高速缓存以加快表的打开速度。与普通表缓存不同，表定义缓存占用的空间更少，不使用文件描述符。
table_open_cache_instances = 64 #打开表缓存实例的数量（默认为1）。为了通过减少会话之间的争用来提高可伸缩性，可以将开放表缓存划分为几个较小的大小table_open_cache/的 缓存实例 table_open_cache_instances。会话需要仅锁定一个实例以访问DML语句。这会在实例之间对高速缓存进行分段，从而在有许多会话访问表时允许使用高速缓存的操作具有更高的性能。（DDL语句仍然需要锁定整个缓存，但这些语句比DML语句要频繁得多。）对于常规使用16个或更多内核的系统，建议使用值8或16。

# session memory settings #
read_buffer_size = 16M #对于所有存储引擎，此选项也在以下上下文中使用：在为行排序时，用于缓存临时文件（不是临时表）中的索引ORDER BY。用于批量插入分区。用于缓存嵌套查询的结果。
read_rnd_buffer_size = 32M #此变量用于从MyISAM 表中读取，对于任何存储引擎，用于多范围读取优化。将变量设置为较大的值可以大大提高ORDER BY 性能。但是，这是为每个客户端分配的缓冲区，因此不应将全局变量设置为较大的值。而是仅从需要运行大型查询的客户端中更改会话变量。
sort_buffer_size = 32M #必须执行排序的每个会话都会分配此大小的缓冲区。sort_buffer_size 并非特定于任何存储引擎，并且以一般方式应用于优化。至少该 sort_buffer_size值必须足够大，以容纳排序缓冲区中的十五个元组。此外，增加价值 max_sort_length可能需要增加价值 sort_buffer_size。
tmp_table_size = 64M #内部内存临时表的最大大小。此变量不适用于用户创建的 MEMORY表。实际限制是根据tmp_table_size和 max_heap_table_size的较小值确定的 。如果内存中的临时表超出限制，MySQL会自动将其转换为磁盘上的 MyISAM表。如果您执行许多高级 查询并且内存很多tmp_table_size，max_heap_table_size则增加（以及 必要时）的值 GROUP BY。您可以将创建的内部磁盘上临时表的数量与通过比较Created_tmp_disk_tables和 Created_tmp_tables 变量的值创建的内部临时表的总数进行比较 。
join_buffer_size = 128M
thread_cache_size = 64

# log settings #
log_error=error.log #错误日志 默认保存在data目录
log_bin = binlog  #是否启用了二进制日志。如果使用该 --log-bin选项，则该变量的值为ON; 否则就是OFF。
general_log_file = general.log #通用日志文件的名称。默认值为 host_name.log，但可以使用该--general_log_file选项更改初始值 。
slow_query_log = 1  #是否启用慢查询日志。该值可以是0（或 OFF）以禁用日志，或1（或 ON）以启用日志。默认值取决于是否--slow_query_log给出了该选项。日志输出的目标由log_output系统变量控制 ; 如果该值为NONE，则即使启用了日志，也不会写入日志条目。
slow_query_log_file = slow.log #慢查询日志，默认值为 host_name-slow.log，但可以使用该--slow_query_log_file选项更改初始值 。 默认保存在data目录
log_queries_not_using_indexes = 1 #是否将不使用索引的查询记录到慢查询日志中。
log_slow_admin_statements = 1 #在写入慢查询日志的语句中包含慢速管理语句。行政陈述包括ALTER TABLE， ANALYZE TABLE， CHECK TABLE， CREATE INDEX， DROP INDEX， OPTIMIZE TABLE，和 REPAIR TABLE。
log_slow_slave_statements = 1 #启用慢速查询日志时，此变量将启用long_query_time对从服务器上执行时间超过几秒的查询的日志记录 。这个变量是在MySQL 5.6.11中添加的。请注意，即使log_slow_slave_statements已启用，也不会在主服务器的慢速日志中记录主服务器中以行格式记录的所有语句 。
log_throttle_queries_not_using_indexes = 10 #如果 log_queries_not_using_indexes 启用，则 log_throttle_queries_not_using_indexes 变量限制可以写入慢查询日志的每分钟此类查询的数量。值0（默认值）表示“ 无限制 ”。
expire_logs_days = 90 #自动二进制日志文件删除的天数。默认值为0，表示“ 不自动删除。“可能的删除发生在启动时和刷新二进制日志时。发生日志刷新，如第5.4节“MySQL服务器日志”中所示。要手动删除二进制日志文件，请使用该 PURGE BINARY LOGS语句。
long_query_time = 2 #如果查询花费的时间超过此秒数，则服务器会递增Slow_queries 状态变量。如果启用了慢查询日志，则查询将记录到慢查询日志文件中。此值是实时测量的，而不是CPU时间，因此在负载较轻的系统上低于阈值的查询可能会高于严重负载的阈值。最小值和默认值分别long_query_time为0和10。该值可以指定为微秒的分辨率。对于记录到文件，写入包括微秒部分的时间。对于记录到表，只写入整数倍; 微秒部分被忽略。
min_examined_row_limit = 100 #检查少于此行数的查询不会记录到慢查询日志中。
log_bin_trust_function_creators = 1 #启用二进制日志记录时，此变量适用。它控制是否可以信任存储的函数创建者不创建将导致不安全事件写入二进制日志的存储函数。如果设置为0（默认值），用户不允许创建或更改存储功能，除非他们有SUPER 除了特权CREATE ROUTINE或ALTER ROUTINE特权。设置为0还强制执行必须使用DETERMINISTIC特征或使用 READS SQL DATA或声明函数的限制 NO SQL特性。如果变量设置为1，则MySQL不会对存储的函数创建强制实施这些限制。此变量也适用于触发器创建。
log_slave_updates = 1 #从服务器从主服务器接收的更新是否应记录到从属服务器自己的二进制日志中。必须在从站上启用二进制日志记录才能使此变量生效。

# innodb settings #
innodb_page_size = 16384 #InnoDB页面大小（默认为16KB）。许多值都以页数计算; 页面大小使它们可以轻松转换为字节。
innodb_buffer_pool_size = 500M #在一个独立的只使用InnoDB引擎的MySQL服务器中，根据经验，推荐设置innodb-buffer-pool-size为服务器总可用内存的80%。
# 为什么不是90%或者100%呢？
# 因为其它的东西也需要内存：
# * 每个查询至少需要几K的内存(有时候是几M)
# * 有各种其它内部的MySQL结构和缓存
# * InnoDB有一些结构是不用缓冲池的内存的(字典缓存，文件系统，锁系统和页哈希表等)
# * 也有一些MySQL文件是在OS缓存里的(binary日志，relay日志,innodb事务日志等)
# * 此处，你也必须为操作系统留出些内存
innodb_buffer_pool_instances = 16 #InnoDB 缓冲池分区 的区域数。对于具有数千兆字节范围的缓冲池的系统，将缓冲池划分为单独的实例可以通过减少不同线程读取和写入缓存页面时的争用来提高并发性。存储在缓冲池中或从缓冲池读取的每个页面都使用散列函数随机分配给其中一个缓冲池实例。每个缓冲池管理自己的空闲列表， 刷新列表， LRU以及连接到缓冲池的所有其他数据结构，并受其自己的缓冲池互斥锁保护。
innodb_buffer_pool_load_at_startup = 1  #指定在MySQL服务器启动时， 通过加载较早时保存的相同页面来自动预热InnoDB 缓冲池。通常与innodb_buffer_pool_dump_at_shutdown结合使用 。 
innodb_buffer_pool_dump_at_shutdown = 1 #指定在MySQL服务器关闭时是否记录InnoDB 缓冲池中缓存的页面 ，以便在下次重新启动时缩短 预热过程。通常与innodb_buffer_pool_load_at_startup。结合使用 。
innodb_lru_scan_depth = 4096 #影响缓冲池刷新操作 的算法和启发式的参数。主要是性能专家调整I / O密集型工作负载的兴趣。它为每个缓冲池实例指定缓冲池LRU页面列表向下清除页面清理器线程扫描查找要刷新的脏页的距离。这是每秒执行一次的后台操作。 小于默认值的设置通常适用于大多数工作负载。高于必要值的值可能会影响性能。如果在典型工作负载下具有备用I / O容量，则仅考虑增加该值。相反，如果写入密集型工作负载使I / O容量饱和，请减小该值，尤其是在大型缓冲池的情况下。调整时innodb_lru_scan_depth，从较低的值开始并向上配置设置，目标是很少看到零空闲页面。此外，考虑innodb_lru_scan_depth在更改缓冲池实例的数量时进行调整，因为 innodb_lru_scan_depth* innodb_buffer_pool_instances 定义页清除程序线程每秒执行的工作量。
innodb_lock_wait_timeout = 5 #放弃之前InnoDB 事务等待行锁定的时间长度（以秒为单位）。默认值为50秒。尝试访问由另一个InnoDB事务锁定的行的 事务在发出以下错误之前最多等待这一行以便对该行进行写访问：ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction发生锁定等待超时时，将回滚当前语句 （而不是整个事务）。要使整个事务回滚，请使用该--innodb_rollback_on_timeout 选项启动服务器 
innodb_io_capacity = 200 #该innodb_io_capacity 参数设置InnoDB后台任务每秒执行的I / O操作数的上限，例如 从缓冲池刷新页面和合并来自更改缓冲区的数据 。该innodb_io_capacity限制适用于所有缓冲池实例总限额。刷新脏页时，限制在缓冲池实例之间平均分配。innodb_io_capacity应设置为大约系统每秒可执行的I / O操作数。理想情况下，保持设置尽可能低，但不要低到背景活动落后。如果该值太高，则会从缓冲池中删除数据并过快地插入缓冲区以进行缓存以提供显着的好处。默认值为200.对于具有更高I / O速率的繁忙系统，可以设置更高的值以帮助服务器处理与高速行更改相关的后台维护工作。通常，您可以根据InnoDB I / O 使用的驱动器数量增加该值。例如，您可以增加使用多个磁盘或固态磁盘（SSD）的系统的值。对于低端SSD，默认设置200通常就足够了。对于更高端的总线连接SSD，请考虑更高的设置，例如1000。对于具有单独5400 RPM或7200 RPM驱动器的系统，您可以将值降低到100，这表示可执行大约100 IOPS的旧一代磁盘驱动器可用的每秒I / O操作（IOPS）的估计比例。虽然您可以指定一个非常高的值，例如一百万，但实际上这样的大值几乎没有任何好处。通常，建议不要使用20000或更高的值，除非您已经证明较低的值不足以满足您的工作负载。
innodb_io_capacity_max = 400 #如果冲洗活动落后，InnoDB 可以比施加的限制更积极地冲洗 innodb_io_capacity。 在这种情况下innodb_io_capacity_max，InnoDB后台任务定义每秒执行的I / O操作数的上限 。该innodb_io_capacity_max 设置是所有缓冲池实例的总限制。如果innodb_io_capacity在启动时指定 设置但未指定值 innodb_io_capacity_max，则 innodb_io_capacity_max默认值为值的两倍 innodb_io_capacity，最小值为2000。配置时innodb_io_capacity_max，两倍innodb_io_capacity 往往是一个很好的起点。默认值2000适用于使用固态磁盘（SSD）或多个常规磁盘驱动器的工作负载。对于不使用SSD或多个磁盘驱动器的工作负载，2000的设置可能太高，并且可能允许过多的刷新。对于单个常规磁盘驱动器，建议设置介于200和400之间。对于高端，总线连接的SSD，请考虑更高的设置，例如2500.与 innodb_io_capacity设置一样，保持设置尽可能低，但不要太低 ，如果必要，InnoDB不能充分扩展到超出innodb_io_capacity限制。
innodb_flush_method = O_DIRECT #定义用于将 数据刷新到 InnoDB 数据文件和日志文件的方法，这可能会影响I / O吞吐量。如果innodb_flush_method设置为 NULL类Unix系统，则fsync默认使用该 选项。如果 在Windows上innodb_flush_method设置为 NULL，则async_unbuffered默认使用该 选项。innodb_flush_method类Unix系统 的选项包括：
# fsync：InnoDB使用fsync()系统调用来刷新数据和日志文件。fsync是默认设置。
# O_DSYNC：InnoDB用于 O_SYNC打开和刷新日志文件，以及fsync()刷新数据文件。 InnoDB不O_DSYNC直接使用 ，因为在很多种Unix上都存在问题。
# littlesync：此选项用于内部性能测试，目前不受支持。使用风险由您自己承担。
# nosync：此选项用于内部性能测试，目前不受支持。使用风险由您自己承担。
# O_DIRECT：InnoDB 使用O_DIRECT（或 directio()在Solaris上）打开数据文件，并用于fsync()刷新数据和日志文件。某些GNU / Linux版本，FreeBSD和Solaris上提供了此选项。
# O_DIRECT_NO_FSYNC： 在刷新I / O期间InnoDB使用O_DIRECT，但之后跳过 fsync()系统调用。此设置适用于某些类型的文件系统，但不适用于其他类型。例如，它不适合XFS。如果您不确定您使用的文件系统是否需要 fsync()（例如保留所有文件元数据），请O_DIRECT改用。
innodb_undo_logs = 128 #定义InnoDB回滚段的数量。innodb_undo_logs是innodb_rollback_segments的别名。定义 用于生成撤消记录的数据修改事务所使用的回滚段数 InnoDB。每个回滚段最多可支持1023个数据修改事务。如果您观察到与撤消日志相关的互斥争用，则此设置适用于调整性​​能。虽然您可以增加或减少使用的回滚段InnoDB数，但系统中实际存在的回滚段数不会减少。因此，您可以从此参数的低值开始并逐渐增加它，以避免分配不需要的回滚段。的 innodb_rollback_segments 默认值是128，这也是最大值。
#innodb_undo_tablespaces = 3 #回滚段表空间数量。默认值为0。由于在长时间运行的事务期间undo日志会变大，因此在多个表空间中使用撤消日志会减少任何一个表空间的最大大小。撤消表空间文件是在定义的位置创建的 innodb_undo_directory，其名称形式为 ，其中是表示空间ID的一系列整数（包括前导零）。undo表空间文件的默认大小为10MiB。 undoNN重要innodb_undo_tablespaces只能在初始化MySQL实例之前配置，之后不能更改。如果未指定任何值，则使用默认设置0初始化实例。尝试InnoDB使用比MySQL实例初始化时指定的更多数量的撤消表空间重新启动会导致启动失败并显示错误，指出InnoDB未找到预期的撤消表空间的数量。
innodb_flush_neighbors = 0 #指定是否刷从一个页面InnoDB缓冲池也可以清空其他脏页在相同的段。默认值1从缓冲池中刷新相同范围内的连续脏页。设置为0将 innodb_flush_neighbors关闭，并且不会从缓冲池中刷新其他脏页。设置为2会从缓冲池中刷新相同范围内的脏页。当表数据存储在传统 HDD存储设备上时， 与在不同时间刷新各个页面相比，在一次操作中刷新这些邻居页面减少了I / O开销（主要用于磁盘搜索操作）。对于存储在SSD上的表数据 ，查找时间不是一个重要因素，您可以关闭此设置以分散写入操作。
innodb_log_file_size = 1G #在每个字节大小日志文件在日志组。日志文件（innodb_log_file_size* innodb_log_files_in_group）的总大小不能超过略小于512GB的最大值。例如，一对255 GB的日志文件接近限制但不超过它。默认值为48MB。通常，日志文件的总大小应该足够大，以至于服务器可以消除工作负载活动中的高峰和低谷，这通常意味着有足够的重做日志空间来处理超过一小时的写入活动。值越大，缓冲池中需要的检查点刷新活动越少，从而节省磁盘I / O. 较大的日志文件也会使崩溃恢复速度变慢，但MySQL 5.5及更高版本中恢复性能的改进使得日志文件大小不再考虑。
innodb_log_files_in_group = 2 #数日志文件 中日志组。 InnoDB以循环方式写入文件。默认（和推荐）值为2.文件的位置由innodb_log_group_home_dir。指定 。日志文件（innodb_log_file_size* innodb_log_files_in_group）的总大小最大可达512GB。
innodb_log_buffer_size = 64M #InnoDB 用于写入磁盘上日志文件 的缓冲区的大小（以字节为单位）。默认值为8MB。大型 日志缓冲区使大型事务能够运行，而无需在事务提交之前将日志写入磁盘。因此，如果您有更新，插入或删除许多行的事务，则使日志缓冲区更大可以节省磁盘I / O. 
innodb_purge_threads = 4 #InnoDB专用于清除操作的后台线程数 。默认值和最小值1表示清除操作始终由后台线程执行，而不是作为主线程的一部分 。在一个或多个后台线程中运行清除操作有助于减少内部争用 InnoDB，从而提高可伸缩性。将值增加到大于1会创建许多单独的清除线程，这可以提高在多个表上执行DML操作的系统的效率 。最大值为32。
innodb_large_prefix = 1 #启用此选项以允许InnoDB使用DYNAMIC 或 COMPRESSED 行格式的表的 索引键前缀长度超过767字节（最多3072字节）。（创建此类表也需要选项值 innodb_file_format=barracuda 和 innodb_file_per_table=true。）有关与各种设置下的索引键前缀关联的最大值，
innodb_thread_concurrency = 64 #InnoDB尝试将操作系统线程的数量同时保持在 InnoDB小于或等于此变量给定的限制（InnoDB使用操作系统线程来处理用户事务）。一旦线程数达到此限制，额外的线程被置于等待状态一内“ 先入先出 ” （FIFO）队列以供执行。等待锁的线程不计入并发执行线程的数量。此变量的范围是0到1000.值0（默认值）被解释为无限并发（无并发检查）。禁用线程并发检查可以InnoDB根据需要创建任意数量的线程。值0也禁用queries inside InnoDB和queries in queue counters在ROW OPERATIONS 第SHOW ENGINE INNODB STATUS 输出。如果您的MySQL实例与其他应用程序共享CPU资源，或者您的工作负载或并发用户数正在增长，请考虑设置此变量。正确的设置取决于工作负载，计算环境以及您运行的MySQL版本。您需要测试一系列值以确定提供最佳性能的设置。innodb_thread_concurrency是一个动态变量，它允许您在实时测试系统上试验不同的设置。如果特定设置表现不佳，您可以快速设置 innodb_thread_concurrency回0。使用以下准则来帮助查找和维护适当的设置：如果工作负载的并发用户线程数小于64，请进行设置 innodb_thread_concurrency=0。如果您的工作负载一直很大或偶尔会出现峰值，请先设置 innodb_thread_concurrency=128然后将值降低到96,80,64等，直到找到提供最佳性能的线程数。例如，假设您的系统通常有40到50个用户，但是这个数字会定期增加到60,70甚至200.您会发现80个并发用户的性能稳定但开始显示高于此数字的回归。在这种情况下，您将设置 innodb_thread_concurrency=80为避免影响性能。如果您不希望InnoDB为用户线程使用超过一定数量的虚拟CPU（例如，20个虚拟CPU），请设置 innodb_thread_concurrency为此数字（或者可能更低，具体取决于性能结果）。如果您的目标是将MySQL与其他应用程序隔离，则可以考虑将该mysqld进程专门绑定 到虚拟CPU。但请注意，如果mysqld进程不是一直很忙，那么独占绑定可能会导致非最佳硬件使用 。在这种情况下，您可以绑定 mysqld 处理虚拟CPU但也允许其他应用程序使用部分或全部虚拟CPU。
innodb_print_all_deadlocks = 1 #当启用该选项，所有信息 死锁在 InnoDB用户交易被记录在 mysqld 错误日志。否则，您将使用该SHOW ENGINE INNODB STATUS命令查看有关上次死锁的信息。偶尔的 InnoDB死锁不一定是个问题，因为InnoDB立即检测到条件并自动回滚其中一个事务。如果应用程序没有适当的错误处理逻辑来检测回滚并重试其操作，则可以使用此选项来解决发生死锁的原因。大量死锁可能表明需要重构为多个表发出 DML或SELECT ... FOR UPDATE语句的事务，以便每个事务以相同的顺序访问表，从而避免死锁条件。
innodb_strict_mode = 1 #当innodb_strict_mode启用时， InnoDB将返回错误，而不是警告了一定的条件。严格模式有助于防止SQL中忽略的拼写错误和语法错误，或操作模式和SQL语句的各种组合的其他意外后果。当 innodb_strict_mode启用时， InnoDB提出了在某些情况下错误条件，而不是发出警告和处理指定的声明（也许无意的行为）。这类似于 sql_modeMySQL，它控制MySQL接受的SQL语法，并确定它是否默默地忽略错误，或验证输入语法和数据值。
innodb_sort_buffer_size = 128M #指定在创建InnoDB索引期间用于对数据进行排序的排序缓冲区的大小。指定的大小定义读入内存以进行内部排序然后写入磁盘的数据量。该过程称为“ 运行 ”。在合并阶段，读入并合并指定大小的缓冲区对。设置越大，运行和合并的次数就越少。此排序区域仅在索引创建期间用于合并排序，而不是在以后的索引维护操作期间。索引创建完成后，将释放缓冲区。
innodb_write_io_threads = 16 #用于写入操作的I / O线程数 InnoDB。默认值为4.
innodb_read_io_threads = 16 #用于读取操作的I / O线程数 InnoDB。
innodb_file_per_table = 1 #当innodb_file_per_table启用（默认），InnoDB存储数据和索引在一个单独的每个新创建的表 .ibd 文件，而不是系统表空间。删除或截断表时，将回收这些表的存储。此设置启用 InnoDB表压缩等功能 。
innodb_stats_persistent_sample_pages = 64 #估计索引列的基数和其他 统计信息时要采样 的索引页数，例如计算的列 。增加该值会提高索引统计信息的准确性，从而可以提高查询执行计划的执行过程中，在增加的I / O的费用 为表。
innodb_autoinc_lock_mode = 2 #用于生成 自动增量值的锁定模式。对于传统，连续或交错，允许值分别为0,1或2。默认设置为1（连续）。 当innodb_autoinc_lock_mode设置为2时，所有insert种类的SQL都可以立马获得锁并释放，这时的效率最高。但是会引入一个新的问题：当binlog_format为statement时，这时的复制没法保证安全，因为批量的insert，比如insert ..select..语句在这个情况下，也可以立马获取到一大批的自增id值，不必锁整个表，slave在回放这个sql时必然会产生错乱。我们做个测试验证复制不是安全的。
innodb_online_alter_log_max_size=1G #指定在表的联机DDL操作期间使用的临时日志文件大小的上限（以字节为单位）InnoDB。每个正在创建的索引或要更改的表都有一个这样的日志文件。此日志文件存储在DDL操作期间在表中插入，更新或删除的数据。临时日志文件在需要时扩展为值 innodb_sort_buffer_size，最大为指定的最大值 innodb_online_alter_log_max_size。如果临时日志文件超过了大小上限，则 ALTER TABLE操作失败，并回滚所有未提交的并发DML操作。因此，此选项的较大值允许在联机DDL操作期间发生更多DML，但在表被锁定以应用日志中的数据时，还会延长DDL操作结束时的时间段。
innodb_open_files=4096 #仅当您使用多个InnoDB 表空间时，此配置选项才有意义 。它指定MySQL一次可以保持打开的最大.ibd 文件数 。最小值为10.从MySQL 5.6.6开始，如果innodb_file_per_table未启用，则默认值为300;如果不启用， 则默认值为300 table_open_cache。在5.6.6之前，默认值为300。用于文件的文件描述符仅.ibd用于InnoDB表。它们独立于--open-files-limit服务器选项指定的那些 ，并且不影响表缓存的操作。

# replication settings #
master_info_repository = TABLE #该文件保存slave连接master的状态以及配置信息，如用户名，密码，日志执行的位置等。在5.6版本之前，都是使用master.info文件，从5.6开始，通过在my.cnf  中配置 --master-info-repository=TABLE。这些信息会被写入mysql.slave_master_info 表中，代替原来的master.info文件了。
relay_log_info_repository = TABLE #该文件保存slave上relay log的执行位置。在5.6版本之前，都是使用relay-log.info文件，从5.6开始，通过在my.cnf中配置 --relay-log-info-repository=TABLE，使用mysql.slave_relay_log_info表代替原来的文件。每次当slave上执行start slave时，就会读取该表中的位置信息。
sync_binlog = 1 #sync_binlog参数来控制数据库的binlog刷到磁盘上去。最安全的就是sync_binlog=1了，表示每次事务提交，MySQL都会把binlog刷下去，是最安全但是性能损耗最大的设置。
gtid_mode = on #开启GTID复制
enforce_gtid_consistency = 1 #保证GTID安全的参数
log_slave_updates  #relay-log里的日志内容再记录到slave本地的binlog里
binlog_format = ROW #此变量设置二进制日志格式，并且可以是任何一个STATEMENT，ROW或MIXED。
binlog_rows_query_log_events = 1 #可以在binlog_format=row中记录执行的具体SQL语句。
relay_log = relay.log #开启中继日志
relay_log_recovery = 1 #当slave从库宕机后，假如relay-log损坏了，导致一部分中继日志没有处理，则自动放弃所有未执行的relay-log，并且重新从master上获取日志，这样就保证了relay-log的完整性。默认情况下该功能是关闭的，将relay_log_recovery的值设置为1时，可在slave从库上开启该功能，建议开启。
slave_skip_errors = ddl_exist_errors #复制经常会遇到错误而导致slave端复制中断，这个时候一般就需要人工干预，跳过错误才能继续 ddl_exist_errors值却比较特别，它代表了一组errorCode的组合，分别是：
# 1007：数据库已存在，创建数据库失败
# 1008：数据库不存在，删除数据库失败
# 1050：数据表已存在，创建数据表失败
# 1050：数据表不存在，删除数据表失败
# 1054：字段不存在，或程序文件跟数据库有冲突
# 1060：字段重复，导致无法插入
# 1061：重复键名
# 1068：定义了多个主键
# 1094：位置线程ID
# 1146：数据表缺失，请恢复数据库
slave_rows_search_algorithms = &amp;apos;INDEX_SCAN,HASH_SCAN&amp;apos; #部分解决无主键表导致的复制延迟问题，其基本思路是对于在一个ROWS EVENT中的所有前镜像收集起来，然后在一次扫描全表时，判断HASH中的每一条记录进行更新。
skip_slave_start=0 #auto_start_slave
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;最近两天整理的参数文件详细说明，常用的参数都涉及到了，主要适用于MySQL 5.6，参考姜承尧老师的mysql_best_configuration，时间匆忙，后续发现错误会及时更正。&lt;br&gt;&lt;a href=&quot;https://github.com/jdaaaaaa
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="性能" scheme="http://idber.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>【译】MySQL 5.7中InnoDB事务隔离模式的影响</title>
    <link href="http://idber.github.io/2018/08/18-MySQL%205.7%E4%B8%ADInnoDB%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BD%B1%E5%93%8D.html"/>
    <id>http://idber.github.io/2018/08/18-MySQL 5.7中InnoDB事务隔离模式的影响.html</id>
    <published>2018-08-17T22:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.928Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;http://dimitrik.free.fr/blog/archives/2015/02/mysql-performance-impact-of-innodb-transaction-isolation-modes-in-mysql-57.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;via&lt;/a&gt;&lt;br&gt;过去几年，其他人已经写了很多有价值的文章，解释了InnoDB事务隔离级别的所有细节以及如何解决这个问题。因此，我将避免重复已经说过的内容; 我的注意力吸引了PeterZ的性能研究并发表在以下文章中：&lt;a href=&quot;https://www.percona.com/blog/2015/01/14/mysql-performance-implications-of-innodb-isolation-modes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.percona.com/blog/2015/01/14/mysql-performance-implications-of-innodb-isolation-modes/&lt;/a&gt; 这篇文章非常好，可以很好地分析观察问题所在，可以通过修改隔离级别为READ-COMMITTED替代REPEATABLE-READ（InnoDB默认级别）来解决。那么问题来了：为什么我们没有默认的READ-COMMITTED模式？有什么危险吗？&lt;/p&gt;
&lt;p&gt;让我们一起探讨&lt;/p&gt;
&lt;p&gt;首先，你应该记住你的理论，不仅仅是在InnoDB中实现所有这些东西的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB中的事务隔离/ MVCC是通过ReadViews实现的&lt;/li&gt;
&lt;li&gt;每次创建ReadView时，都应该获取互斥锁（trx_sys）&lt;/li&gt;
&lt;li&gt;在REPEATABLE-READ模式下，在事务启动时创建ReadView&lt;/li&gt;
&lt;li&gt;在READ-COMMITTED模式下，在每个语句上创建一个ReadView&lt;/li&gt;
&lt;li&gt;意味着，如果您的陈述很短 - 您可能会在工作负载中遇到trx_sys互斥争用风暴。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，一切都取决于工作量，如果你很幸运，你可能会在这里看到一个好处（一切皆有可能，对吧？ - 至少在理论上）&lt;/p&gt;
&lt;p&gt;现在让我告诉你一些你会觉得自己不那么幸运的情况&lt;/p&gt;
&lt;p&gt;对于我的测试用例，我将使用：&lt;/p&gt;
&lt;p&gt;40cores-HT服务器&lt;br&gt;运行OEL 6.5 2.6.32-504内核&lt;br&gt;极快的闪存（Fusion-io ioMemory）&lt;br&gt;每个工作负载使用64个并发用户&lt;br&gt;每个工作负载执行3个测试用例：&lt;br&gt;配置REPEATABLE-READ模式（RR）&lt;br&gt;READ-COMMITTED模式已配置（RC）&lt;br&gt;已配置READ-UNCOMMITTED模式（RU）&lt;/p&gt;
&lt;p&gt;DBT-2 500W工作负载（TPC-C）：&lt;br&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/01Impact%20of%20InnoDB%20Transaction%20Isolation%20Modes%20in%20MySQL%205.7.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;观察 ：&lt;br&gt;你可能已经观察到，与第一个（RR）相比，第二（RC）和第三（RU）测试案例的TPS略低一些&lt;br&gt;“回归”不是很大，但值得注意&lt;br&gt;现在让我们来看看InnoDB中的内部锁定争用。&lt;br&gt;锁定争议：&lt;br&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/02Impact%20of%20InnoDB%20Transaction%20Isolation%20Modes%20in%20MySQL%205.7.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;观察 ：&lt;br&gt;对于RC和RU测试，trx_sys互斥锁的跳跃争用非常明显&lt;br&gt;然而，它还不是太大，不会造成严重的损害..&lt;/p&gt;
&lt;p&gt;现在，让我们转移到一个沉重的Sysbench OLTP_RW - 我在这里通过在我的测试中添加读/写比率稍微改变了“经典”OLTP_RW：&lt;br&gt;最初负载以128：1的比率开始（主要是读取，少写入）&lt;br&gt;那么16：1&lt;br&gt;那么4：1&lt;br&gt;那么2：1&lt;br&gt;最后1：1&lt;/p&gt;
&lt;p&gt;我也在使用这个测试用例来评估写入在事务中的影响等。&lt;/p&gt;
&lt;p&gt;到目前为止：&lt;/p&gt;
&lt;p&gt;Sysbench OLTP_RW 32x10M-tables，rw128 / 16/4/2/1：&lt;br&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/03Impact%20of%20InnoDB%20Transaction%20Isolation%20Modes%20in%20MySQL%205.7.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;观察 ：&lt;br&gt;这里的影响更多只是值得注意的;-)&lt;br&gt;这只是因为trx_sys互斥争用？或者是其他东西？..&lt;br&gt;锁定争议：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/04Impact%20of%20InnoDB%20Transaction%20Isolation%20Modes%20in%20MySQL%205.7.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;观察 ：&lt;br&gt;哦，确实，trx_sys现在跳得太高了！&lt;br&gt;它会更糟糕吗？&lt;/p&gt;
&lt;p&gt;让我们看看;-) &lt;/p&gt;
&lt;p&gt;下一个工作负载的代码名称是“OLTP_RW-p_sel10” - 这个测试中的所有读取都被10个点选择所取代，这就是全部，使得写入时的负载更加激进，读取时更快和更快：&lt;/p&gt;
&lt;p&gt;Sysbench OLTP_RW-p_sel10 32x10M表，rw128 / 16/4/2/1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/05Impact%20of%20InnoDB%20Transaction%20Isolation%20Modes%20in%20MySQL%205.7.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;观察 ：&lt;br&gt;事实上，看到x2时间更糟糕的表现真的是杀人..&lt;br&gt;仍然由于trx_sys互斥？&lt;br&gt;锁定争论：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/06Impact%20of%20InnoDB%20Transaction%20Isolation%20Modes%20in%20MySQL%205.7.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;嗯，你可能仍然会说这只是因为这个服务器太大了，这就是我观察所有这些争论的原因，你将离现实不远 - 在较小的机器上所有这些争论当然都会降​​低 - 但是！仍然“值得注意”;-)）&lt;/p&gt;
&lt;p&gt;相同的OLTP_RW-p_sel10，但在20cores-HT上:(&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/07Impact%20of%20InnoDB%20Transaction%20Isolation%20Modes%20in%20MySQL%205.7.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;虽然今天许多x2 CPU Intel机器总共拥有超过32个-cx-HT，所以“小”HW变得很大; - ））&lt;/p&gt;
&lt;p&gt;总结：&lt;br&gt;那么，我们最终应该从所有这些东西中得出结论?&lt;br&gt;PeterZ告诉我们一个如此美好的故事，现在你带着你的实验来表明PeterZ错了……&lt;br&gt;伙计们，PeterZ没错！&lt;br&gt;?? - 所以，你在撒谎??????&lt;br&gt;而且我也不是在撒谎;-)）&lt;br&gt;??? …..&lt;br&gt;那么，你应该记住的是，没有“银弹”，大多数情况下最普遍的答案将是“它取决于” ;&lt;br&gt;与InnoDB交易隔离在这里是一样的故事！&lt;br&gt;一般规则如下：&lt;br&gt;如果您的查询和事务很短：请使用默认的REPEATABLE-READ模式！&lt;br&gt;如果您的查询很长并且读取了很多可能被其他事务并行修改的数据：那么使用READ-COMMITTED模式 - 这将允许您在查询进行时读取已提交的更改并避免丢失而不是扫描旧页面图像（正如PeterZ在他的故事中向你展示的那样;-)）&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;http://dimitrik.free.fr/blog/archives/2015/02/mysql-performance-impact-of-innodb-transaction-isolation-modes-in-mysql-57.ht
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="性能" scheme="http://idber.github.io/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 5.7新特性系列一</title>
    <link href="http://idber.github.io/2018/08/17-MySQL%205.7%E6%96%B0%E7%89%B9%E6%80%A7%E7%B3%BB%E5%88%97%E4%B8%80.html"/>
    <id>http://idber.github.io/2018/08/17-MySQL 5.7新特性系列一.html</id>
    <published>2018-08-16T22:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.929Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h1&gt;&lt;p&gt;MySQL 5.7在2015-10-21发布了GA版本，即5.7.9，目前小版本已经到了5.7.23。5.7新增了许多新的feature和优化，接下来一个系列，我们就一起来尝尝鲜。首先这次主要是预览feature的变化以及兼容性问题。后面的系列，会针对重要的feature展开来学习。&lt;/p&gt;
&lt;h1 id=&quot;2-安全相关的特性&quot;&gt;&lt;a href=&quot;#2-安全相关的特性&quot; class=&quot;headerlink&quot; title=&quot;2 安全相关的特性&quot;&gt;&lt;/a&gt;2 安全相关的特性&lt;/h1&gt;&lt;h2 id=&quot;2-1-认证插件&quot;&gt;&lt;a href=&quot;#2-1-认证插件&quot; class=&quot;headerlink&quot; title=&quot;2.1 认证插件&quot;&gt;&lt;/a&gt;2.1 认证插件&lt;/h2&gt;&lt;p&gt;mysql.user表中的plugin更改成not null，5.7开始不再支持mysql_old_password的认证插件，推荐全部使用mysql_native_password。从低版本升级到5.7的时候，需要处理两个兼容性问题。&lt;/p&gt;
&lt;p&gt;[兼容性] 需要先迁移mysql_old_password的用户，然后进行user表结构的升级：&lt;/p&gt;
&lt;h3 id=&quot;1-迁移mysql-old-password用户&quot;&gt;&lt;a href=&quot;#1-迁移mysql-old-password用户&quot; class=&quot;headerlink&quot; title=&quot;1. 迁移mysql_old_password用户&quot;&gt;&lt;/a&gt;1. 迁移mysql_old_password用户&lt;/h3&gt;&lt;p&gt; MySQL 5.7.2之前的版本，是根据password的hash value来判断使用的认证插件类型，5.7.2以后的版本，plugin字段为not null，就直接根据plugin来判断了。新的密码从password字段中，保存到新的字段authentication_string中，password字段废弃处理。&lt;/p&gt;
&lt;p&gt;如果user是隐式的mysql_native_password。直接使用sql进行变更：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UPDATE mysql.user SET plugin = &amp;apos;mysql_native_password&amp;apos; WHERE plugin = &amp;apos;&amp;apos; AND (Password = &amp;apos;&amp;apos; OR LENGTH(Password) = 41);
FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果user是隐式的或者显示的mysql_old_password， 首先通过以下sql进行查询：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT User, Host, Password FROM mysql.user WHERE (plugin = &amp;apos;&amp;apos; AND LENGTH(Password) = 16) OR plugin = &amp;apos;mysql_old_password&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果存在记录，就表示还有使用mysql_old_password的user，使用以下sql进行用户的迁移：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER USER &amp;apos;user1&amp;apos;@&amp;apos;localhost&amp;apos; IDENTIFIED WITH mysql_native_password BY &amp;apos;DBA-chosen-password&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-user表结构升级&quot;&gt;&lt;a href=&quot;#2-user表结构升级&quot; class=&quot;headerlink&quot; title=&quot;2. user表结构升级&quot;&gt;&lt;/a&gt;2. user表结构升级&lt;/h3&gt;&lt;p&gt;通过mysql_upgrade直接进行升级，步骤如下[5.6-&amp;gt;5.7]：&lt;/p&gt;
&lt;p&gt;stop MySQL 5.6实例&lt;br&gt;替换5.7的mysqld二进制版本&lt;br&gt;使用5.7启动实例&lt;br&gt;run mysql_upgrade升级系统表&lt;br&gt;重启MySQL 5.7实例&lt;/p&gt;
&lt;h2 id=&quot;2-2-密码过期&quot;&gt;&lt;a href=&quot;#2-2-密码过期&quot; class=&quot;headerlink&quot; title=&quot;2.2 密码过期&quot;&gt;&lt;/a&gt;2.2 密码过期&lt;/h2&gt;&lt;p&gt;用户可以通过 ALTER USER ‘test‘@’localhost’ PASSWORD EXPIRE;这样的语句来使用户的密码过期。 并新增加 default_password_lifetime来表示用户密码自动过期时间，从5.7.10开始，其默认值从0变更到了360，也就是默认一年过期。 可以通过以下两种方法禁止过期：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. SET GLOBAL default_password_lifetime = 0;
2. ALTER USER &amp;apos;test&amp;apos;@&amp;apos;localhost&amp;apos; PASSWORD EXPIRE NEVER;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[兼容性] 只需要通过mysql_upgrade升级mysql.user系统表就可以使用密码过期新功能。&lt;/p&gt;
&lt;h2 id=&quot;2-3-账号锁定&quot;&gt;&lt;a href=&quot;#2-3-账号锁定&quot; class=&quot;headerlink&quot; title=&quot;2.3 账号锁定&quot;&gt;&lt;/a&gt;2.3 账号锁定&lt;/h2&gt;&lt;p&gt;用户可以通过以下语法进行账号锁定，阻止这个用户进行登录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER USER &amp;apos;test&amp;apos;@&amp;apos;localhost&amp;apos; ACCOUNT LOCK;
ALTER USER &amp;apos;test&amp;apos;@&amp;apos;localhost&amp;apos; ACCOUNT UNLOCK;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[兼容性] 只需要通过mysql_upgrade升级mysql.user系统表就可以使用密码过期新功能。&lt;/p&gt;
&lt;h2 id=&quot;2-4-SSL连接&quot;&gt;&lt;a href=&quot;#2-4-SSL连接&quot; class=&quot;headerlink&quot; title=&quot;2.4 SSL连接&quot;&gt;&lt;/a&gt;2.4 SSL连接&lt;/h2&gt;&lt;p&gt;如果mysqld编译使用的openssl，在启动的时候，默认创建SSL， RSA certificate 和 key 文件。 但不管是openssl还是yassl，如果没有设置ssl相关的参数，mysqld都会在data directory里查找ssl认证文件，来尽量打开ssl特性。&lt;/p&gt;
&lt;p&gt;[兼容性] 不存在兼容性的问题&lt;/p&gt;
&lt;h2 id=&quot;2-5-安装数据库&quot;&gt;&lt;a href=&quot;#2-5-安装数据库&quot; class=&quot;headerlink&quot; title=&quot;2.5 安装数据库&quot;&gt;&lt;/a&gt;2.5 安装数据库&lt;/h2&gt;&lt;p&gt;5.7开始建议用户使用 mysqld –initialize来初始化数据库，放弃之前的mysql_install_db的方式，新的方式只创建了一个root@localhost的用户，随机密码保存在~/.mysql_secret文件中，并且账号是expired，第一次使用必须reset password，并且不再创建test db。&lt;/p&gt;
&lt;p&gt;[兼容性] 不存在兼容性的问题&lt;/p&gt;
&lt;h1 id=&quot;3-sql-mode变更&quot;&gt;&lt;a href=&quot;#3-sql-mode变更&quot; class=&quot;headerlink&quot; title=&quot;3 sql mode变更&quot;&gt;&lt;/a&gt;3 sql mode变更&lt;/h1&gt;&lt;p&gt;5.7 sql_mode的默认值变更为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mode_no_engine_substitution |
mode_only_full_group_by |
mode_strict_trans_tables |
mode_no_zero_in_date |
mode_no_zero_date |
mode_error_for_division_by_zero |
mode_no_auto_create_user
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而在5.7之前，sql_mode的默认值都只有mode_no_engine_substitution。 所以在5.7默认的情况下，比如grant不存在的用户的时候，会报一下错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ERROR 1133 (42000): Can&amp;apos;t find any matching row in the user table
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;必须先使用create user，然后再使用grant user。&lt;/p&gt;
&lt;p&gt;[兼容性] 默认sql mode发生变更会导致sql的行为不一致。&lt;/p&gt;
&lt;h1 id=&quot;4-online-alter-table&quot;&gt;&lt;a href=&quot;#4-online-alter-table&quot; class=&quot;headerlink&quot; title=&quot;4. online alter table&quot;&gt;&lt;/a&gt;4. online alter table&lt;/h1&gt;&lt;p&gt;支持online rename index操作， in_place并且不需要table copy。 [兼容性] 不存在兼容性的问题&lt;/p&gt;
&lt;h1 id=&quot;5-InnoDB增强&quot;&gt;&lt;a href=&quot;#5-InnoDB增强&quot; class=&quot;headerlink&quot; title=&quot;5. InnoDB增强&quot;&gt;&lt;/a&gt;5. InnoDB增强&lt;/h1&gt;&lt;h3 id=&quot;5-1-varchar长度变更支持inplace&quot;&gt;&lt;a href=&quot;#5-1-varchar长度变更支持inplace&quot; class=&quot;headerlink&quot; title=&quot;5.1 varchar长度变更支持inplace&quot;&gt;&lt;/a&gt;5.1 varchar长度变更支持inplace&lt;/h3&gt;&lt;p&gt;变更varchar 类型字段的长度支持inplace方法，但有一个限制，即用于表示varchar字段长度的字节数不能发生变化，也就是支持比如varchar的长度在255以下变更或者255以上的范围进行变更，因为从小于255变更到大于255，其size的字节需要从1个增加到2个。&lt;/p&gt;
&lt;p&gt;注意：减少varchar的长度，仍然需要table copy。&lt;/p&gt;
&lt;h3 id=&quot;5-2-优化InnoDB临时表&quot;&gt;&lt;a href=&quot;#5-2-优化InnoDB临时表&quot; class=&quot;headerlink&quot; title=&quot;5.2 优化InnoDB临时表&quot;&gt;&lt;/a&gt;5.2 优化InnoDB临时表&lt;/h3&gt;&lt;p&gt;因为InnoDB临时表的数据不再不受redo保护，而redo只保护临时表的元数据，所以大幅提升了临时表的性能。 并且InnoDB临时表的元数据保存在一个新的系统表中即innodb_temp_table_info， 临时表将建立一个统一的表空间，我们称之为临时表空间，其目录地址可以通过参数innodb_temp_data_file_path来设置。系统在启动的时候，都会新建这个表空间，重启会删除重建。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show global variables like &amp;apos;%temp_data_file_path%&amp;apos;;
+----------------------------+-----------------------+
| Variable_name              | Value                 |
+----------------------------+-----------------------+
| innodb_temp_data_file_path | ibtmp1:12M:autoextend |
+----------------------------+-----------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并且5.7存储引擎默认都变更成InnoDB了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; show global variables like &amp;apos;%storage_engine%&amp;apos;;
+----------------------------------+--------+
| Variable_name                    | Value  |
+----------------------------------+--------+
| default_storage_engine           | InnoDB |
| default_tmp_storage_engine       | InnoDB |
| disabled_storage_engines         |        |
| internal_tmp_disk_storage_engine | InnoDB |
+----------------------------------+--------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意： 在开启gtid的情况下，非auto commit或者显示begin的context下，create 或者drop 临时表，仍然和5.6一样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ERROR 1787 (HY000): Statement violates GTID consistency: CREATE TEMPORARY TABLE and DROP TEMPORARY TABLE can only be executed outside transactional context.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外， insert into t select * from t也会遇到错误，不能在一个sql语句中reference两次临时表。&lt;/p&gt;
&lt;p&gt;备注： 因为InnoDB临时表进行了比较大的变动，我们会专门进行一次详细的介绍。&lt;/p&gt;
&lt;h3 id=&quot;5-3-InnoDB原生支持DATA-GEOMETRY类型&quot;&gt;&lt;a href=&quot;#5-3-InnoDB原生支持DATA-GEOMETRY类型&quot; class=&quot;headerlink&quot; title=&quot;5.3 InnoDB原生支持DATA_GEOMETRY类型&quot;&gt;&lt;/a&gt;5.3 InnoDB原生支持DATA_GEOMETRY类型&lt;/h3&gt;&lt;p&gt;并且支持在spatial data types上建立index，加速查询。&lt;/p&gt;
&lt;h3 id=&quot;5-4-buffer-pool-dump&quot;&gt;&lt;a href=&quot;#5-4-buffer-pool-dump&quot; class=&quot;headerlink&quot; title=&quot;5.4 buffer pool dump&quot;&gt;&lt;/a&gt;5.4 buffer pool dump&lt;/h3&gt;&lt;p&gt;buffer pool dump和load支持一个新的参数innodb_buffer_pool_dump_pct，即dump的比例，并且使用innodb_io_capacity 来控制load过程中的IO吞吐量。&lt;/p&gt;
&lt;h3 id=&quot;5-5-多线程flush-dirty&quot;&gt;&lt;a href=&quot;#5-5-多线程flush-dirty&quot; class=&quot;headerlink&quot; title=&quot;5.5 多线程flush dirty&quot;&gt;&lt;/a&gt;5.5 多线程flush dirty&lt;/h3&gt;&lt;p&gt;从5.7.4开始，innodb_page_cleaners参数可以设置，支持多线程flush dirty page，加快脏块的刷新。&lt;/p&gt;
&lt;h3 id=&quot;5-6-NVM-file-system&quot;&gt;&lt;a href=&quot;#5-6-NVM-file-system&quot; class=&quot;headerlink&quot; title=&quot;5.6 NVM file system&quot;&gt;&lt;/a&gt;5.6 NVM file system&lt;/h3&gt;&lt;p&gt;MySQL 一直使用double write buffer来解决一个page写入的partial write问题，但在linux系统上的Fusion-io Non-Volatile Memory (NVM) file system支持原子的写入。 这样就可以省略掉double write buffer的使用， 5.7.4以后，如果Fusion-io devices支持atomic write，那么MySQL自动把dirty block直接写入到数据文件了。这样减少了一次内存copy和IO操作。&lt;/p&gt;
&lt;h3 id=&quot;5-7-InnoDB分区表&quot;&gt;&lt;a href=&quot;#5-7-InnoDB分区表&quot; class=&quot;headerlink&quot; title=&quot;5.7 InnoDB分区表&quot;&gt;&lt;/a&gt;5.7 InnoDB分区表&lt;/h3&gt;&lt;p&gt;MySQL 5.7之前的版本，InnoDB并不支持分区表，分区表的支持是在ha_partition引擎上支持的，从5.7开始，InnoDB支持原生的分区表，并且可以使用传输表空间。&lt;/p&gt;
&lt;p&gt;[兼容性] mysql_upgrade会扫描ha_partition引擎支持的InnoDB表，并升级成InnoDB分区表，5.7.9之后，可以通过命令ALTER TABLE … UPGRADE PARTITIONING.进行升级。如果之前的版本大量使用了分区表，要注意使用mysql_upgrade会消耗非常长的时间来升级分区表。&lt;/p&gt;
&lt;h3 id=&quot;5-8-动态调整buffer-pool-size&quot;&gt;&lt;a href=&quot;#5-8-动态调整buffer-pool-size&quot; class=&quot;headerlink&quot; title=&quot;5.8 动态调整buffer pool size&quot;&gt;&lt;/a&gt;5.8 动态调整buffer pool size&lt;/h3&gt;&lt;p&gt;MySQL 5.7.5之后，可以online动态调整buffer pool size，通过设置动态的参数innodb_buffer_pool_size来调整，并且根据Innodb_buffer_pool_resize_status状态来查看resize的进度，因为resize的过程是以chunk为大小，把pages从一个内存区域copy到另一片内存的。&lt;/p&gt;
&lt;h3 id=&quot;5-9-加快recovery&quot;&gt;&lt;a href=&quot;#5-9-加快recovery&quot; class=&quot;headerlink&quot; title=&quot;5.9 加快recovery&quot;&gt;&lt;/a&gt;5.9 加快recovery&lt;/h3&gt;&lt;p&gt;MySQL 5.7.5之前，在recovery的过程中，需要扫描所有的ibd文件，获取元信息， 5.7.5之后，新加了一种redo log类型，即MLOG_FILE_NAME， 记录从上一次checkpoint以来，发生过变更的文件，这样在recovery的过程中，只需要打开这些文件就可以了。 [兼容性] 因为增加了新的log record type，需要安全的关闭5.7之前的实例，清理掉redo。&lt;/p&gt;
&lt;h3 id=&quot;5-10-表空间管理&quot;&gt;&lt;a href=&quot;#5-10-表空间管理&quot; class=&quot;headerlink&quot; title=&quot;5.10 表空间管理&quot;&gt;&lt;/a&gt;5.10 表空间管理&lt;/h3&gt;&lt;p&gt;支持创建表空间，例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE TABLESPACE `tablespace_name`
ADD DATAFILE &amp;apos;file_name.ibd&amp;apos;
[FILE_BLOCK_SIZE = n]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并可以在创建表的时候，指定属于哪个表空间，&lt;/p&gt;
&lt;p&gt;[兼容性] 因为可以任意指定空间目录，要注意升级过程中，不要漏掉目录。&lt;/p&gt;
&lt;h3 id=&quot;5-11-InnoDB-Tablespace-Encryption&quot;&gt;&lt;a href=&quot;#5-11-InnoDB-Tablespace-Encryption&quot; class=&quot;headerlink&quot; title=&quot;5.11 InnoDB Tablespace Encryption&quot;&gt;&lt;/a&gt;5.11 InnoDB Tablespace Encryption&lt;/h3&gt;&lt;p&gt;支持InnoDB数据文件加密，其依赖keyring plugin来进行秘钥的管理，后面我们单独来介绍InnoDB加密的方法，并且RDS也实现了一种InnoDB数据文件透明加密方法，并通过KMS系统来管理秘钥。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table t(id int) encryption=&amp;apos;y&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;未完待续&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h1&gt;&lt;p&gt;MySQL 5.7在2015-10-21发布了GA版本，即5.7.9，目前小版本已经到了5.7.23。5.7新
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="新特性" scheme="http://idber.github.io/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>RC or RR</title>
    <link href="http://idber.github.io/2018/08/16-RC%20or%20RR.html"/>
    <id>http://idber.github.io/2018/08/16-RC or RR.html</id>
    <published>2018-08-16T02:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.933Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;数据库事务隔离级别分为四种（级别递减）：&lt;/p&gt;
&lt;p&gt;1、Serializable （串行化）：最严格的级别，事务串行执行，资源消耗最大；&lt;/p&gt;
&lt;p&gt;2、REPEATABLE READ（重复读） ：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了“脏读取”和“不可重复读取”的情况，但不能避免“幻读”(MySQL通过Next-Key lock算法解决了幻读问题)，但是带来了更多的性能损失。&lt;/p&gt;
&lt;p&gt;3、READ COMMITTED （提交读）：大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了“脏读取”，但不能避免“幻读”和“不可重复读取”。该级别适用于大多数系统。&lt;/p&gt;
&lt;p&gt;4、Read Uncommitted（未提交读） ：事务中的修改，即使没有提交，其他事务也可以看得到，会导致“脏读”、“幻读”和“不可重复读取”。&lt;/p&gt;
&lt;p&gt;脏读、不可重复读、幻读：&lt;/p&gt;
&lt;p&gt;也许有很多读者会对上述隔离级别中提及到的 脏读、不可重复读、幻读 的理解有点吃力，我在这里尝试使用通俗的方式来解释这三种语义：&lt;/p&gt;
&lt;p&gt;脏读：所谓的脏读，其实就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。&lt;/p&gt;
&lt;p&gt;也就是说，当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。&lt;/p&gt;
&lt;p&gt;不可重复读：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。&lt;/p&gt;
&lt;p&gt;也就是说，当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。&lt;/p&gt;
&lt;p&gt;幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。&lt;/p&gt;
&lt;p&gt;也就是说，当前事务读第一次取到的数据比后来读取到数据条目少。&lt;/p&gt;
&lt;p&gt;不可重复读和幻读比较：&lt;/p&gt;
&lt;p&gt;两者有些相似，但是前者针对的是update或delete，后者针对的insert。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、隔离级别&quot;&gt;&lt;a href=&quot;#一、隔离级别&quot; class=&quot;headerlink&quot; title=&quot;一、隔离级别&quot;&gt;&lt;/a&gt;一、隔离级别&lt;/h1&gt;&lt;p&gt;事务的隔离级别有4种: SQL-1992 ，但是我只想介绍其中两种，因为其他的两个根本就用不上&lt;/p&gt;
&lt;h4 id=&quot;1-1-什么叫一致性锁定读-和-一致性非锁定读&quot;&gt;&lt;a href=&quot;#1-1-什么叫一致性锁定读-和-一致性非锁定读&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么叫一致性锁定读 和 一致性非锁定读&quot;&gt;&lt;/a&gt;1.1 什么叫一致性锁定读 和 一致性非锁定读&lt;/h4&gt;&lt;h5 id=&quot;一致性锁定读&quot;&gt;&lt;a href=&quot;#一致性锁定读&quot; class=&quot;headerlink&quot; title=&quot;一致性锁定读&quot;&gt;&lt;/a&gt;一致性锁定读&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;读数据的时候，会去加S-lock、x-lock&lt;/li&gt;
&lt;li&gt;eg：select … for update , select … lock in share mode&lt;/li&gt;
&lt;li&gt;dml语句&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&quot;一致性非锁定读&quot;&gt;&lt;a href=&quot;#一致性非锁定读&quot; class=&quot;headerlink&quot; title=&quot;一致性非锁定读&quot;&gt;&lt;/a&gt;一致性非锁定读&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;读数据的时候，不加任何的锁，快照读（snapshot read）    &lt;/li&gt;
&lt;li&gt;eg: select … 最普通的查询语句&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;1-2-什么是幻读&quot;&gt;&lt;a href=&quot;#1-2-什么是幻读&quot; class=&quot;headerlink&quot; title=&quot;1.2 什么是幻读&quot;&gt;&lt;/a&gt;1.2 什么是幻读&lt;/h4&gt;&lt;p&gt;概念&lt;br&gt;一个事务内的同一条【一致性锁定读】SQL多次执行，读到的结果不一致，我们称之为幻读。&lt;br&gt;实战&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set global tx_isolation=&amp;apos;READ-COMMITTED&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事务一: &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root:test&amp;gt; begin;select * from lc for update;
+------+
| id   |
+------+
|    1 |
|    2 |
+------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事务二：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root:test&amp;gt;begin; insert into lc values(3);
Query OK, 1 row affected (0.00 sec)
root:test&amp;gt; commit ;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事务一：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root:test&amp;gt; select * from lc for update;  
+------+
| id   |
+------+
|    1 |
|    2 |
|    3 |
+------+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;同一个事务一中，同一条select * from lc for update (一致性锁定读) 执行两次，得到的结果不一致，说明产生了幻读&lt;/li&gt;
&lt;li&gt;同一个事务一中，同一条select * from lc  (一致性非锁定读) 执行两次，得到的结果不一致，说明产生了幻读&lt;/li&gt;
&lt;li&gt;我们姑且认为，幻读和不可重复读为一个概念，实际上也差不多一个概念。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;1-3-什么是脏读&quot;&gt;&lt;a href=&quot;#1-3-什么是脏读&quot; class=&quot;headerlink&quot; title=&quot;1.3 什么是脏读&quot;&gt;&lt;/a&gt;1.3 什么是脏读&lt;/h4&gt;&lt;p&gt;这个大家都很多好理解，就是事务一还没有提交的事务，却被事务二读到了，这就是脏读&lt;/p&gt;
&lt;p&gt;repeatable-read（RR）可重复读&lt;br&gt;顾名思义：一个事务内的同一条【一致性锁定读】SQL多次执行，读到的结果一致，我们称之为可重复读。&lt;br&gt;解决了幻读的问题&lt;br&gt;read-committed （RC）读已提交&lt;br&gt;顾名思义: 只要其他事务提交了，我就能读到&lt;br&gt;解决了脏读的问题，没有解决幻读的问题&lt;/p&gt;
&lt;h1 id=&quot;二、隔离级别是如何实现的&quot;&gt;&lt;a href=&quot;#二、隔离级别是如何实现的&quot; class=&quot;headerlink&quot; title=&quot;二、隔离级别是如何实现的&quot;&gt;&lt;/a&gt;二、隔离级别是如何实现的&lt;/h1&gt;&lt;p&gt;就拿上面那个简单的例子来佐证好了&lt;/p&gt;
&lt;p&gt;环境&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dba:lc_4&amp;gt; show create table lc;
+-------+--------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                           |
+-------+--------------------------------------------------------------------------------------------------------+
| lc    | CREATE TABLE `lc` (
  `id` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 |
+-------+--------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
dba:lc_4&amp;gt; select * from lc;
+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
+----+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RR&lt;/p&gt;
&lt;p&gt;RR 如何解决幻读问题？&lt;br&gt;RR 的锁算法：next-key lock&lt;/p&gt;
&lt;p&gt;解决幻读的案例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dba:lc_4&amp;gt; set tx_isolation=&amp;apos;repeatable-read&amp;apos;;
Query OK, 0 rows affected (0.00 sec)
dba:lc_4&amp;gt; select * from lc for update ;
+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
+----+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时候，查看下锁的情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;------------
TRANSACTIONS
------------
Trx id counter 133588361
Purge done for trx&amp;apos;s n:o &amp;lt; 133588356 undo n:o &amp;lt; 0 state: running but idle
History list length 892
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 421565826150000, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 421565826149088, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 133588360, ACTIVE 4 sec
2 lock struct(s), heap size 1136, 4 row lock(s)
MySQL thread id 135, OS thread handle 140001104295680, query id 1176 localhost dba cleaning up
TABLE LOCK table `lc_4`.`lc` trx id 133588360 lock mode IX
RECORD LOCKS space id 289 page no 3 n bits 72 index PRIMARY of table `lc_4`.`lc` trx id 133588360 lock_mode X  --next key lock ， 锁记录和范围
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;   --next-key lock, 锁住正无穷大
Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000001; asc     ;;  --next-key lock, 锁住1和1之前的区间，包括记录 (negtive,1]
 1: len 6; hex 000007f6657e; asc     e~;;
 2: len 7; hex e5000040220110; asc    @&amp;quot;  ;;
Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000002; asc     ;;  --next-key lock, 锁住2和1之前的区间，包括记录 (1,2]
 1: len 6; hex 000007f6657f; asc     e ;;
 2: len 7; hex e6000040330110; asc    @3  ;;
Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000003; asc     ;;  --next-key lock, 锁住3和2之间的区间，包括记录 (2,3]
 1: len 6; hex 000007f66584; asc     e ;;
 2: len 7; hex e9000040240110; asc    @$  ;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总结下来就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(negtive bounds,1] ， (1,2] ， (2,3]，(3,positive bounds) –锁住的记录和范围，相当于表锁  &lt;/li&gt;
&lt;li&gt;这时候，session 2 插入任何一条记录，会被锁住，所以幻读可以避免，尤其彻底解决了幻读的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RC&lt;/p&gt;
&lt;p&gt;RC 的锁算法：record locks&lt;br&gt;幻读对线上影响大吗？ oracle默认就是RC隔离级别&lt;/p&gt;
&lt;p&gt;不解决幻读的案例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dba:lc_4&amp;gt; set tx_isolation=&amp;apos;read-committed&amp;apos;;
Query OK, 0 rows affected (0.00 sec)
dba:lc_4&amp;gt; select * from lc for update ;
+----+
| id |
+----+
|  1 |
|  2 |
|  3 |
+----+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看锁的信息如下  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;------------
TRANSACTIONS
------------
Trx id counter 133588362
Purge done for trx&amp;apos;s n:o &amp;lt; 133588356 undo n:o &amp;lt; 0 state: running but idle
History list length 892
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 421565826150000, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 421565826149088, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 133588361, ACTIVE 3 sec
2 lock struct(s), heap size 1136, 3 row lock(s)
MySQL thread id 138, OS thread handle 140001238955776, query id 1192 localhost dba cleaning up
TABLE LOCK table `lc_4`.`lc` trx id 133588361 lock mode IX
RECORD LOCKS space id 289 page no 3 n bits 72 index PRIMARY of table `lc_4`.`lc` trx id 133588361 lock_mode X locks rec but not gap  --记录锁，只锁记录
Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000001; asc     ;;   -- 记录锁，锁住1
 1: len 6; hex 000007f6657e; asc     e~;;
 2: len 7; hex e5000040220110; asc    @&amp;quot;  ;;
Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000002; asc     ;;  -- 记录锁，锁住2
 1: len 6; hex 000007f6657f; asc     e ;;
 2: len 7; hex e6000040330110; asc    @3  ;;
Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000003; asc     ;; -- 记录锁，锁住3
 1: len 6; hex 000007f66584; asc     e ;;
 2: len 7; hex e9000040240110; asc    @$  ;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总结下来&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;锁住的是哪些？  [1,2,3] 这些记录被锁住  &lt;/li&gt;
&lt;li&gt;那么session 2 除了1，2，3 不能插入之外，其他的记录都能，比如； insert into lc select 4 , 那么再次select * from lc for udpate 的时候，就是4条记录了，由此产生幻读&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RC vs RR 安全性&lt;/p&gt;
&lt;p&gt;RC 和 binlog&lt;/p&gt;
&lt;p&gt;RC 模式，binlog 必须使用Row 模式&lt;br&gt;为什么RC的binlog必须使用Row&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;session 1:
begin;
delete from  tb_1 where id &amp;gt; 0;

session 2:
begin;
insert into tb_1 select 100;
commit;

session 1:
commit;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果RC模式下的binlog是statement模式，结果会是怎么样呢？&lt;br&gt;master :  结果是 100&lt;br&gt;slave  :  结果是 空&lt;br&gt;这样就导致master和slave结果不一致了: 因为在slave上，先执行insert into tb_1 select 100; 再执行delete from  tb_1 where id &amp;gt; 0; 当然等于空咯    &lt;/p&gt;
&lt;p&gt;如果RC模式下的binlog是ROW模式，结果会是怎么样呢？&lt;br&gt;master :  结果是 100&lt;br&gt;slave :  结果是 100&lt;br&gt;主从结果一致，因为binlog是row模式，slave并不是逻辑的执行上述sql，而记录的都是行的变化&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;RC 的优点&lt;/p&gt;
&lt;p&gt;1.由于降低了隔离级别，那么实现起来简单，对锁的开销小，基本上不会有Gap lock，那么导致死锁和锁等待的可能就小&lt;br&gt;2.当然RC也不是完全没有Gap lock，当purge 和 唯一性索引存在的时候会产生特殊的Gap lock，这个后面会具体讲&lt;/p&gt;
&lt;p&gt;RC 的缺点&lt;br&gt;1.会有幻读发生&lt;br&gt;2.事务内的每条select，都会产生新的read-view，造成资源浪费&lt;/p&gt;
&lt;p&gt;RR 的优点&lt;br&gt;1.一个事务，只有再开始的时候才会产生read-view，有且只有一个，所以这块消耗比较小&lt;br&gt;2.解决了幻读的问题, 实现了真正意义上的隔离级别&lt;/p&gt;
&lt;p&gt;RR 的缺点&lt;br&gt;由于RR的实现，是通过Gap-lock实现，经常会锁定一个范围，那么导致死锁和所等待的概率非常大&lt;br&gt;我们的选择&lt;br&gt;一般我们生产环境的标配，都是RC+Row 模式，谁用谁知道哦&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;数据库事务隔离级别分为四种（级别递减）：&lt;/p&gt;
&lt;p&gt;1、Serializable （串行化）：最严格的级别，事务串行执行，资源消耗最大；&lt;/p&gt;
&lt;p&gt;2、REPEATABLE READ（重复读） ：保证了一个事务不会修改已经由另一个
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="事务" scheme="http://idber.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>隔离级别</title>
    <link href="http://idber.github.io/2018/08/15-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html"/>
    <id>http://idber.github.io/2018/08/15-隔离级别.html</id>
    <published>2018-08-15T02:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.939Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;开始介绍之前，先让我们了解一些基本概念。ANSI SQL STANDARD定义了递增4类隔离级别（READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE)，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级别一般支持更高的并发处理，并拥有更低的系统开销。&lt;/p&gt;
&lt;h4 id=&quot;Read-Uncommitted（读未提交）&quot;&gt;&lt;a href=&quot;#Read-Uncommitted（读未提交）&quot; class=&quot;headerlink&quot; title=&quot;* Read Uncommitted（读未提交）&quot;&gt;&lt;/a&gt;* Read Uncommitted（读未提交）&lt;/h4&gt;&lt;p&gt;在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。&lt;/p&gt;
&lt;h4 id=&quot;Read-Committed（读已提交）&quot;&gt;&lt;a href=&quot;#Read-Committed（读已提交）&quot; class=&quot;headerlink&quot; title=&quot;* Read Committed（读已提交）&quot;&gt;&lt;/a&gt;* Read Committed（读已提交）&lt;/h4&gt;&lt;p&gt;一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。&lt;/p&gt;
&lt;h4 id=&quot;Repeatable-Read（可重读）&quot;&gt;&lt;a href=&quot;#Repeatable-Read（可重读）&quot; class=&quot;headerlink&quot; title=&quot;* Repeatable Read（可重读）&quot;&gt;&lt;/a&gt;* Repeatable Read（可重读）&lt;/h4&gt;&lt;p&gt;这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。&lt;/p&gt;
&lt;h4 id=&quot;Serializable（可串行化）&quot;&gt;&lt;a href=&quot;#Serializable（可串行化）&quot; class=&quot;headerlink&quot; title=&quot;* Serializable（可串行化）&quot;&gt;&lt;/a&gt;* Serializable（可串行化）&lt;/h4&gt;&lt;p&gt;这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 这四种隔离级别采取不同的锁类型来实现。并发控制中读取同一个表的数据，可能出现如下问题：&lt;/p&gt;
&lt;h4 id=&quot;脏读-Drity-Read-：&quot;&gt;&lt;a href=&quot;#脏读-Drity-Read-：&quot; class=&quot;headerlink&quot; title=&quot;脏读(Drity Read)：&quot;&gt;&lt;/a&gt;脏读(Drity Read)：&lt;/h4&gt;&lt;p&gt;事务T1修改了一行数据，事务T2在事务T1提交之前读到了该行数据。&lt;/p&gt;
&lt;h4 id=&quot;不可重复读-Non-repeatable-read&quot;&gt;&lt;a href=&quot;#不可重复读-Non-repeatable-read&quot; class=&quot;headerlink&quot; title=&quot;不可重复读(Non-repeatable read):&quot;&gt;&lt;/a&gt;不可重复读(Non-repeatable read):&lt;/h4&gt;&lt;p&gt;事务T1读取了一行数据。 事务T2接着修改或者删除了改行数据，当T1再次读取同一行数据的时候，读到的数据时修改之后的或者发现已经被删除。&lt;/p&gt;
&lt;h4 id=&quot;幻读-Phantom-Read&quot;&gt;&lt;a href=&quot;#幻读-Phantom-Read&quot; class=&quot;headerlink&quot; title=&quot;幻读(Phantom Read):&quot;&gt;&lt;/a&gt;幻读(Phantom Read):&lt;/h4&gt;&lt;p&gt;事务T1读取了满足某条件的一个数据集，事务T2插入了一行或者多行数据满足了T1的选择条件，导致事务T1再次使用同样的选择条件读取的时候，得到了比第一次读取更多的数据集。&lt;/p&gt;
&lt;p&gt;MySQL/INNODB支持ANSI SQL STANDARD规定的四种隔离级别（READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE).本篇文章重点关注一下MySQL REPEATABLE READ隔离级别与其他数据实现方式上的不同之处。&lt;/p&gt;
&lt;p&gt;下面看一下MySQL在REPEATABLE READ 隔离级别下的工作方式：&lt;/p&gt;
&lt;p&gt;开启两个session。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB01.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来看一下另外一个开源数据库PostgreSQL在REPEATABLE READ 隔离级别下的工作方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB02.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;同样测试了SQL SERVER，得到的结果与PostgreSQL是一致的。&lt;/p&gt;
&lt;p&gt;从上面的执行情况我们可以看到MySQL与PostgreSQL两者工作方式上有所不同。MySQL在执行UPDATE语句的时候对于session2的INSERT语句是可以看到的，也就是说发生了幻读。那么MySQL在隔离级别为REPEATABLE READ的情况下，表现出来的幻读现象是否属于一个BUG呢？曾经有人在2013年给官方提过一个关于该现象的BUG，请参考&lt;a href=&quot;https://bugs.mysql.com/bug.php?id=63870&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://bugs.mysql.com/bug.php?id=63870&lt;/a&gt; 。 从BUG页面的注释可以了解到，该现象是与MySQL对REPATABLE READ隔离级别的实现方式有关。而这种幻读现象对于REPATABLE READ隔离级别也是正确的方式。请看wikipedia上对于REPEATABLE READ的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Repeatable reads&lt;br&gt;In this isolation level, a lock-based concurrency control DBMS implementation keeps read and&lt;br&gt;write locks (acquired on selected data) until the end of the transaction. However, range-locks are not managed, so phantom reads can occur.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外我们接着看一下ANSI SQL STANDARD对于各种隔离级别发生幻读的规定：&lt;br&gt;&lt;img src=&quot;https://github.com/idber/idber.photo/blob/master/blog/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB03.png?raw=true&quot; alt=&quot;&quot;&gt;&lt;br&gt;我们从wikipedia以及ANSI SQL STANDARD可以看到对于REPEATABLE READ隔离级别下是允许出现幻读现象的。&lt;/p&gt;
&lt;p&gt;接下来我们从源码的角度分析一下Innodb对于REPEATABLE READ隔离级别的执行过程(代码只覆盖重要执行部分）。 以上面的例子为依据进行剖析： 对于第一条SELECT语句，InnoDB将调用row_search_for_mysql函数来返回扫描行。函数row_search_for_mysql调用相关代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UNIV_INTERN
dberr_t
row_search_for_mysql(
/*=================*/
  byte*   buf,    /* 用来存放记录的空间地址 */
  ulint   mode,   /* InnoDB页扫描顺序 */
  row_prebuilt_t* prebuilt, /* InnoDB扫描需要的所有信息都包含在这个结构体，比如表以及Index等信息 */
  ulint   match_mode, /* 对于Index的匹配模式，是精确匹配还是前缀索引匹配 */
  ulint   direction)  /* 指定扫描顺序，正序还是倒叙扫描 */
{
    ...
    /* 从这里我们看出开始一个新事务，并非是从执行BEGIN语句位置开始，而是从其后开始执行的第一条语句开始分配事务ID */
    trx_start_if_not_started(trx, ((trx-&amp;gt;mysql_thd
          &amp;amp;&amp;amp; thd_is_select(trx-&amp;gt;mysql_thd)
          ) || srv_read_only_mode) ? FALSE : TRUE); 

    ...
    // 如果是SQL语句第一次开始执行，需要考虑对TABLE增加意向所

     if (!prebuilt-&amp;gt;sql_stat_start) {
     // 这里标记SQL语句已经开始执行，处理一条SQL语句循环扫描记录的过程
    /* No need to set an intention lock or assign a read view */

    if (UNIV_UNLIKELY
        (trx-&amp;gt;read_view == NULL 
         &amp;amp;&amp;amp; prebuilt-&amp;gt;select_lock_type == LOCK_NONE)) {
      fputs(&amp;quot;InnoDB: Error: MySQL is trying to&amp;quot;            &amp;quot; perform a consistent read\n&amp;quot;            &amp;quot;InnoDB: but the read view is not assigned!\n&amp;quot;,            stderr);
      trx_print(stderr, trx, 600);
      fputc(&amp;apos;\n&amp;apos;, stderr);
      ut_error;
        }
  } else if (prebuilt-&amp;gt;select_lock_type == LOCK_NONE) {
    /* This is a consistent read */
    /* Assign a read view for the query */
    // 如果是第一次执行SELECT语句，构建READ_VIEW. 该READ_VIEW 用来判断记录的可见性
    trx_assign_read_view(trx);
    prebuilt-&amp;gt;sql_stat_start = FALSE;
  } else {
    ...
  }

    ...

     /* We are ready to look at a possible new index entry in the result
  set: the cursor is now placed on a user record */
    /* 从这里我们看一下InnoDB如何获取一条新纪录。由于上面例子中SESSION1的第一条语句是SELECT语句，InnoDB在REPEATABLE READ 隔离级别下，不对SELECT 语句加锁，所以这里执行SELECT语句的时候prebuilt-&amp;gt;select_lock_type为LOCK_NONE。下面我们直接看一下prebuilt-&amp;gt;select_lock_type为LOCK_NONE的情况下，InnoDB如何扫描行？ */
  if (prebuilt-&amp;gt;select_lock_type != LOCK_NONE) {
    ... //稍后会对prebuilt-&amp;gt;select_lock_type != LOCK_NONE的情况进行分析
    }
  else
    {
        /* This is a non-locking consistent read: if necessary, fetch
    a previous version of the record */

    if (trx-&amp;gt;isolation_level == TRX_ISO_READ_UNCOMMITTED) {

      /* 对于READ UNCOMMITTED隔离级别，我们什么都不需要，只要让他读取最新的记录版本即可 */

    } else if (index == clust_index) {

      /* Fetch a previous version of the row if the current
      one is not visible in the snapshot; if we have a very
      high force recovery level set, we try to avoid crashes
 by skipping this lookup */
      // 如果是全表扫描或主键扫描，这里需要看看当前记录是否对当前事务可见
      if (UNIV_LIKELY(srv_force_recovery &amp;lt; 5)
          &amp;amp;&amp;amp; !lock_clust_rec_cons_read_sees(
            rec, index, offsets, trx-&amp;gt;read_view)) {
        // 如果不可见，这里需要查找历史版本
        rec_t*  old_vers;
        /* The following call returns &amp;apos;offsets&amp;apos;
        associated with &amp;apos;old_vers&amp;apos; */
        err = row_sel_build_prev_vers_for_mysql(
          trx-&amp;gt;read_view, clust_index,
          prebuilt, rec, &amp;amp;offsets, &amp;amp;heap,
          &amp;amp;old_vers, &amp;amp;mtr);
                if (err != DB_SUCCESS) {

          goto lock_wait_or_error;
        }

        if (old_vers == NULL) {
          /* The row did not exist yet in
          the read view */
          // 如果当前记录对当前事务不可见，也没有历史版本，直接查找下一条记录
          goto next_rec;
        }

        rec = old_vers;
           } else {
      /* We are looking into a non-clustered index,
      and to get the right version of the record we
      have to look also into the clustered index: this
      is necessary, because we can only get the undo
      information via the clustered index record. */

      ut_ad(!dict_index_is_clust(index));
      // 这里处理是Secondary index扫描的情况
      if (!lock_sec_rec_cons_read_sees(
            rec, trx-&amp;gt;read_view)) {
        /* We should look at the clustered index.
                However, as this is a non-locking read,
        we can skip the clustered index lookup if
        the condition does not match the secondary
        index entry. */
        // 这里InnoDB做了一下优化，如果当前记录不满足ICP，直接查找下一条记录；如果满足ICP则需要继续根据聚集索引寻找历史版本
        switch (row_search_idx_cond_check(
            buf, prebuilt, rec, offsets)) {
        case ICP_NO_MATCH:
          goto next_rec;
        case ICP_OUT_OF_RANGE:
          err = DB_RECORD_NOT_FOUND;
          goto idx_cond_failed;
        case ICP_MATCH:
          goto requires_clust_rec;
        }
        ut_error;
      }
    }
  }
...
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来我们看一下UPDATE的执行过程。对于UPDATE操作执行流程的简单描述如下：&lt;/p&gt;
&lt;p&gt;根据WHERE条件扫描一条记录（row_search_for_mysql）&lt;/p&gt;
&lt;p&gt;更新当前获取的记录(ha_innobase::update_row)&lt;/p&gt;
&lt;p&gt;重新将更新后的记录写入InnoDB存储引擎(row_upd_step)&lt;/p&gt;
&lt;p&gt;那么我们按照上面的这个流程看一下源码方面的执行过程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UNIV_INTERN
dberr_t
row_search_for_mysql(
/*=================*/
  byte*   buf,    /* 用来存放记录的空间地址 */
  ulint   mode,   /* InnoDB页扫描顺序 */
  row_prebuilt_t* prebuilt, /* InnoDB扫描需要的所有信息都包含在这个结构体，比如表以及Index等信息 */
  ulint   match_mode, /* 对于Index的匹配模式，是精确匹配还是前缀索引匹配 */
  ulint   direction)  /* 指定扫描顺序，正序还是倒叙扫描 */
{
    ...
    /* 从这里我们看出开始一个新事务，并非是从执行BEGIN语句位置开始，而是从其后开始执行的第一条语句开始分配事务ID */
    trx_start_if_not_started(trx, ((trx-&amp;gt;mysql_thd
          &amp;amp;&amp;amp; thd_is_select(trx-&amp;gt;mysql_thd)
          ) || srv_read_only_mode) ? FALSE : TRUE); 

    ...
    // 如果是SQL语句第一次开始执行，需要考虑对TABLE增加意向所

     if (!prebuilt-&amp;gt;sql_stat_start) {
     // 这里标记SQL语句已经开始执行，处理一条SQL语句循环扫描记录的过程
    /* No need to set an intention lock or assign a read view */

    if (UNIV_UNLIKELY
        (trx-&amp;gt;read_view == NULL 
         &amp;amp;&amp;amp; prebuilt-&amp;gt;select_lock_type == LOCK_NONE)) {
      ...
        }
  } else if (prebuilt-&amp;gt;select_lock_type == LOCK_NONE) {
    ...
  } else {
    // 这里开始非INSERT的DML操作，因为DML会对记录增加记录排他锁。具体需要增加什么类型的锁，可以参考https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html
 wait_table_again:
    // 这里要对TABLE加意向锁
    err = lock_table(0, index-&amp;gt;table,
         prebuilt-&amp;gt;select_lock_type == LOCK_S
         ? LOCK_IS : LOCK_IX, thr);

    if (err != DB_SUCCESS) {

      table_lock_waited = TRUE;
      goto lock_table_wait;
    }    
    prebuilt-&amp;gt;sql_stat_start = FALSE;
  }

    ...
  if (prebuilt-&amp;gt;select_lock_type != LOCK_NONE) {
     ulint lock_type;

    if (!set_also_gap_locks
        || srv_locks_unsafe_for_binlog
        || trx-&amp;gt;isolation_level &amp;lt;= TRX_ISO_READ_COMMITTED
        || (unique_search &amp;amp;&amp;amp; !rec_get_deleted_flag(rec, comp))) {
      // 这里对于READ_UNCOMMITTED以及READ_COMMITTED,或者唯一键扫描不需要使用gap锁
      goto no_gap_lock;
    } else {
      lock_type = LOCK_ORDINARY;
    }

    /* If we are doing a &amp;apos;greater or equal than a primary key
    value&amp;apos; search from a clustered index, and we find a record
    that has that exact primary key value, then there is no need
    to lock the gap before the record, because no insert in the
    gap can be in our search range. That is, no phantom row can
    appear that way.

    An example: if col1 is the primary key, the search is WHERE
    col1 &amp;gt;= 100, and we find a record where col1 = 100, then no
    need to lock the gap before that record. */

    if (index == clust_index
        &amp;amp;&amp;amp; mode == PAGE_CUR_GE
        &amp;amp;&amp;amp; direction == 0
        &amp;amp;&amp;amp; dtuple_get_n_fields_cmp(search_tuple)
        == dict_index_get_n_unique(index)
        &amp;amp;&amp;amp; 0 == cmp_dtuple_rec(search_tuple, rec, offsets)) {
no_gap_lock:
      lock_type = LOCK_REC_NOT_GAP;
    }

        err = sel_set_rec_lock(btr_pcur_get_block(pcur),
               rec, index, offsets,
               prebuilt-&amp;gt;select_lock_type,
               lock_type, thr);

    switch (err) {
      const rec_t*  old_vers;
    case DB_SUCCESS_LOCKED_REC:
      if (srv_locks_unsafe_for_binlog
          || trx-&amp;gt;isolation_level
          &amp;lt;= TRX_ISO_READ_COMMITTED) {
        /* Note that a record of
        prebuilt-&amp;gt;index was locked. */
        prebuilt-&amp;gt;new_rec_locks = 1;
      }
      err = DB_SUCCESS;
    case DB_SUCCESS:
     // 加锁成功后就认为记录可见了，并未像SELECT语句一样根据事务开始的READ_VIEW进行可见性判断。所以对于DML来说，所有提交的事务都是可见的。
      break;
    case DB_LOCK_WAIT:
          /* Never unlock rows that were part of a conflict. */
      // 如果存在锁冲突，也就是其他事务正在更新同一行
      prebuilt-&amp;gt;new_rec_locks = 0;

      if (UNIV_LIKELY(prebuilt-&amp;gt;row_read_type
          != ROW_READ_TRY_SEMI_CONSISTENT)
          || unique_search
          || index != clust_index) {

        goto lock_wait_or_error;
      }

      /* The following call returns &amp;apos;offsets&amp;apos;
      associated with &amp;apos;old_vers&amp;apos; */
      // 这里需要查看是否有别的事务提交了，以便获取最新版本的记录
      row_sel_build_committed_vers_for_mysql(
        clust_index, prebuilt, rec,
        &amp;amp;offsets, &amp;amp;heap, &amp;amp;old_vers, &amp;amp;mtr);

      /* Check whether it was a deadlock or not, if not
      a deadlock and the transaction had to wait then
      release the lock it is waiting on. */
            err = lock_trx_handle_wait(trx);

      switch (err) {
      case DB_SUCCESS:
        /* The lock was granted while we were
        searching for the last committed version.
        Do a normal locking read. */

        offsets = rec_get_offsets(
          rec, index, offsets, ULINT_UNDEFINED,
          &amp;amp;heap);
        goto locks_ok;
      case DB_DEADLOCK:
        goto lock_wait_or_error;
      case DB_LOCK_WAIT:
        err = DB_SUCCESS;
        break;
      default:
        ut_error;
      }
            if (old_vers == NULL) {
        /* The row was not yet committed */

        goto next_rec;
      }
      did_semi_consistent_read = TRUE;
      rec = old_vers;
      break;
    default:

      goto lock_wait_or_error;
    }

    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面的代码我们可以看到，对于UPDATE操作更新的记录包含幻读读取到的已提交事务的最新记录。那么接下来看为什么UPDATE之后的SELECT语句对于UPDATE之后的所有语句都可见了？ 原因是前面的UPDATE语句执行之后，会将当前记录上存储的事务信息更新为当前的事务，而当前事务所做的任何更新，对本事务所有SELECT查询都变的可见，因此最后输出的结果是UPDATE执行后更新的所有记录。&lt;/p&gt;
&lt;p&gt;当前各种数据库对于隔离级别的支持不尽相同，比如ORACLE，它只实现了READ COMMITTED和SERIALIZABLE两种ANSI SQL STANDARD规定的隔离级别（这里ORACLE还实现了一种自定义的READ ONLY隔离级别，具体请参考&lt;a href=&quot;https://docs.oracle.com/cd/B28359_01/server.111/b28318/consist.htm#CNCPT621&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://docs.oracle.com/cd/B28359_01/server.111/b28318/consist.htm#CNCPT621&lt;/a&gt; ） ， 而没有实现REPEATABLE READ。对于相同的隔离级别，不同的数据库有着自己不同的实现方式。所以我们在理解隔离级别的时候需要针对具体的数据库。综上所述，我们看到了MySQL InnoDB引擎对于REPEATABLE READ隔离级别有着不同于其他数据库的实现方式。而该实现方式符合ANSI SQL STANDARD，并非属于实现上的BUG。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;开始介绍之前，先让我们了解一些基本概念。ANSI SQL STANDARD定义了递增4类隔离级别（READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE)，包括了一些具体规则，用来限定事务内外
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="事务" scheme="http://idber.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB Buffer Pool Flush策略漫谈</title>
    <link href="http://idber.github.io/2018/08/14-InnoDB%20buffer%20pool%20flush%E7%AD%96%E7%95%A5%E6%BC%AB%E8%B0%88.html"/>
    <id>http://idber.github.io/2018/08/14-InnoDB buffer pool flush策略漫谈.html</id>
    <published>2018-08-14T02:01:56.000Z</published>
    <updated>2019-04-22T01:41:16.927Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;我们知道InnoDB使用buffer pool来缓存从磁盘读取到内存的数据页。buffer pool通常由数个内存块加上一组控制结构体对象组成。内存块的个数取决于buffer pool instance的个数，不过在5.7版本中开始默认以128M（可配置）的chunk单位分配内存块，这样做的目的是为了支持buffer pool的在线动态调整大小。&lt;/p&gt;
&lt;p&gt;Buffer pool的每个内存块通过mmap的方式分配内存，因此你会发现，在实例启动时虚存很高，而物理内存很低。这些大片的内存块又按照16KB划分为多个frame，用于存储数据页。&lt;/p&gt;
&lt;p&gt;虽然大多数情况下buffer pool是以16KB来存储数据页，但有一种例外：使用压缩表时，需要在内存中同时存储压缩页和解压页，对于压缩页，使用Binary buddy allocator算法来分配内存空间。例如我们读入一个8KB的压缩页，就从buffer pool中取一个16KB的block，取其中8KB，剩下的8KB放到空闲链表上；如果紧跟着另外一个4KB的压缩页读入内存，就可以从这8KB中分裂4KB，同时将剩下的4KB放到空闲链表上。&lt;/p&gt;
&lt;p&gt;为了管理buffer pool，每个buffer pool instance 使用如下几个链表来管理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LRU链表包含所有读入内存的数据页；&lt;/li&gt;
&lt;li&gt;Flush_list包含被修改过的脏页；&lt;/li&gt;
&lt;li&gt;unzip_LRU包含所有解压页；&lt;/li&gt;
&lt;li&gt;Free list上存放当前空闲的block。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外为了避免查询数据页时扫描LRU，还为每个buffer pool instance维护了一个page hash，通过space id 和page no可以直接找到对应的page。&lt;/p&gt;
&lt;p&gt;一般情况下，当我们需要读入一个Page时，首先根据space id 和page no找到对应的buffer pool instance。然后查询page hash，如果page hash中没有，则表示需要从磁盘读取。在读盘前首先我们需要为即将读入内存的数据页分配一个空闲的block。当free list上存在空闲的block时，可以直接从free list上摘取；如果没有，就需要从unzip_lru 或者 lru上驱逐page。&lt;/p&gt;
&lt;p&gt;这里需要遵循一定的原则（参考函数buf_LRU_scan_and_free_block , 5.7.5）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先尝试从unzip_lru上驱逐解压页；&lt;/li&gt;
&lt;li&gt;如果没有，再尝试从Lru链表上驱逐Page；&lt;/li&gt;
&lt;li&gt;如果还是无法从Lru上获取到空闲block，用户线程就会参与刷脏，尝试做一次SINGLE PAGE FLUSH，单独从Lru上刷掉一个脏页，然后再重试。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Buffer pool中的page被修改后，不是立刻写入磁盘，而是由后台线程定时写入，和大多数数据库系统一样，脏页的写盘遵循日志先行WAL原则，因此在每个block上都记录了一个最近被修改时的Lsn，写数据页时需要确保当前写入日志文件的redo不低于这个Lsn。&lt;/p&gt;
&lt;p&gt;然而基于WAL原则的刷脏策略可能带来一个问题：当数据库的写入负载过高时，产生redo log的速度极快，redo log可能很快到达同步checkpoint点。这时候需要进行刷脏来推进Lsn。由于这种行为是由用户线程在检查到redo log空间不够时触发，大量用户线程将可能陷入到这段低效的逻辑中，产生一个明显的性能拐点。&lt;/p&gt;
&lt;h2 id=&quot;Page-Cleaner线程&quot;&gt;&lt;a href=&quot;#Page-Cleaner线程&quot; class=&quot;headerlink&quot; title=&quot;Page Cleaner线程&quot;&gt;&lt;/a&gt;Page Cleaner线程&lt;/h2&gt;&lt;p&gt;在MySQL5.6中，开启了一个独立的page cleaner线程来进行刷lru list 和flush list。默认每隔一秒运行一次，5.6版本里提供了一大堆的参数来控制page cleaner的flush行为，包括：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;innodb_adaptive_flushing_lwm， 
innodb_max_dirty_pages_pct_lwm
innodb_flushing_avg_loops
innodb_io_capacity_max
innodb_lru_scan_depth
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我们不一一介绍，总的来说，如果你发现redo log推进的非常快，为了避免用户线程陷入刷脏，可以通过调大innodb_io_capacity_max来解决，该参数限制了每秒刷新的脏页上限，调大该值可以增加Page cleaner线程每秒的工作量。如果你发现你的系统中free list不足，总是需要驱逐脏页来获取空闲的block时，可以适当调大innodb_lru_scan_depth 。该参数表示从每个buffer pool instance的lru上扫描的深度，调大该值有助于多释放些空闲页，避免用户线程去做single page flush。&lt;/p&gt;
&lt;p&gt;为了提升扩展性和刷脏效率，在5.7.4版本里引入了多个page cleaner线程，从而达到并行刷脏的效果。目前Page cleaner并未和buffer pool绑定，其模型为一个协调线程 + 多个工作线程，协调线程本身也是工作线程。因此如果innodb_page_cleaners设置为4，那么就是一个协调线程，加3个工作线程，工作方式为生产者-消费者。工作队列长度为buffer pool instance的个数，使用一个全局slot数组表示。&lt;/p&gt;
&lt;p&gt;协调线程在决定了需要flush的page数和lsn_limit后，会设置slot数组，将其中每个slot的状态设置为PAGE_CLEANER_STATE_REQUESTED, 并设置目标page数及lsn_limit，然后唤醒工作线程 (pc_request)&lt;/p&gt;
&lt;p&gt;工作线程被唤醒后，从slot数组中取一个未被占用的slot，修改其状态，表示已被调度，然后对该slot所对应的buffer pool instance进行操作。直到所有的slot都被消费完后，才进入下一轮。通过这种方式，多个page cleaner线程实现了并发flush buffer pool，从而提升flush dirty page/lru的效率。&lt;/p&gt;
&lt;h2 id=&quot;MySQL5-7的InnoDB-flush策略优化&quot;&gt;&lt;a href=&quot;#MySQL5-7的InnoDB-flush策略优化&quot; class=&quot;headerlink&quot; title=&quot;MySQL5.7的InnoDB flush策略优化&quot;&gt;&lt;/a&gt;MySQL5.7的InnoDB flush策略优化&lt;/h2&gt;&lt;p&gt;在之前版本中，因为可能同时有多个线程操作buffer pool刷page （在刷脏时会释放buffer pool mutex），每次刷完一个page后需要回溯到链表尾部，使得扫描bp链表的时间复杂度最差为O（N*N）。&lt;/p&gt;
&lt;p&gt;在5.6版本中针对Flush list的扫描做了一定的修复，使用一个指针来记录当前正在flush的page，待flush操作完成后，再看一下这个指针有没有被别的线程修改掉，如果被修改了，就回溯到链表尾部，否则无需回溯。但这个修复并不完整，在最差的情况下，时间复杂度依旧不理想。&lt;/p&gt;
&lt;p&gt;因此在5.7版本中对这个问题进行了彻底的修复，使用多个名为hazard pointer的指针，在需要扫描LIST时，存储下一个即将扫描的目标page，根据不同的目的分为几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flush_hp: 用作批量刷FLUSH LIST&lt;/li&gt;
&lt;li&gt;lru_hp: 用作批量刷LRU LIST&lt;/li&gt;
&lt;li&gt;lru_scan_itr: 用于从LRU链表上驱逐一个可替换的page，总是从上一次扫描结束的位置开始，而不是LRU尾部&lt;/li&gt;
&lt;li&gt;single_scan_itr: 当buffer pool中没有空闲block时，用户线程会从FLUSH LIST上单独驱逐一个可替换的page 或者 flush一个脏页，总是从上一次扫描结束的位置开始，而不是LRU尾部。&lt;br&gt;后两类的hp都是由用户线程在尝试获取空闲block时调用，只有在推进到某个buf_page_t::old被设置成true的page (大约从Lru链表尾部起至总长度的八分之三位置的page)时， 再将指针重置到Lru尾部。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些指针在初始化buffer pool时分配，每个buffer pool instance都拥有自己的hp指针。当某个线程对buffer pool中的page进行操作时，例如需要从LRU中移除Page时，如果当前的page被设置为hp，就要将hp更新为当前Page的前一个page。当完成当前page的flush操作后，直接使用hp中存储的page指针进行下一轮flush。&lt;/p&gt;
&lt;h2 id=&quot;社区优化&quot;&gt;&lt;a href=&quot;#社区优化&quot; class=&quot;headerlink&quot; title=&quot;社区优化&quot;&gt;&lt;/a&gt;社区优化&lt;/h2&gt;&lt;p&gt;一如既往的，Percona Server在5.6版本中针对buffer pool flush做了不少的优化，主要的修改包括如下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;优化刷LRU流程buf_flush_LRU_tail 该函数由page cleaner线程调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原生的逻辑：依次flush 每个buffer pool instance，每次扫描的深度通过参数innodb_lru_scan_depth来配置。而在每个instance内，又分成多个chunk来调用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;修改后的逻辑为：每次flush一个buffer pool的LRU时，只刷一个chunk，然后再下一个instance，刷完所有instnace后，再回到前面再刷一个chunk。简而言之，把集中的flush操作进行了分散，其目的是分散压力，避免对某个instance的集中操作，给予其他线程更多访问buffer pool的机会。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;允许设定刷LRU/FLUSH LIST的超时时间，防止flush操作时间过长导致别的线程（例如尝试做single page flush的用户线程）stall住；当到达超时时间时,page cleaner线程退出flush。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免用户线程参与刷buffer pool 当用户线程参与刷buffer pool时，由于线程数的不可控，将产生严重的竞争开销，例如free list不足时做single page flush，以及在redo空间不足时，做dirty page flush，都会严重影响性能。Percona Server允许选择让page cleaner线程来做这些工作，用户线程只需要等待即可。出于效率考虑，用户还可以设置page cleaner线程的cpu调度优先级。 另外在Page cleaner线程经过优化后，可以知道系统当前处于同步刷新状态，可以去做更激烈的刷脏(furious flush)，用户线程参与到其中，可能只会起到反作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;允许设置page cleaner线程，purge线程，io线程，master线程的CPU调度优先级，并优先获得InnoDB的mutex。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用新的独立后台线程来刷buffer pool的LRU链表，将这部分工作负担从page cleaner线程剥离。 实际上就是直接转移刷LRU的代码到独立线程了。从之前Percona的版本来看，都是在不断的强化后台线程，让用户线程少参与到刷脏/checkpoint这类耗时操作中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;我们知道InnoDB使用buffer pool来缓存从磁盘读取到内存的数据页。buffer pool通常由数个内存块加上一组控制结
    
    </summary>
    
      <category term="MySQL" scheme="http://idber.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://idber.github.io/tags/MySQL/"/>
    
      <category term="性能优化" scheme="http://idber.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
